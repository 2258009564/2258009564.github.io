<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Alisa的数字花园</title>
      <link>https://quartz.jzhao.xyz</link>
      <description>最近的10条笔记 on Alisa的数字花园</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>1227</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/1227</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/1227</guid>
    <description><![CDATA[ void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; int maxnum = 0; vector&lt;int&gt; h(n), k = h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; h[i] &gt;&gt; k[i]; maxnum = max({maxnum, h[i], k[i]}); } int l = 1, r = maxnum, m, ans; while (l &lt;= r) { m = l + (r - l) / 2; auto check = [&amp;]() { ... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>503</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/503</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/503</guid>
    <description><![CDATA[ void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n + 2); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; for (int i = n; i &gt;= 1; i--) v[i] -= v[i - 1]; struct datas { int d, s, t; }; vector&lt;datas&gt; k(m + 1); for (int i = 1; i &lt;= m; i++) cin &gt;&gt; k[i].d &gt;&g... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>5407</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/5407</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/5407</guid>
    <description><![CDATA[ void solve() { auto check = [&amp;]() -&gt; bool { }; }. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>562</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E5%89%8D%E7%BC%80%E5%92%8C/562</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E5%89%8D%E7%BC%80%E5%92%8C/562</guid>
    <description><![CDATA[ void solve() { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; }. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>判断整除 数位法</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%88%A4%E6%96%AD%E6%95%B4%E9%99%A4-%E6%95%B0%E4%BD%8D%E6%B3%95</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%88%A4%E6%96%AD%E6%95%B4%E9%99%A4-%E6%95%B0%E4%BD%8D%E6%B3%95</guid>
    <description><![CDATA[ 对于所有正整数 1都是因子 数位和是三的倍数 那么3就是因子 末尾是5或者0 5就是因子 对于7 一个n位数(n &gt;= 6) 有abbbccc → a （三个连续的b可以和三个连续的c约掉) 判断a是否可以整除7即可 数位和是9的倍数 那么9就是因子. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>学习笔记</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</guid>
    <description><![CDATA[ 好用的小操作 求数位之和 int dig(int x) { return (x + 8) % 9 + 1; // 输入123 返回6 } 原理： 任意一个数字 x 可以写成它的各位数字的加权和，形式如下： x = a_k * 10^k + a_(k-1) * 10^(k-1) + .. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>很杂乱的板子</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%BE%88%E6%9D%82%E4%B9%B1%E7%9A%84%E6%9D%BF%E5%AD%90</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%BE%88%E6%9D%82%E4%B9%B1%E7%9A%84%E6%9D%BF%E5%AD%90</guid>
    <description><![CDATA[ // 大数加法 string largeadd(string &amp;a, string &amp;b) { if (a.size() &lt; b.size()) swap(a, b); int p = 0; for (size_t i = 0; i &lt; b.size(); i++) { int ai = a[a.size() - i - 1] - &#039;0&#039;; int bi = b[b.size() - i - 1] - &#039;0&#039;; int sum = ai + bi + p; if (sum &gt;= 10) { p = 1; sum -= 1... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>PBDS</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PBDS</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PBDS</guid>
    <description><![CDATA[ PBDS (Policy-Based Data Structures) PBDS 是 GCC 编译器提供的一套基于策略的数据结构库，包含了许多高效的数据结构，在算法竞赛中非常实用。 引入头文件 #include &lt;ext/pb_ds/assoc_container.hpp&gt; #include &lt;ext/pb_ds/tree_policy.hpp&gt; using namespace __gnu_pbds; 核心数据结构 1. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>并查集</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86</guid>
    <description><![CDATA[ 并查集 顾名思义 就是对集合的合并和查询 可以在均摊 o1 的复杂度下解决此类问题 初始化 我们需要一个 father 数组 来记录各个元素所在集合 的 代表元素 假设我们有 n 个元素 从 1 开始 那么不妨如下初始化： DSU(int n): father(n + 1) { iota(all(father), 0ll); } int find(int x) 这个函数可以查询 x 所在的集合 其实就是查出 x 的代表元素 因此 有如下递归代码： int find(int x) { if (father[x] == x) return x; else { // 继续往上查找 return fi... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>树状数组</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84</guid>
    <description><![CDATA[ 树状数组 (Binary Indexed Tree / Fenwick Tree) 树状数组是一种用于高效处理前缀和查询和单点修改的数据结构，时间复杂度为 O(log n)。 核心思想 树状数组利用二进制的性质，通过 lowbit 函数来管理区间。每个位置 i 管理的区间长度为 lowbit(i)。 lowbit 函数 int lowbit(int x) { return x &amp; (-x); // 获取 x 的二进制表示中最低位的 1 } 基本操作 初始化 class BIT { private: vector&lt;int&gt; tree; int n; public: BIT(i... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item>
    </channel>
  </rss>