<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Alisa的数字花园</title>
      <link>https://quartz.jzhao.xyz</link>
      <description>最近的10条笔记 on Alisa的数字花园</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>2125 d2</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98%EF%BC%81/cf/2125-d2</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98%EF%BC%81/cf/2125-d2</guid>
    <description><![CDATA[ A B C D 概率怎么算？ 比方说有n条线段 选择每一条线段的概率分别是 p[i] 那么我们4条线段 选择2和4 的总概率就是 P = (1 - p[1]) * p[2] * (1 - p[3]) * p[4] 我们钦定一个初始概率 P_{0} = \prod (1-p[i]) 最后要求的概率是上面P 那么每一个概率就要乘上一个系数： P = P_{0} \times (p[2]\times\frac{1}{1-p[2]}) \times (p[4]\times\frac{1}{1-p[4]}) 又有 p[i] = \frac{p_i}{q_{i}} 化简即可。 总之 记 w_{i} = (... ]]></description>
    <pubDate>Tue, 22 Jul 2025 17:43:40 GMT</pubDate>
  </item><item>
    <title>关于</title>
    <link>https://quartz.jzhao.xyz/%E5%85%B3%E4%BA%8E</link>
    <guid>https://quartz.jzhao.xyz/%E5%85%B3%E4%BA%8E</guid>
    <description><![CDATA[ 一个学生，现阶段最喜欢做的事是躺着。. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:31:09 GMT</pubDate>
  </item><item>
    <title>20250722</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98%EF%BC%81/nowcoder/2025%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1/20250722</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98-%E8%A1%A5%E9%A2%98%EF%BC%81/nowcoder/2025%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1/20250722</guid>
    <description><![CDATA[ F 记 a + b = tot 分 n &gt;= tot 和 n &lt; tot 两类讨论。 对于 n &lt; tot 如果 n &lt;= a 那么一定无法做到；如果 n &gt; a 那么直接可以做到 输出0 对于 n &gt;= tot 我们直接令 n %= tot 表示可以经历完整的 n / tot 轮；对于剩下的余数 当 n &gt; a 时一个都不用删，当 n &lt;= a 时候必须全部删完。 D 签到。 根据题目意思，我们可以发现 当已经有现成的 a 个并列的1 我们总可以先把他变成0然后再跟前后连续的一个0组成a + 1 个并列的0 也就是说 只要找到 a 个现成的连续... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:26:46 GMT</pubDate>
  </item><item>
    <title>1227</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/1227</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/1227</guid>
    <description><![CDATA[ void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; int maxnum = 0; vector&lt;int&gt; h(n), k = h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; h[i] &gt;&gt; k[i]; maxnum = max({maxnum, h[i], k[i]}); } int l = 1, r = maxnum, m, ans; while (l &lt;= r) { m = l + (r - l) / 2; auto check = [&amp;]() { ... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>503</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/503</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/503</guid>
    <description><![CDATA[ void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; v(n + 2); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; for (int i = n; i &gt;= 1; i--) v[i] -= v[i - 1]; struct datas { int d, s, t; }; vector&lt;datas&gt; k(m + 1); for (int i = 1; i &lt;= m; i++) cin &gt;&gt; k[i].d &gt;&g... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>5407</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/5407</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E4%BA%8C%E5%88%86/5407</guid>
    <description><![CDATA[ void solve() { auto check = [&amp;]() -&gt; bool { }; }. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>562</title>
    <link>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E5%89%8D%E7%BC%80%E5%92%8C/562</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/ACW2024/%E5%89%8D%E7%BC%80%E5%92%8C/562</guid>
    <description><![CDATA[ void solve() { int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; }. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>判断整除 数位法</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%88%A4%E6%96%AD%E6%95%B4%E9%99%A4-%E6%95%B0%E4%BD%8D%E6%B3%95</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%88%A4%E6%96%AD%E6%95%B4%E9%99%A4-%E6%95%B0%E4%BD%8D%E6%B3%95</guid>
    <description><![CDATA[ 对于所有正整数 1都是因子 数位和是三的倍数 那么3就是因子 末尾是5或者0 5就是因子 对于7 一个n位数(n &gt;= 6) 有abbbccc → a （三个连续的b可以和三个连续的c约掉) 判断a是否可以整除7即可 数位和是9的倍数 那么9就是因子. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>学习笔记</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</guid>
    <description><![CDATA[ 好用的小操作 求数位之和 int dig(int x) { return (x + 8) % 9 + 1; // 输入123 返回6 } 原理： 任意一个数字 x 可以写成它的各位数字的加权和，形式如下： x = a_k * 10^k + a_(k-1) * 10^(k-1) + .. ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item><item>
    <title>很杂乱的板子</title>
    <link>https://quartz.jzhao.xyz/ACM-research/%E5%BE%88%E6%9D%82%E4%B9%B1%E7%9A%84%E6%9D%BF%E5%AD%90</link>
    <guid>https://quartz.jzhao.xyz/ACM-research/%E5%BE%88%E6%9D%82%E4%B9%B1%E7%9A%84%E6%9D%BF%E5%AD%90</guid>
    <description><![CDATA[ // 大数加法 string largeadd(string &amp;a, string &amp;b) { if (a.size() &lt; b.size()) swap(a, b); int p = 0; for (size_t i = 0; i &lt; b.size(); i++) { int ai = a[a.size() - i - 1] - &#039;0&#039;; int bi = b[b.size() - i - 1] - &#039;0&#039;; int sum = ai + bi + p; if (sum &gt;= 10) { p = 1; sum -= 1... ]]></description>
    <pubDate>Tue, 22 Jul 2025 14:15:19 GMT</pubDate>
  </item>
    </channel>
  </rss>