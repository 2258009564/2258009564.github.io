{"1":{"slug":"1","filePath":"1.md","title":"1","links":[],"tags":[],"content":"// 大数加法\nstring largeadd(string &amp;a, string &amp;b)\n{\n    if (a.size() &lt; b.size())\n        swap(a, b);\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        int bi = b[b.size() - i - 1] - &#039;0&#039;;\n        int sum = ai + bi + p;\n        if (sum &gt;= 10)\n        {\n            p = 1;\n            sum -= 10;\n        }\n        else\n            p = 0;\n        a[a.size() - 1 - i] = sum + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == &#039;9&#039; &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;0&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai + p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    if (p == 1)\n        a.insert(a.begin(), &#039;1&#039;);\n    return a;\n}\n// 大数减法\nstring largemin(string a, string b)\n{\n    int flag = 0;\n    if (b.size() &gt;= a.size() &amp;&amp; b &gt;= a)\n    {\n        swap(a, b);\n        flag = 1;\n    }\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - 1 - i] - &#039;0&#039;;\n        int bi = b[b.size() - 1 - i] - &#039;0&#039;;\n        int diff = ai - bi - p;\n        if (diff &lt; 0)\n        {\n            p = 1;\n            diff += 10;\n        }\n        else\n            p = 0;\n        a[a.size() - i - 1] = diff + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == 0 &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;9&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai - p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    while (*a.begin() == &#039;0&#039; &amp;&amp; a.size() &gt; 1)\n        a.erase(a.begin());\n    if (flag)\n        a.insert(a.begin(), &#039;-&#039;);\n    return a;\n}\n \n// DSU并查集\nclass DSU\n{\nprivate:\n    vector&lt;int&gt; parent, rank, size;\n    int count;\n \npublic:\n    DSU(int n) : parent(n + 1), rank(n + 1, 0), size(n + 1, 1), count(n)\n    {\n        iota(all(parent), 0ll);\n    }\n \n    int find(int x)\n    {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    }\n \n    void merge(int i, int j)\n    {\n        int ri = find(i), rj = find(j);\n        if (ri == rj)\n        {\n            return;\n        }\n \n        if (rank[ri] &lt; rank[rj])\n        {\n            swap(ri, rj);\n        }\n        parent[rj] = ri;\n        size[ri] += size[rj];\n        if (rank[ri] == rank[rj])\n        {\n            rank[ri]++;\n        }\n        count--;\n    }\n \n    bool issame(int i, int j)\n    {\n        return find(i) == find(j);\n    }\n \n    int getsize(int x)\n    {\n        return size[find(x)];\n    }\n \n    int getgroups()\n    {\n        return count;\n    }\n};\n// DSU end\n \n// COMB 组合数 快速幂，乘法逆元 都在里面\nconst int N = 1e6;\nvector&lt;int&gt; f(N), invf(N);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n    int ans = 1;\n    while (exp)\n    {\n        if (exp &amp; 1)\n        {\n            ans = ans * base % MOD;\n        }\n        base = base * base % MOD;\n        exp &gt;&gt;= 1;\n    }\n    return ans;\n}\n \nint inv(int x)\n{\n    return ksm(x, MOD - 2) % MOD;\n}\n \nvoid pre()\n{\n    if (inited)\n    {\n        return;\n    }\n    inited = 1;\n    f[0] = 1;\n    for (int i = 1; i &lt; N; i++)\n    {\n        f[i] = f[i - 1] * i % MOD;\n    }\n \n    invf[N - 1] = inv(f[N - 1]);\n    for (int i = N - 2; i &gt;= 0; i--)\n    {\n        invf[i] = invf[i + 1] * (i + 1) % MOD;\n    }\n}\n \nint comb(int n, int k)\n{\n    if (!inited)\n    {\n        pre();\n    }\n    if (k &lt; 0 or k &gt; n)\n    {\n        return 0;\n    }\n \n    return f[n] * invf[k] % MOD * invf[n - k] % MOD;\n}\n// comb end ----\n \n// 马拉车\n \n// 预处理\nstring preprocess(const string &amp;s)\n{\n    string t = &quot;^&quot;;\n    for (char c : s)\n    {\n        t += &quot;#&quot; + string(1, c);\n    }\n    t += &quot;#$&quot;;\n    return t;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    string T = preprocess(s);\n    int n = T.size();\n    vector&lt;int&gt; P(n, 0); // P[i] 记录以 t[i] 为中心的回文半径\n    int C = 0, R = 0;    // C 是回文中心，R 是回文串的最右边界\n    for (size_t i = 1; i &lt; n - 1; i++)\n    {\n        // 确定对称位置\n        int Mirror = 2 * C - i;\n        if (i &lt; R)\n        {\n            P[i] = min(P[Mirror], R - i);\n        }\n        // 尝试扩展边界\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n        {\n            P[i]++;\n        }\n        // 如果当前回文串扩展超过了 R，更新中心和右边界\n        if (i + P[i] &gt; R)\n        {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    // 找到最长的回文子串\n    int maxLen = 0;\n    int Centerindex = 0;\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        if (P[i] &gt; maxLen)\n        {\n            maxLen = P[i];\n            Centerindex = i;\n        }\n    }\n    // 构造回文串\n    int start = (Centerindex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n \nsigned main()\n{\n    // ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n// end ---\n \n// BIT 树状数组\n \nclass BIT\n{\nprivate:\n    vector&lt;int&gt; c;\n    int n;\n \n    int lowbit(int x)\n    {\n        return x &amp; -x;\n    }\n \npublic:\n    BIT(int size) : n(size)\n    {\n        c.resize(n + 1, 0);\n    }\n \n    BIT(vector&lt;int&gt; &amp;arr) : n(arr.size())\n    {\n        c.resize(n + 1, 0);\n        for (int i = 1; i &lt;= n; i++)\n        {\n            add(i, arr[i - 1]);\n        }\n    }\n \n    void add(int i, int val)\n    {\n        while (i &lt;= n)\n        {\n            c[i] += val;\n            i += lowbit(i);\n        }\n    }\n \n    int sum(int i)\n    {\n        int ans = 0;\n        while (i)\n        {\n            ans += c[i];\n            i -= lowbit(i);\n        }\n        return ans;\n    }\n \n    int query(int l, int r)\n    {\n        return sum(r) - sum(l - 1);\n    }\n \n    int get(int i)\n    {\n        return query(i, i);\n    }\n \n    int update(int i, int val)\n    {\n        auto delta = val = get(i);\n        add(i, delta);\n    }\n \n    void clear()\n    {\n        fill(all(c), 0);\n    }\n \n    // 获取树状数组的大小\n    int size()\n    {\n        return n;\n    }\n};\n \n// BIT end\n \n// 大数模下幂运算\n \n// 快速幂函数，计算 base^exponent mod mod\nlong long modPow(long long base, long long exponent, long long mod)\n{\n    long long result = 1;\n    base %= mod;\n    while (exponent &gt; 0)\n    {\n        if (exponent &amp; 1)\n            result = (result * base) % mod;\n        base = (base * base) % mod;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n \nvoid solve()\n{\n    long long x, p;\n    string y;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;\n    // 对 x 取模（防止数字过大）\n    x %= p;\n    // 特判：若 y 为 &quot;0&quot;，根据数学通常规定 x^0 = 1（注意：0^0一般认为1也可以根据题意而定）\n    if (y == &quot;0&quot;)\n    {\n        cout &lt;&lt; 1 % p &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    // 答案初始为 1\n    long long ans = 1;\n    // 对指数 y 的每一位进行处理\n    for (char c : y)\n    {\n        int d = c - &#039;0&#039;;\n        // 将当前答案提升 10 次方后再乘上 x^d mod p\n        ans = modPow(ans, 10, p);\n        ans = (ans * modPow(x, d, p)) % p;\n    }\n    cout &lt;&lt; ans % p &lt;&lt; &quot;\\n&quot;;\n}\n \n// 大树模下 end ---\n \n// 很多DP\n \n// --------------------- 基础DP问题 ---------------------\n \n// 01背包问题 - 每个物品最多选一次\nint knapsack01(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = capacity; j &gt;= weights[i]; j--)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 完全背包问题 - 每个物品可以选无限次\nint knapsackComplete(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = weights[i]; j &lt;= capacity; j++)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 多重背包问题 - 每个物品有特定数量限制\nint knapsackMultiple(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values,\n                     const vector&lt;int&gt; &amp;counts, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        // 二进制优化 - 将k个物品拆成二进制表示\n        int w = weights[i], v = values[i], c = counts[i];\n        for (int k = 1; k &lt;= c; k *= 2)\n        {\n            for (int j = capacity; j &gt;= k * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - k * w] + k * v);\n            }\n            c -= k;\n        }\n \n        if (c &gt; 0)\n        {\n            for (int j = capacity; j &gt;= c * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - c * w] + c * v);\n            }\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 最长递增子序列 (LIS)\nint longestIncreasingSubsequence(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; dp(n, 1);\n \n    for (int i = 1; i &lt; n; i++)\n    {\n        for (int j = 0; j &lt; i; j++)\n        {\n            if (nums[i] &gt; nums[j])\n            {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n \n    return *max_element(dp.begin(), dp.end());\n}\n \n// 最长递增子序列优化版 (O(nlogn))\nint longestIncreasingSubsequenceOptimized(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; tails;\n \n    for (int num : nums)\n    {\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n        if (it == tails.end())\n        {\n            tails.push_back(num);\n        }\n        else\n        {\n            *it = num;\n        }\n    }\n \n    return tails.size();\n}\n \n// 最长公共子序列 (LCS)\nint longestCommonSubsequence(const string &amp;text1, const string &amp;text2)\n{\n    int m = text1.size(), n = text2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (text1[i - 1] == text2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }\n            else\n            {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// 编辑距离\nint editDistance(const string &amp;word1, const string &amp;word2)\n{\n    int m = word1.size(), n = word2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 0; i &lt;= m; i++)\n        dp[i][0] = i;\n    for (int j = 0; j &lt;= n; j++)\n        dp[0][j] = j;\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (word1[i - 1] == word2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else\n            {\n                dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// --------------------- 区间DP ---------------------\n \n// 石子合并问题 - 求合并代价最小值\nint mergeStones(const vector&lt;int&gt; &amp;stones)\n{\n    int n = stones.size();\n    if (n &lt;= 1)\n        return 0;\n \n    // 前缀和加速区间求和\n    vector&lt;int&gt; prefixSum(n + 1, 0);\n    for (int i = 0; i &lt; n; i++)\n    {\n        prefixSum[i + 1] = prefixSum[i] + stones[i];\n    }\n \n    // dp[i][j] 表示合并区间[i,j]的最小代价\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INF));\n \n    // 初始化：单个石子无需合并\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = 0;\n    }\n \n    // 按区间长度递推\n    for (int len = 2; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n \n            // 尝试在不同位置分割\n            for (int k = i; k &lt; j; k++)\n            {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefixSum[j + 1] - prefixSum[i]);\n            }\n        }\n    }\n \n    return dp[0][n - 1];\n}\n \n// --------------------- 树形DP ---------------------\n \n// 树的最大独立集 (在树上选择不相邻的节点使得权值和最大)\nvoid dfsIndependentSet(int node, int parent, const vector&lt;vector&lt;int&gt;&gt; &amp;tree,\n                       const vector&lt;int&gt; &amp;values, vector&lt;vector&lt;int&gt;&gt; &amp;dp)\n{\n    for (int child : tree[node])\n    {\n        if (child != parent)\n        {\n            dfsIndependentSet(child, node, tree, values, dp);\n            // dp[node][0] - 不选当前节点\n            dp[node][0] += max(dp[child][0], dp[child][1]);\n            // dp[node][1] - 选当前节点\n            dp[node][1] += dp[child][0];\n        }\n    }\n    dp[node][1] += values[node]; // 加上当前节点的权值\n}\n \nint maxIndependentSet(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, const vector&lt;int&gt; &amp;values)\n{\n    int n = values.size();\n    // dp[i][0] - 不选节点i的最大值, dp[i][1] - 选节点i的最大值\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));\n \n    dfsIndependentSet(0, -1, tree, values, dp);\n    return max(dp[0][0], dp[0][1]);\n}\n \n// --------------------- 状态压缩DP ---------------------\n \n// 旅行商问题 (TSP)\nint tsp(const vector&lt;vector&lt;int&gt;&gt; &amp;dist)\n{\n    int n = dist.size();\n    // dp[mask][i] 表示已经访问的城市集合为mask，当前在城市i的最短路径\n    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; n, vector&lt;int&gt;(n, INF));\n \n    // 起点为城市0\n    dp[1][0] = 0; // 只访问城市0的状态\n \n    for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++)\n    {\n        for (int i = 0; i &lt; n; i++)\n        {\n            if ((mask &gt;&gt; i) &amp; 1)\n            { // 城市i已访问\n                for (int j = 0; j &lt; n; j++)\n                {\n                    if ((mask &gt;&gt; j) &amp; 1 &amp;&amp; i != j)\n                    { // 城市j也已访问\n                        dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 &lt;&lt; i)][j] + dist[j][i]);\n                    }\n                }\n            }\n        }\n    }\n \n    // 所有城市都访问并回到起点\n    int result = INF;\n    for (int i = 1; i &lt; n; i++)\n    {\n        if (dist[i][0] != INF)\n        {\n            result = min(result, dp[(1 &lt;&lt; n) - 1][i] + dist[i][0]);\n        }\n    }\n \n    return result;\n}\n \n// --------------------- 数位DP ---------------------\n \n// 计算区间[l,r]中满足条件的数字个数\nint digitDP(int l, int r)\n{\n    vector&lt;int&gt; digits;\n \n    // 数位分解函数\n    auto getDigits = [&amp;](int num)\n    {\n        vector&lt;int&gt; result;\n        while (num)\n        {\n            result.push_back(num % 10);\n            num /= 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    };\n \n    // DP函数，自行定义状态和转移方程\n    function&lt;int(int, bool, bool, int)&gt; dp = [&amp;](int pos, bool isLimit, bool isNum, int state)\n    {\n        // 实现特定问题的状态转移逻辑\n        // pos: 当前处理到的位置\n        // isLimit: 是否有上界限制\n        // isNum: 前面是否已经有数字了\n        // state: 问题相关的状态\n \n        if (pos == digits.size())\n        {\n            return isNum ? 1 : 0; // 根据具体问题调整返回值\n        }\n \n        // 这里补充具体问题的状态转移逻辑\n \n        return 0; // 占位返回\n    };\n \n    // 计算[0,r]的结果\n    digits = getDigits(r);\n    int right_result = dp(0, true, false, 0);\n \n    // 计算[0,l-1]的结果\n    digits = getDigits(l - 1);\n    int left_result = dp(0, true, false, 0);\n \n    // 返回区间结果\n    return right_result - left_result;\n}\n \n// --------------------- 概率DP ---------------------\n \n// 骰子问题 - 投掷n个骰子，点数和为target的概率\ndouble diceProb(int n, int target)\n{\n    if (target &lt; n || target &gt; 6 * n)\n        return 0.0;\n \n    vector&lt;vector&lt;double&gt;&gt; dp(n + 1, vector&lt;double&gt;(6 * n + 1, 0.0));\n    // 初始化：一个骰子\n    for (int i = 1; i &lt;= 6; i++)\n    {\n        dp[1][i] = 1.0 / 6.0;\n    }\n \n    for (int i = 2; i &lt;= n; i++)\n    {\n        for (int j = i; j &lt;= 6 * i; j++)\n        {\n            for (int k = 1; k &lt;= 6 &amp;&amp; k &lt; j; k++)\n            {\n                dp[i][j] += dp[i - 1][j - k] * (1.0 / 6.0);\n            }\n        }\n    }\n \n    return dp[n][target];\n}\n \n// --------------------- 实用DP子问题 ---------------------\n \n// 最大子序和 (Kadane算法)\nint maxSubArray(const vector&lt;int&gt; &amp;nums)\n{\n    int currMax = nums[0], globalMax = nums[0];\n \n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        currMax = max(nums[i], currMax + nums[i]);\n        globalMax = max(globalMax, currMax);\n    }\n \n    return globalMax;\n}\n \n// 最大子矩阵和\nint maxSubMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    if (matrix.empty() || matrix[0].empty())\n        return 0;\n \n    int rows = matrix.size(), cols = matrix[0].size();\n    int result = INT_MIN;\n \n    for (int left = 0; left &lt; cols; left++)\n    {\n        vector&lt;int&gt; tempSum(rows, 0);\n \n        for (int right = left; right &lt; cols; right++)\n        {\n            // 将二维问题转化为一维\n            for (int i = 0; i &lt; rows; i++)\n            {\n                tempSum[i] += matrix[i][right];\n            }\n \n            // 应用Kadane算法找一维最大子序和\n            int kadaneMax = tempSum[0];\n            int currMax = tempSum[0];\n \n            for (int i = 1; i &lt; rows; i++)\n            {\n                currMax = max(tempSum[i], currMax + tempSum[i]);\n                kadaneMax = max(kadaneMax, currMax);\n            }\n \n            result = max(result, kadaneMax);\n        }\n    }\n \n    return result;\n}\n \n// 最长回文子串\nstring longestPalindrome(const string &amp;s)\n{\n    int n = s.size();\n    if (n == 0)\n        return &quot;&quot;;\n \n    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));\n    int start = 0, maxLen = 1;\n \n    // 所有长度为1的子串都是回文\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = true;\n    }\n \n    // 检查长度为2的子串\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (s[i] == s[i + 1])\n        {\n            dp[i][i + 1] = true;\n            start = i;\n            maxLen = 2;\n        }\n    }\n \n    // 检查长度大于2的子串\n    for (int len = 3; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n            if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1])\n            {\n                dp[i][j] = true;\n                start = i;\n                maxLen = len;\n            }\n        }\n    }\n \n    return s.substr(start, maxLen);\n}\n// 很多DP end\n \n// 拓扑\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj; // 邻接表\n    vector&lt;int&gt; indegree(n, 0);          // 统计入度\n    vector&lt;int&gt; result;                  // 结果集合\n    int s, t;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t;\n        indegree[t]++;\n        adj[s].push_back(t);\n    }\n \n    queue&lt;int&gt; que;\n    for (int i = 0; i &lt; n; i++)\n    {\n        // 入度为0 可以作为开头 加入队列\n        if (!indegree[i])\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    if (result.size() - n)\n    {\n        cout &lt;&lt; -1;\n    }\n    else\n    {\n        cout &lt;&lt; result;\n    }\n}\n// 拓扑end\n \n// 生成树 kru\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    struct Edge\n    {\n        int v1, v2, val;\n        Edge(int v1, int v2, int val) : v1(v1), v2(v2), val(val) {};\n    };\n    vector&lt;Edge&gt; edges;\n \n    int v1, v2, val;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        auto [a, b] = minmax(v1, v2);\n        edges.emplace_back(a, b, val);\n    }\n    ranges::sort(edges, [](Edge &amp;a, Edge &amp;b)\n                 { return a.val &lt; b.val; });\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n + 1);\n        iota(father.begin(), father.end(), 0ll);\n    };\n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : ffind(father[i]);\n    };\n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n    // FU end\n    init(n);\n \n    int MSTweight = 0, MSTnode = 0;\n \n    for (auto &amp;&amp;[v1, v2, val] : edges)\n    {\n        if (!issame(v1, v2))\n        {\n            funion(v1, v2);\n            MSTweight += val;\n            MSTnode++;\n        }\n        if (MSTnode == n - 1)\n        {\n            cout &lt;&lt; MSTnode;\n            return;\n        }\n    }\n    cout &lt;&lt; -1;\n    return;\n}\n// 生成树 kru end\n \n// 生成树 prim\nvoid solve()\n{\n    int v, e;\n    cin &gt;&gt; v &gt;&gt; e;\n    int vsz = v + 1;\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(vsz + 1);\n    int v1, v2, val;\n    while (e--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    // prim begin\n    vector&lt;int&gt; visited(vsz, 0), minDist(vsz, INFLL);\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;\n \n    minDist[1] = 0;\n    pq.push({0, 1});\n \n    int totalweight = 0, nodeInMST = 0;\n \n    while (pq.size())\n    {\n        auto [w, cur] = pq.top();\n        pq.pop();\n \n        if (visited[cur])\n        {\n            continue;\n        }\n \n        visited[cur] = 1;\n        totalweight += w;\n        nodeInMST++;\n \n        for (auto &amp;&amp;[next, nextw] : adj[cur])\n        {\n            if (visited[next])\n            {\n                continue;\n            }\n \n            if (nextw &lt; minDist[next])\n            {\n                minDist[next] = nextw;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n    if (nodeInMST != v)\n    {\n        cout &lt;&lt; -1;\n        return;\n    }\n    cout &lt;&lt; totalweight;\n}\n// prim end\n \n// ford 可以处理负环\nvoid solve()\n{\n    int n, m, s, t, v;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;\n        adj[s][t] = v;\n    }\n \n    vector&lt;int&gt; minDist(n + 1, INF);\n    minDist[1] = 0;\n \n    int _ = n - 1;\n    while (_--) //\n    {\n        for (auto &amp;&amp;[v1, v] : adj)\n        {\n            for (auto &amp;&amp;[v2, val] : v)\n            {\n                if (minDist[v1] != INF)\n                {\n                    minDist[v2] = min(minDist[v2], minDist[v1] + val);\n                }\n            }\n        }\n    }\n \n    if (minDist[n] == INF)\n    {\n        cout &lt;&lt; &quot;unconnected&quot;;\n    }\n    else\n    {\n        cout &lt;&lt; minDist[n];\n    }\n}\n// ford end\n \n// dijk\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表，pair&lt;节点, 距离&gt;\n    int s, e, v;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;\n        adj[s].push_back({e, v});\n    }\n \n    /*\n    堆优化版Dijkstra算法:\n    1. 使用优先队列维护当前所有可达但未访问的节点，按距离排序\n    2. 每次取出队列中距离最小的节点，标记为已访问\n    3. 更新该节点邻居的距离，并将新的可能路径加入队列\n    */\n \n    vector&lt;int&gt; minDist(n + 1, INT_MAX); // 每一个节点到源点的最小距离\n    vector&lt;bool&gt; visited(n + 1, false);  // 记录节点是否已被访问\n \n    int start = 1, en = n;\n    minDist[start] = 0;\n \n    // 优先队列，存储&lt;距离, 节点编号&gt;，按距离从小到大排序\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n    pq.push({0, start});\n \n    while (!pq.empty())\n    {\n        int dist = pq.top().first;\n        int cur = pq.top().second;\n        pq.pop();\n \n        if (visited[cur])\n            continue;        // 如果已经访问过，跳过\n        visited[cur] = true; // 标记为已访问\n \n        // 更新当前节点的所有邻居\n        for (const auto &amp;edge : adj[cur])\n        {\n            int next = edge.first;\n            int weight = edge.second;\n \n            if (!visited[next] &amp;&amp; minDist[cur] + weight &lt; minDist[next])\n            {\n                minDist[next] = minDist[cur] + weight;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n \n    cout &lt;&lt; (minDist[en] == INT_MAX ? -1 : minDist[en]);\n}\n// dijk end\n \n// 多源最短路 floyd\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector v(n + 1, vector&lt;int&gt;(n + 1, INT_MAX));\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            cin &gt;&gt; v[i][j];\n        }\n    }\n \n    // floyd\n    for (int k = 1; k &lt;= n; k++)\n    {\n        for (int i = 1; i &lt;= n; i++)\n        {\n            for (int j = 1; j &lt;= n; j++)\n            {\n                v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n            }\n        }\n    }\n}\n// flyd end\n"},"ACW2024/二分/1227":{"slug":"ACW2024/二分/1227","filePath":"ACW2024/二分/1227.md","title":"1227","links":[],"tags":[],"content":"void solve()\n{\n\tint n, k;\n\tcin &gt;&gt; n &gt;&gt; k;\n\tint maxnum = 0;\n\tvector&lt;int&gt; h(n), k = h;\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; h[i] &gt;&gt; k[i];\n\t\tmaxnum = max({maxnum, h[i], k[i]});\n\t}\n \n\tint l = 1, r = maxnum, m, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tm = l + (r - l) / 2;\n\t\tauto check = [&amp;]()\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\t{\n\t\t\t\tans += (h[i] / m) * (k[i] / m);\n\t\t\t}\n\t\t\treturn ans &gt;= k;\n\t\t};\n\t\tif (check()) l = (ans = mid) + 1;\n\t\telse r = m - 1;\n\t}\n\tcout &lt;&lt; ans;\n}"},"ACW2024/二分/503":{"slug":"ACW2024/二分/503","filePath":"ACW2024/二分/503.md","title":"503","links":[],"tags":[],"content":"void solve()\n{\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tvector&lt;int&gt; v(n + 2);\n\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; \n\tfor (int i = n; i &gt;= 1; i--) v[i] -= v[i - 1];\n \n\tstruct datas\n\t{\n\t\tint d, s, t;\n\t};\n\tvector&lt;datas&gt; k(m + 1);\n\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; k[i].d &gt;&gt; k[i].s &gt;&gt; k[i].t;\n \n\tint l = 1, r = m, mid, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2;\n\t\tauto check = [&amp;]() -&gt; bool\n\t\t{\n\t\t\tauto b = v;\n\t\t\tfor (int i = 1; i &lt;= mid; i++)\n\t\t\t{\n\t\t\t\tb[v[i].s] -= v[i].d;\n\t\t\t\tb[v[i].t + 1] += v[i].d;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 1; i &lt;= m; i++)\n\t\t\t{\n\t\t\t\tans += b[i];\n\t\t\t\tif (b[i] &lt; 0) return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tif (check()) r = (ans = mid) - 1;\n\t\telse l = mid + 1; \n\t}\n\tcout &lt;&lt; ans;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n随着订单增加，每天可用教室的数量一定单调下降\r\n我们可以二分求出第一天出现负值的订单编号\r\n每个订单 我们会选择 [L, R] 全部减去 d\r\n可以用差分来加速处理过程\n\n\n"},"ACW2024/二分/5407":{"slug":"ACW2024/二分/5407","filePath":"ACW2024/二分/5407.md","title":"5407","links":[],"tags":[],"content":"void solve()\n{\n\tauto check = [&amp;]() -&gt; bool\n\t{\n\t\t\n\t\n\t};\n}"},"ACW2024/前缀和/562":{"slug":"ACW2024/前缀和/562","filePath":"ACW2024/前缀和/562.md","title":"562","links":[],"tags":[],"content":"void solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tstring s;\n\tcin &gt;&gt; s;\n\t\n \n}"},"BEGINNING":{"slug":"BEGINNING","filePath":"BEGINNING.md","title":"BEGINNING","links":["学习笔记"],"tags":["begin"],"content":"heading 1\nheading 2\nheading 3\nheading 4\nheading 5\nheading 6\nbold\r\nitalic\n\nbullet item 1\nbullet item 2\n\nnested item\n\n\nbullet item 1\n\n\nno.1\nno.2\n\n学习笔记\r\nlink text\nHighlight Text\r\n～～ dont know why i cant use strikethrough ～～\n\n checkbox\n put ‘x’\n\n\n\n                  \n                  Node\n                  \n                \n\n\n1\n\n\n\n\n%这是一个注释%\n\n以下是 latex 教程\n\n+\r\n-\r\n\\times\r\n\\div\r\n=\r\n\\neq \n(a + b)\r\n\\{a + b\\}\r\n[a + b]\r\n\\frac{a}{b}\r\n\r\na^2\r\nx_1\r\n\\sqrt{a}\n\\alpha \\times \\beta = \\gamma\r\n\\sum_{i = 1}^{n} i\r\n\\Sigma_{i = 1}^{n} i\r\n\\Pi_{i = 1}^{n} i"},"Quick-LaTeX-readme":{"slug":"Quick-LaTeX-readme","filePath":"Quick LaTeX readme.md","title":"Quick LaTeX readme","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShorthandStringShorthandStringShorthandStringsq\\sqrt{}bb\\mathbb{}bf\\mathbf{}te\\text{}inf\\inftybi\\binom{#cursor}{#tab}cd\\cdotqu\\quadti\\timesal\\alphabe\\betaga\\gammaGa\\Gammade\\deltaDe\\Deltaep\\epsilonze\\zetaet\\etath\\thetaTh\\Thetaio\\iotaka\\kappala\\lambdaLa\\Lambdamu\\munu\\nuxi\\xiXi\\Xipi\\piPi\\Pirh\\rhosi\\sigmaSi\\Sigmata\\tauup\\upsilonUp\\Upsilonph\\phiPh\\Phich\\chips\\psiPs\\Psiom\\omegaOm\\Omega"},"asdlfjkalsdfjklasjkf":{"slug":"asdlfjkalsdfjklasjkf","filePath":"asdlfjkalsdfjklasjkf.md","title":"asdlfjkalsdfjklasjkf","links":[],"tags":[],"content":"喜欢你\nlov u"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"welcome to my github page!\nall i wanna do is just gotta sleep…"},"偏序集。。。":{"slug":"偏序集。。。","filePath":"偏序集。。。.md","title":"偏序集。。。","links":[],"tags":[],"content":"根据您的要求，我会用中文为您解释偏序集、格、有界格和补格。\n偏序集 (Partially Ordered Set, Poset)\n一个偏序集是一个集合 P 及其上的一个二元关系 \\preceq，该关系满足以下三个性质：\n\n自反性 (Reflexivity)：对于 P 中任意元素 a，都有 a \\preceq a。\n反对称性 (Antisymmetry)：对于 P 中任意元素 a, b，如果 a \\preceq b 且 b \\preceq a，那么 a = b。\n传递性 (Transitivity)：对于 P 中任意元素 a, b, c，如果 a \\preceq b 且 b \\preceq c，那么 a \\preceq c。\n需要注意的是，在偏序集中，并不是所有的元素对都必须是可比较的。也就是说，可能存在 a, b \\in P，a \\not\\preceq b 且 b \\not\\preceq a。\n例子：\n整数集合 \\mathbb{Z} 和普通的小于等于关系 (\\mathbb{Z}, \\le) 是一个偏序集。\n一个集合 S 的幂集 P(S)（所有子集的集合）和子集关系 (P(S), \\subseteq) 是一个偏序集。例如，对于集合 {1, 2, 3}，{1} \\subseteq {1, 2}，但 {1} 和 {2} 不可比较。\n格 (Lattice)\n一个格是一个偏序集 (L, \\preceq)，其中对于 L 中任意两个元素 a, b，都存在它们的最小上界 (least upper bound, supremum 或 join) 和最大下界 (greatest lower bound, infimum 或 meet)。\n最小上界通常记作 a \\lor b (读作 “a join b”)。它是所有同时大于等于 a 和 b 的元素中最小的一个。\n最大下界通常记作 a \\land b (读作 “a meet b”)。它是所有同时小于等于 a 和 b 的元素中最大的一个。\n简单来说，格是一个“结构良好”的偏序集，其中任何两个元素都有明确的“结合”方式（最小上界）和“交叠”方式（最大下界）。\n例子：\n整数集合 \\mathbb{Z} 和普通的小于等于关系 (\\mathbb{Z}, \\le) 构成一个格，其中 a \\lor b = \\max(a, b)， a \\land b = \\min(a, b)。\n一个集合 S 的幂集 P(S) 和子集关系 (P(S), \\subseteq) 构成一个格，其中 A \\lor B = A \\cup B (并集)，A \\land B = A \\cap B (交集)。\n有界格 (Bounded Lattice)\n一个有界格是一个格 (L, \\preceq)，其中存在一个全上界 (universal upper bound) 和一个全下界 (universal lower bound)。\n全上界通常记作 \\mathbf{1} (或 I)，也称为最大元素 (greatest element) 或单位元素 (unit element)。对于 L 中任意元素 a，都有 a \\preceq \\mathbf{1}。\n全下界通常记作 \\mathbf{0} (或 O)，也称为最小元素 (least element) 或零元素 (zero element)。对于 L 中任意元素 a，都有 \\mathbf{0} \\preceq a。\n例子：\n一个集合 S 的幂集 P(S) 和子集关系 (P(S), \\subseteq) 构成一个有界格。它的全上界是 S 本身，全下界是空集 \\emptyset。\n一个闭区间 [a, b] 上的实数集合，以及普通的小于等于关系 ([a, b], \\le) 构成一个有界格。它的全上界是 b，全下界是 a。\n补格 (Complemented Lattice)\n一个补格是一个有界格 (L, \\preceq, \\mathbf{0}, \\mathbf{1})，其中对于 L 中每一个元素 a，都存在一个补元 (complement) a’，满足以下两个条件：\na \\land a’ = \\mathbf{0}\na \\lor a’ = \\mathbf{1}\n补元在布尔代数中扮演着“非”的角色。请注意，一个元素的补元可能不唯一。如果在一个格中每个元素的补元都是唯一的，那么这个格被称为布尔代数。\n例子：\n一个集合 S 的幂集 P(S) 和子集关系 (P(S), \\subseteq) 构成一个补格。对于任意子集 A \\subseteq S，它的补元就是 S \\setminus A (补集)，因为 A \\cap (S \\setminus A) = \\emptyset (全下界) 且 A \\cup (S \\setminus A) = S (全上界)。\n考虑正整数集合 D_n（n 的所有正因子）与整除关系 (\\mid)，当 n 是无平方数时，它形成一个补格。例如，D_6 = {1, 2, 3, 6}，\\mathbf{0}=1, \\mathbf{1}=6。对于元素 2，其补元是 3，因为 2 \\land 3 = \\text{gcd}(2,3) = 1 = \\mathbf{0}，2 \\lor 3 = \\text{lcm}(2,3) = 6 = \\mathbf{1}。\n希望这些解释对您有所帮助！如果您还有其他问题，随时可以问我。\n"},"判断整除-数位法":{"slug":"判断整除-数位法","filePath":"判断整除 数位法.md","title":"判断整除 数位法","links":[],"tags":[],"content":"对于所有正整数\n1都是因子\n数位和是三的倍数 那么3就是因子\n末尾是5或者0 5就是因子\n对于7 一个n位数(n &gt;= 6) 有abbbccc → a （三个连续的b可以和三个连续的c约掉) 判断a是否可以整除7即可\n数位和是9的倍数 那么9就是因子"},"大创中期答辩演讲":{"slug":"大创中期答辩演讲","filePath":"大创中期答辩演讲.md","title":"大创中期答辩演讲","links":[],"tags":[],"content":"各位评委、老师，大家好。\n我叫梁震宇 ，是“理智先锋娱乐互动工作室”的负责人 。今天，我将向大家展示一个将中国古代科学智慧与现代游戏体验深度融合的创业项目。\n\n(幻灯片切换：项目背景与团队实力)\n我们想解决一个问题：如何让今天的年轻人，尤其是学生，真正爱上科学，同时深刻感受我们自己文化的魅力？传统课本的知识是静态的，而历史题材的游戏又常常忽略了其中蕴含的科学光芒。\n我们的答案，是创造一种全新的互动体验。为此，我们立足于北宋科学家沈括的科学巨著——《梦溪笔谈》 。我们不仅仅是讲述历史，而是邀请玩家化身时空旅者，亲手去“复现”那些沉睡在古籍中的科学实验 。\n我们的核心价值，就是将古风叙事与物理知识结合 ，通过角色扮演和游戏化的方式 ，极大地降低科学的学习门槛 ，最终培养玩家的文化认同感与科学精神 。\n支撑这个愿景的，是一个充满实战经验的团队。我们的核心成员，曾荣获CCPC程序设计竞赛东北地区铜牌、中国大学生计算机设计大赛国家级三等奖等多项荣誉 。我们的指导老师梅险老师，在计算机博弈与游戏设计领域拥有深厚的项目经验和多项国家级荣誉 。我们不仅有热情，更有将想法变为现实的技术实力。\n\n(幻灯片切换：游戏核心设计与特色)\n接下来，我为大家介绍游戏的核心设计。\n我们的游戏设计了五章史诗级的冒险 。每一章都围绕一个核心的科学问题展开，比如第一章的“小孔成像”和第二章的“光的反射与折射” 。这不只是简单的知识灌输，我们的教育目标巧妙地融入了玩法之中 。例如，玩家需要亲手调整装置，才能观察到“光沿直线传播”的现象 。同时，游戏还融合了物理、历史等多学科知识 ，比如在“汴京的挑战”一章中，玩家需要运用流体力学知识来解决水患问题 。\n为了区别于市场上的其他产品，我们设计了三大差异化机制： 第一，科学实验系统 。玩家可以自主设计实验方案，系统会根据操作的逻辑性进行评分，真正深化对科学原理的理解 。\n第二，历史沉浸设计 。游戏中的许多关键对话和线索，都直接引自《梦溪笔谈》原著，解锁隐藏剧情，增强文化沉浸感 。\n第三，跨时空叙事 。玩家在古都汴京做出的决策，会影响到他在现代博物馆中看到的展览，构建一种奇妙的时空联动体验 。\n\n(幻灯片切换：开发路线与未来规划)\n目前，我们正严格按照开发路线图推进。从2024年底的市场调研，到今年上半年的游戏制作，我们已经完成了核心玩法的开发 。接下来，我们将在8到10月进行发行运营 。\n我们的发行策略非常清晰： 首先，通过众筹模式启动，比如资助10元解锁隐藏章节，50元获得一枚精美的宋代科学仪器徽章，以此凝聚第一批核心用户 。\n其次，我们将在Steam平台进行试发行，以“大学生创新创业项目”的身份，用极具吸引力的1元定价，快速获取国区玩家的宝贵反馈 。\n同时，我们会在B站、抖音等多平台进行内容推广，通过开发日志、幕后花絮等形式，与玩家建立紧密的联系 。\n\n(幻灯片切换：初步成果与用户反馈)\n目前，我们的努力已经初见成效。\n这是我们制作的游戏官网和部分游戏截图 。大家可以看到，从关卡设计到动态效果，我们都力求细节。比如，在“磨针成指南针”的环节，我们制作了专门的动画效果，给予玩家“亲手操作”的沉浸感 。在探索任务中，也有实时的声音和文字提示，引导玩家顺利通关 。\n我们搭建了工作室的基本架构，分为市场、技术和美术策划三大部门，由各专业同学负责，高效协作 。\n我们诚挚地邀请各位访问我们的官网，亲身体验游戏的试玩版 。\n总结而言，“理智先锋”正在做一件非常有意义的事：我们不只是在开发一款游戏，更是在打造一个可以玩的“数字文化遗产”，一座连接过去与未来的桥梁。我们希望通过这部作品，让科学和传统文化，变得触手可及、趣味盎然。\n我的汇报到此结束，谢谢大家。"},"大创答辩":{"slug":"大创答辩","filePath":"大创答辩.md","title":"大创答辩","links":[],"tags":[],"content":"第一章 项目目的与团队能力验证\n1. 项目核心价值：寓教于乐 × 古风传承\n\n\n文化赋能教育：\n\n科学史的活化：以《梦溪笔谈》为蓝本，将沈括的科学探索转化为可交互体验，让玩家“亲手验证”古代科学原理（如磁针偏角实验、小孔成像）。\n古风叙事魅力：\n\n美术风格：宋代水墨画风+工笔场景（汴京街市、梦溪园建筑考据历史文献）。\nNPC对话：严格引用《梦溪笔谈》原文（如“方家以磁石磨针锋，则能指南”）。\n\n\n跨学科融合：物理知识（光学/磁学/流体力学）与历史人文结合，培养玩家科学思维与文化认同。\n\n\n\n差异化竞争力：\n\n填补市场空白：当前Steam平台缺乏“中国古代科学+角色扮演”题材，同类游戏《Kerbal太空计划》侧重现代航天，本作专注本土化科学启蒙。\n轻量化学习门槛：通过游戏机制降低科学理解难度（如“光影之谜”章节用拖拽镜面直观演示反射定律）。\n\n\n\n2. 团队能力验证\n\n技术实力：\n\n成员累计获省级及以上奖项6项，包括：\n\nACM国际大学生程序设计竞赛东北三省赛区铜奖（技术能力证明）\n全国大学生电子商务竞赛二等奖（创新与商业思维）\n高校数字创意教学技能大赛优秀奖（跨学科协作能力）\n\n\n\n\n开发经验：\n\n熟练使用RPG Maker VX引擎开发，自主开发物理模拟插件（支持实时光影追踪、水流动力学）。\n内测版本已吸引200+玩家体验，平均单次游戏时长43分钟，核心章节通关率达68%。\n\n\n\n\n第二章 项目研究内容（游戏核心设计）\n1. 五章史诗冒险：科学探索之旅\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n章节核心科学问题玩法设计教育目标时空漩涡小孔成像原理在图书馆场景中通过调整孔洞形状、光源位置，观察成像规律理解光的直线传播特性光影之谜光的反射与折射协助沈括改良“覆盆镜”实验，需通过镜面反射点燃蜡烛掌握反射定律与实际应用汴京的挑战流体力学与水利工程设计分水堰模型，通过调整坝体角度解决洪水泛滥问题运用伯努利原理分析水流压力梦溪园的奇遇地磁场与磁针偏角在实验室中重复沈括磁针实验，记录不同材料对磁偏角的影响理解地磁南极与地理北极差异回归与传承科学方法论总结选择现代实验设备复现古代实验，对比古今科技差异培养批判性思维与历史视角\n2. 差异化机制设计\n\n科学实验系统：所有章节均包含可交互实验台，玩家需自主设计实验步骤（如“先固定光源，再移动挡板”），系统根据操作逻辑性评分。\n历史沉浸设计：\n\n穿越回现代后，玩家需在图书馆数字档案中查找《梦溪笔谈》原文，解锁隐藏剧情。\nNPC对话严格参照《梦溪笔谈》原文记载（如“方家以磁石磨针锋，则能指南”）。\n\n\n跨时空叙事：汴京章节决策影响现代图书馆展品陈列（如成功解决水患可解锁“北宋水利模型”数字展柜）。\n\n\n第三章 项目研究路线与进度\n1. 开发路线图\n\n第一阶段（已完成）：\n\n完成5个章节架构设计，2章可交互原型开发（时空漩涡、光影之谜）。\n物理模拟插件基础功能实现（小孔成像、磁针偏角实验）。\n\n\n第二阶段（进行中）：\n\n开发汴京水利工程章节，优化伯努利原理模拟算法。\n制作Steam商店页原型，启动内测用户招募。\n\n\n第三阶段（计划中）：\n\n完成全章节联调，制作宣传视频与开发者日志。\n对接中小学科学课程，开发配套教学资源包。\n\n\n\n2. 未来规划\n\nSteam平台发行：\n\n定价38元标准版，配套教学版定制内容（含教师手册、课堂任务包）。\n计划2024年Q3上线，同步启动校园推广。\n\n\n资金筹集方案：\n\n二维码众筹：阶梯回报（10元档解锁隐藏章节，50元档赠宋代科学仪器徽章）。\n虚拟资助体系：开发“学徒等级系统”，资助者可获游戏内专属称号（如“沈括首席弟子”）。\n\n\n\n\n第四章 项目初步成果展示\n1. 团队荣誉与奖项\n\n技术类：\n\nACM国际大学生程序设计竞赛东北三省赛区铜奖\n\n\n创新类：\n\n全国大学生电子商务竞赛二等奖\n\n\n设计类：\n\n高校数字创意教学技能大赛优秀奖\n\n\n\n2. 游戏近况与验证\n\n技术成果：\n\n自主研发物理引擎：支持实时光影追踪、磁针偏角动态计算。\n可交互实验台原型：玩家操作记录与逻辑评分系统。\n\n\n用户反馈：\n\n内测版本吸引200+玩家体验，平均单次游戏时长43分钟，核心章节通关率68%。\n用户评论：“通过游戏真正理解了小孔成像原理”（B站UP主实况视频弹幕）。\n\n\n\n3. 游戏介绍网页\n\n网址：Science Student’s Fantasy Journey\n核心内容：\n\n五章冒险故事线完整介绍\n游戏特色与美术风格展示\n立即下载试玩入口\n\n\n\n\n可视化建议\n\n必配素材：\n\n游戏主界面截图（宋代山水画风+章节选择界面）。\n「光影之谜」章节实验流程GIF（拖拽镜面点燃蜡烛）。\n沈括角色设定图（宋代文人服饰+手持《梦溪笔谈》手卷）。\n\n\n增强说服力：\n\n对比图：展示“传统教材讲解” vs “游戏内实验流程”的知识传递效率。\n文化考据资料：汴京水利工程设计参考《营造法式》的文献截图。\n\n\n\n"},"大学物理":{"slug":"大学物理","filePath":"大学物理.md","title":"大学物理","links":[],"tags":[],"content":"质点运动学\n位移 速度 加速度\n\n位置矢量(位矢)\n\n建立直角坐标系后，物体位置用坐标A(x, y, z) 表示\n向量\\vec{r} = \\vec{OA} 就称为 位置矢量 也记作 \\vec{r} = x\\vec{i} +y \\vec{j} + z \\vec{k}\n\n\n运动方程\n\n质点坐标x, y, z 随 t 的变化关系，将 t 消掉即可\n\n\n\n例：已知质点运动学方程是 \\vec{r} = 4t^{2} \\vec{i} + (2t +3)\\vec{j} 求质点的运动方程\nx = 4t^{2}, y = 2t +3 \\to t = \\frac{y - 3}{2} \\to x = 4(\\frac{y - 3}{2}) ^{2}\n\n位移与路程\n\n物体的位置变化记为位移\\triangle\\vec{r}  用起点到终点的有向线段表示\n物体实际运动的路径长为路程\\triangle s\n注意\n\n\\triangle \\vec{r} 是位移，|\\triangle \\vec{r} | 是 位移的大小，\\triangle r 是物体到原点距离的变化\n只有 ds = |d\\vec{r}| 是对的\n\n\n\n\n\n圆周运动的参数\n相对运动\n机械振动\n\\begin{align}\n\\text{位移:} \\quad &amp; x = A \\cos(\\omega t + \\phi) \\\\\n\\text{速度:} \\quad &amp; v = \\frac{dx}{dt} = -A \\omega \\sin(\\omega t + \\phi) \\\\\n\\text{加速度:} \\quad &amp; a = \\frac{dv}{dt} = -A \\omega^2 \\cos(\\omega t + \\phi) \\\\\n\\text{角频率:} \\quad &amp; \\omega = \\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi f \\\\\n\\text{动能:} \\quad &amp; E_k = \\frac{1}{2}mv^2 = \\frac{1}{2}m\\omega^2 A^2 \\sin^2(\\omega t + \\phi) \\\\\n\\text{势能:} \\quad &amp; E_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2 \\cos^2(\\omega t + \\phi) \\\\\n\\text{总能量:} \\quad &amp; E = E_k + E_p = \\frac{1}{2}kA^2 \\\\\n\\text{最大速度:} \\quad &amp; v_{\\text{max}} = A\\omega \\\\\n\\text{最大加速度:} \\quad &amp; a_{\\text{max}} = A\\omega^2 \\\\\n\\text{微分方程:} \\quad &amp; \\frac{d^2x}{dt^2} + \\omega^2 x = 0\n\\end{align}\n以下是一些简谐振动的经典二级结论及其详细推导过程，适合用于快速解题和理解物理本质。所有公式均提供 LaTeX 源码。\n\n结论1：弹性力在半个周期内所做的功为 0\n推导过程：\n弹性力是保守力，其做功仅取决于初末位置的势能差。\n简谐振动中，半个周期（T/2）内振子从位置 x_0 移动到对称位置 -x_0，势能变化为：\n\\Delta E_p = \\frac{1}{2}k(-x_0)^2 - \\frac{1}{2}k x_0^2 = 0\n因此弹性力做功 W = -\\Delta E_p = 0。\n\n结论2：动能与势能相等时的位移 x = \\pm \\frac{A}{\\sqrt{2}}\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，当动能等于势能时：\nE_k = E_p = \\frac{1}{2}E \\Rightarrow \\frac{1}{2}kx^2 = \\frac{1}{2} \\cdot \\frac{1}{2}kA^2\n解得：\nx^2 = \\frac{A^2}{2} \\Rightarrow x = \\pm \\frac{A}{\\sqrt{2}}\n\n结论3：最大速度 v_{\\text{max}} = A\\omega（平衡位置）\n推导过程：\n动能最大值对应速度最大值：\nE_k^{\\text{max}} = \\frac{1}{2}mv_{\\text{max}}^2 = \\frac{1}{2}kA^2\n\\Rightarrow v_{\\text{max}} = A \\sqrt{\\frac{k}{m}} = A\\omega\n\n结论4：最大加速度 a_{\\text{max}} = A\\omega^2（端点）\n推导过程：\n加速度由胡克定律 F = -kx 和牛顿第二定律 F = ma 得：\na = -\\frac{k}{m}x \\Rightarrow |a|_{\\text{max}} = \\frac{k}{m}A = A\\omega^2\n\n结论5：速度与位移的相位差 \\frac{\\pi}{2}\n推导过程：\n位移 x = A\\cos(\\omega t + \\phi)，速度 v = -A\\omega\\sin(\\omega t + \\phi)。\n利用三角恒等式：\n\\sin\\theta = \\cos\\left(\\theta - \\frac{\\pi}{2}\\right)\n\\Rightarrow v = A\\omega\\cos\\left(\\omega t + \\phi + \\frac{\\pi}{2}\\right)\n因此速度超前位移 \\frac{\\pi}{2}。\n\n结论6：周期与振幅无关（等时性）\n推导过程：\n简谐振动周期 T = 2\\pi\\sqrt{\\frac{m}{k}}，仅依赖于系统参数（质量 m 和劲度系数 k），与振幅 A 无关。\n这是简谐振动的核心特性。\n\n结论7：能量与振幅平方成正比\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，直接表明能量与振幅的平方成正比。\n\n结论8：单摆周期公式（小角度近似）\n推导过程：\n单摆受力矩 \\tau = -mgl\\sin\\theta，小角度下 \\sin\\theta \\approx \\theta，\n微分方程为：\n\\frac{d^2\\theta}{dt^2} + \\frac{g}{l}\\theta = 0 \\Rightarrow T = 2\\pi\\sqrt{\\frac{l}{g}}\n\n结论9：垂直弹簧振子的平衡位置偏移\n推导过程：\n竖直悬挂时，平衡位置满足 mg = kx_0 \\Rightarrow x_0 = \\frac{mg}{k}。\n振动仍为简谐运动，振幅以该平衡位置为中心。\nx_0 = \\frac{mg}{k} \\quad \\text{(竖直悬挂时的平衡位置)}\n\\end{equation}$$\n\n---\n\n### **结论10：串联/并联弹簧的等效劲度系数**\n\n- **串联**：$\\frac{1}{k_{\\text{eq}}} = \\frac{1}{k_1} + \\frac{1}{k_2}$  \n- **并联**：$k_{\\text{eq}} = k_1 + k_2$\n\n\n### 例题\n\\begin{align}\n&amp;m = 10^{-3} kg \\\n&amp;x = 0.1 \\cos (8 \\pi t +\\frac{2\\pi}{3})\n\\end{align}\n求弹簧周期，振幅，初相位，速度和加速度的最大值\n\\begin{align}\n&amp;\\omega = 8\\pi \\\n&amp;T = \\frac{2\\pi}{\\omega} = \\frac{2\\pi}{8\\pi} = \\frac{1}{4} \\\n&amp;A= 0.1 \\\n&amp;\\phi = \\frac{2\\pi}{3} \\\n&amp;v_{max} =  A\\omega = 0.8\\pi \\\n&amp;a_{max} =  A\\omega ^ 2 = 6.4 \\pi ^ 2\n\\end{align}\n求最大回复力，最大动能，平均动能和平均势能，在哪些位置上动能势能相等？\n\\begin{align}\n&amp;F_{max} = -kA \\\n&amp;E_k , {max} = \\frac{1}{2}mv{max} \\\n&amp;\\overline{E_k} = \\overline{E_p} = \\frac{1}{2}E_{总} = \\frac{1}{4}\\omega A ^ 2 \\\n&amp;x = \\pm \\frac{A}{\\sqrt{2}} \\quad \\text{时，动能势能相等}\n\\end{align}\n求 $t_2 = 5s$ 和 $t_1 = 1s$ 两个时刻的相位差\n\\begin{align}\n&amp;\\phi(t) = 8\\pi t + \\frac{2\\pi}{3} \\\n&amp;\\triangle \\phi = 32 \\pi\n\\end{align}\n## 机械波\n## 静电场\n\\begin{align*}\n\\text{库仑定律:} \\quad &amp; F = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q_1 q_2}{r^2} \\\n\\text{电场强度:} \\quad &amp; \\vec{E} = \\frac{\\vec{F}}{q_0} \\\n\\text{高斯定律:} \\quad &amp; \\oint \\vec{E} \\cdot d\\vec{A} = \\frac{Q_{\\text{enc}}}{\\varepsilon_0} \\\n\\text{电势:} \\quad &amp; V = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q}{r} \\\n\\text{电容:} \\quad &amp; C = \\frac{Q}{V}, \\quad C_{\\text{平行板}} = \\varepsilon_0 \\frac{A}{d} \\\n\\text{电容器储能:} \\quad &amp; U = \\frac{1}{2} C V^2\n\\end{align*}\n对电荷连续分布的带电体：\n\\begin{align*}\nd\\vec{F} &amp;= \\frac{q_{0} dq}{4\\pi \\epsilon_{0}r} \\vec{r^{0}} \\\n即:\\\nd\\vec{F} &amp;= \\frac{q_{0} \\vec{r^{0}}}{4\\pi \\epsilon r} , dq\\\n则有\\\n\\vec{F} &amp;= \\int_{Q} \\frac{q_{0} \\vec{r^{0}}}{(4\\pi \\epsilon r) }, dq\\\n\\\n其中，dq &amp;=\n\\begin{cases}\n\\lambda , dl \\quad \\text{(线密度)}\\\n\\sigma , dS \\quad \\text{(面密度)}\\\n\\rho , dV \\quad \\text{(体分布)}\n\\end{cases}\\\n\\end{align*}\n矢量积分的一般步骤：\n1. 设坐标，取积分微元，这里是 $dq$ (按照电荷的分布情况取)\n2. 写出点电荷 $dq$ 的电场强度 $d\\vec{E}$ 的大小，方向（标在图上）\n3. 坐标分解 $d\\vec{E}$ (在图上也要画出）\n4. 对 $d\\vec{E}$ 的各个坐标分量 积分\n\n##### 长为 $L$ 的均匀带电直杆，电荷线密度为 $\\lambda$ 求：\n它在空间一点 $P$ 产生的电场强度 （$P$ 点到杆的垂直距离为 $a$)\n\n\\begin{align*}\n\\text{电场强度} ; d\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{dq}{r} \\\nr &amp;= \\sqrt{a^{2} + x^{2}}\\\n设所成角度为 , \\theta ,则有\\\n\\frac{a}{x} &amp;= \\tan \\theta\\\n\\text{这道题是杆子 有}\\\ndq &amp;= \\lambda , dx\\\n\\end{align*}\n##### 一个半径为 $R$ 的导体球表面的面电荷密度为 $\\sigma$ 那么，在距球面 $R$ 处的电场强度为\n\\begin{align*}\n电场强度 \\quad d\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{dq}{r} \\vec{r^{0}}\\\n由高斯定理\\\n\\oint \\vec{E} , dS &amp;= \\frac{Q}{\\epsilon} \\\n则有 \\\n\\vec{E} ,4\\pi (2R) ^{2} &amp;= \\frac{\\sigma \\int dS}{\\epsilon}\\\n解得\\\n\\vec{E} &amp;= \\frac{\\sigma 4 \\pi R^{2}}{4 \\pi 4R ^ {2} \\epsilon} \\\n&amp;= \\frac{\\sigma}{4\\epsilon}\n\\end{align*}\n##### 已知球体半径为 $R$ 带电量为 $q$ （电荷体密度为 $\\rho$ ）求均匀带电体的电场强度分布\n\\begin{align*}\n对于球外 (r &gt;= R)\\\n\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{q}{r^{2}}\\vec{r}^{0}\\\n\\\n由高斯定理，有\\\n\\oint \\vec{E} ,dS &amp;= \\frac{Q}{\\epsilon}\\\n即\\\n\\vec{E} , 4 \\pi r^{2} &amp;= \\frac{q}{\\epsilon}  \\\n\\\n对于球内 （r &lt; R) \\\n\\oint \\vec{E} , dS &amp;= \\vec{E} , 4 \\pi r ^{2} \\\n&amp;= \\frac{\\sigma \\int_{0}^{r} \\rho , dV}{\\epsilon}\\\n&amp;= \\frac{\\sigma \\rho 4 \\pi r^{3} }{3\\epsilon}\n\\end{align*}\n\n\\begin{align*}\\\n\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{q}{r^{2}} \\vec{r^{0}} \\\n\\\n\\\nF &amp;= k \\frac{q_{1}q_{2}}{r^{2}}\n\\end{align*}\n"},"大物模拟题":{"slug":"大物模拟题","filePath":"大物模拟题.md","title":"大物模拟题","links":[],"tags":[],"content":"大学物理（二）综合模拟试题（扩展版）\n考试时间：150分钟\n总分：150分\n\n一、选择题 (共15小题，每小题3分，总计45分)\n请在每小题给出的四个选项中，选出一个最符合题目要求的选项。\n\n\n某质点的运动方程为 x=−2t3+9t2+6 (SI)。关于该质点的运动，下列说法正确的是：\nA. 匀加速直线运动，在 t=3 s 时加速度沿x轴正方向。\nB. 匀加速直线运动，在 t=3 s 时加速度沿x轴负方向。\nC. 变加速直线运动，在 t=3 s 时加速度沿x轴正方向。\nD. 变加速直线运动，在 t=3 s 时加速度沿x轴负方向。 1\n\n\n关于功的概念，下列说法正确的是：\nA. 当保守力做正功时，系统内相应的势能增加。\nB. 质点运动经一闭合路径，保守力对质点做的功为零。\nC. 作用力与反作用力大小相等、方向相反，所以两者所做功的代数和必为零。\nD. 以上说法都正确。 1\n\n\n一质点沿半径为R的圆周作匀速率运动，每秒转一圈，在2秒时间间隔中，其平均速度大小和平均速率大小分别为：\nA. t2πR​,t2πR​\nB. 0,t2πR​\nC. 0,0\nD. t2πR​,0 1\n\n\n一个物体做简谐振动，在振动过程中，动能和势能相等的位置的位移等于：\nA. ±A/4\nB. ±A/2\nC. ±3​A/2\nD. ±2​A/2 1\n\n\n关于高斯定理，下列说法正确的是：\nA. 若高斯面上的电场强度处处为零，则该面内必定没有净电荷。\nB. 若高斯面内没有电荷，则该面上的电场强度必定处处为零。\nC. 若高斯面上的电场强度处处不为零，则该面内必定有电荷。\nD. 若高斯面内有电荷，则该面上的电场强度必定处处不为零。 1\n\n\n在电场中的导体内部（处于静电平衡状态）：\nA. 电场和电势均不为零。\nB. 电场不为零，电势均为零。\nC. 电势和表面电势相等。\nD. 电势高于表面电势。 1\n\n\n一列平面简谐波，传播速度为 300 m/s，频率为 100 Hz。波线上两点相距 2 m，则它们振动的相位差为：\nA. π/3\nB. 2π/3\nC. π\nD. 4π/3 1\n\n\n一列横波沿x轴正方向传播。某时刻波形曲线如图所示。则该时刻：\nA. A点振动速度大于零。\nB. B点静止不动。\nC. C点向上运动。\nD. D点振动速度小于零。 1\n\n\n根据热力学第二定律，下列哪种说法是正确的？\nA. 功可以全部变为热，但热不能全部变为功。\nB. 热量能从高温物体传到低温物体，但不能从低温物体传到高温物体。\nC. 气体能够自由膨胀，但不能自动收缩。\nD. 有规则运动的能量能够变为无规则运动的能量，但无规则运动的能量不能变为有规则运动的能量。 1\n\n\n两个电容器 C1​ 和 C2​ 的电容值分别为 200 pF 和 600 pF。把它们串联起来后，等效电容是：\nA. 150 pF\nB. 250 pF\nC. 400 pF\nD. 800 pF 1\n\n\n一质点作匀速率圆周运动时：\nA. 它的动量不变，对圆心的加速度也不变。\nB. 它的动量不变，对圆心的加速度不断改变。\nC. 它的动量不断改变，对圆心的加速度不变。\nD. 它的动量不断改变，对圆心的加速度也不断改变。 1\n\n\n质点系的内力可以改变：\nA. 系统的总质量\nB. 系统的总动量\nC. 系统的总动能\nD. 系统的总角动量 1\n\n\n一物体作简谐振动，振动方程为 x=Acos(ωt+2π​)。则该物体在 t=0 时刻的动能与 t=T/8 (T为振动周期)时刻的动能之比为：\nA. 1:4\nB. 1:2\nC. 1:1\nD. 2:1 1\n\n\n一平面简谐波在弹性媒质中传播，在媒质质元从平衡位置运动到最大位移处：\nA. 它的动能转化为势能。\nB. 它的势能转化为动能。\nC. 它从相邻的一段质元获得能量其能量逐渐增大。\nD. 它把自己的能量传给相邻的一段质元，其能量逐渐减小。 1\n\n\n空气可以承受的场强的最大值为 E=30 kV/cm，超过这个数值时空气要发生火花放电。有一高压平行板电容器，极板间距离为 d=0.5 cm，此电容器可承受的最高电压是：\nA. 30 kV\nB. 15 kV\nC. 30 V\nD. 15 V 1\n\n\n\n二、简答题 (共6小题，每小题5分，总计30分)\n\n\n为什么坦克发射榴弹时，车体会后退一点？请用相关的物理原理进行解释。 1\n\n\n一列平面简谐波从空气入射到水中。它的波长、波速、周期和频率是否发生变化？若发生变化，请说明如何变化。 1\n\n\n分析一个儿童荡秋千的运动是不是简谐振动？为什么？如果是简谐振动，需要满足什么条件？ 1\n\n\n一些精密的电子仪器常采用全金属外壳，使得内部电路免受外界电场干扰。这个原理叫什么？请再列举一个生活中的应用。 1\n\n\n“质点做匀速运动，则该质点受到的合力一定为零”，这句话正确吗？若不正确，请举例说明。 1\n\n\n说明有关角动量守恒定律在生活中的实际例子。（至少2个） 1\n\n\n\n三、计算题 (共7小题，每小题10分，总计70分)\n\n\n已知一质点作直线运动，其加速度为 a=(4t+5) m/s2。在初始时刻 (t=0)，质点的位置是 x=5 m，速度是 v=0。计算该质点在 t=3 s 时的速度和位置。 1\n\n\n一个质量为 10 kg 的质点在xOy平面内运动，受合外力 F=3yi+(y2−4x2)j​ N 的作用。质点沿抛物线 y=2x2 从点 (0,0) 运动到点 (2,8)。计算：\n(1) 外力所做的功。\n(2) 质点动能的变化。 1\n\n\n一个质量为 M 的大木块具有半径为 R 的四分之一弧形槽，如图所示。质量为 m 的小立方体从曲面的顶端滑下。大木块放在光滑水平面上，二者都作无摩擦的运动，而且都从静止开始。求小立方体脱离大木块时，小立方体和大木块的速度分别为多少？ 1\n（附图：一个大木块，上方有一个四分之一圆弧槽，小木块从槽顶滑下。）\n\n\n一个系统由质量为 10×10−3 kg 的小球和轻弹簧组成，在x轴上做简谐振动。振幅为 24 cm，周期为 4.0 s。当 t=0 时位移为 +24 cm。计算：\n(1) 小球的振动方程。\n(2) 在 t=0.5 s 时，小球所在的位置及此时所受力的大小。 1\n\n\n两个无限长同轴圆柱面，半径分别为 R1​ 和 R2​ (R2​&gt;R1​)，单位长度上分别带有电荷 λ 和 −λ。试求：\n(1) r&lt;R1​ 处各点的电场强度。\n(2) R1​&lt;r&lt;R2​ 处各点的电场强度。\n(3) r&gt;R2​ 处各点的电场强度。 1\n\n\n一列平面余弦波沿x轴正向传播，波速为 5 m/s，原点处质点的振动曲线如图所示。\n(1) 写出波动方程。\n(2) 作出 t=0 时的波形图及距离波源 0.5 m 处质点的振动曲线。 1\n（附图：原点处质点的振动曲线，y轴为位移(m)，t轴为时间(s)，曲线显示在t=0时y=0，且向正方向运动，在t=0.2s时达到最大值0.1m，在t=0.4s时回到y=0。）\n\n\n一质点在x轴上作简谐振动，振幅 A=4 cm，周期 T=2 s，其平衡位置取作坐标原点。若 t=0 时质点第一次通过 x=−2 cm 处且向x轴负方向运动，则：\n(1) 写出质点的振动方程。\n(2) 质点第二次通过 x=−2 cm 处的时刻。 1\n\n\n\n参考答案\n一、选择题\n\n\nD\n\n\nB\n\n\nB\n\n\nD\n\n\nA\n\n\nC\n\n\nD\n\n\nC\n\n\nD\n\n\nA\n\n\nD\n\n\nC\n\n\nA\n\n\nA\n\n\nB\n\n\n二、简答题\n\n\n原理：动量守恒定律。\n坦克和榴弹组成一个系统。在发射榴弹的瞬间，系统在水平方向上不受或近似不受外力作用（忽略地面摩擦力），因此系统在水平方向上的总动量守恒。在发射前，坦克和榴弹都处于静止状态，总动量为零。发射时，榴弹以高速向前飞出，获得一个向前的动量。为了保持系统总动量为零，坦克必须获得一个大小相等、方向相反的向后动量，从而导致车体向后退。 1\n\n\n当平面简谐波从空气入射到水中时：\n\n\n频率（f）和周期（T）不变。 波的频率由波源决定，与介质无关。 1\n\n\n波速（v）改变。 由于水的密度和弹性性质与空气不同，波在水中的传播速度会发生变化。通常，声波在水中的速度比在空气中快。 1\n\n\n波长（λ）改变。 根据波速公式 v=λf，由于频率不变而波速改变，因此波长也会随之改变。如果波速增加，波长会变长；如果波速减小，波长会变短。 1\n\n\n\n\n不是严格的简谐振动。\n儿童荡秋千的运动是一种往复运动，但它不是严格意义上的简谐振动。\n\n\n原因： 简谐振动要求回复力与位移成正比且方向相反（即 F=−kx 形式），或者加速度与位移成正比且方向相反（即 a=−ω2x 形式）。对于单摆（秋千可近似为单摆），回复力是重力沿切线方向的分量 F=−mgsinθ。只有当摆角 θ 非常小（通常小于 10∘）时，sinθ≈θ，此时回复力才近似与位移（弧长 s=Lθ）成正比，即 F≈−mgθ=−(mg/L)s。当摆角较大时，sinθ 与 θ 不再近似相等，回复力不再与位移成线性关系，因此不是简谐振动。 1\n\n\n简谐振动需要满足的条件：\n\n\n回复力与位移成正比且方向相反： 系统必须受到一个指向平衡位置的力，且该力的大小与偏离平衡位置的位移成正比。 1\n\n\n系统参数为常量： 描述系统的物理量（如质量、劲度系数等）在振动过程中保持不变。 1\n\n\n在稳定平衡位置附近做往复运动： 振动发生在系统势能最小的稳定平衡点附近。 1\n\n\n\n\n\n\n这个原理叫做静电屏蔽。\n\n\n原理： 当导体处于静电平衡状态时，其内部的电场强度处处为零。这是因为导体内的自由电荷会重新分布，产生一个与外部电场方向相反的内部电场，从而抵消外部电场的影响。因此，导体内部的区域可以免受外部电场的干扰。 1\n\n\n另一个生活中的应用：\n\n\n法拉第笼： 在雷雨天气时，汽车内部相对安全，就是因为汽车的金属外壳形成了一个法拉第笼，将闪电产生的强大电场屏蔽在外，保护了车内人员。 1\n\n\n通讯电缆的金属屏蔽层： 许多通讯电缆（如同轴电缆）外面都有一层金属网或金属箔，用于屏蔽外界电磁干扰，保证信号传输的质量。 1\n\n\n\n\n\n\n不正确。\n这句话不正确。根据牛顿第一定律，如果质点做匀速直线运动，那么它所受到的合力一定为零。但是，如果质点做匀速圆周运动，虽然速度大小不变，但速度方向时刻在改变，因此存在向心加速度。根据牛顿第二定律 (F=ma)，存在加速度就意味着质点受到了不为零的合力（即向心力）。\n\n举例说明： 质点做匀速圆周运动。例如，一个物体在光滑水平面上用绳子拴住做匀速圆周运动，它受到绳子的拉力（向心力），这个合力不为零，但它仍然做匀速运动（速度大小不变）。 1\n\n\n\n角动量守恒定律在生活中的实际例子：\n\n\n花样滑冰运动员的旋转： 当花样滑冰运动员在旋转时，如果她将手臂从张开状态收拢到身体附近，她的转动惯量会减小。为了保持角动量守恒，她的角速度（旋转速度）会显著增加。反之，当她张开手臂时，转动惯量增大，旋转速度减小。 1\n\n\n跳水运动员的空中翻腾： 跳水运动员在空中完成翻腾动作时，通过收紧身体（减小转动惯量）来增加旋转速度，从而在有限的时间内完成更多的翻腾周数。当他们准备入水时，会伸展身体（增大转动惯量）来减慢旋转，以便平稳入水。\n\n\n地球的自转速度： 地球的自转速度在一定程度上受到其内部质量分布变化的影响。例如，冰川融化导致水流向赤道，会轻微增加地球的转动惯量，从而导致地球自转速度略微减慢，以保持角动量守恒。 1\n\n\n\n\n三、计算题\n\n\n解：\n已知加速度 a=4t+5。\n速度 v=∫adt=∫(4t+5)dt=2t2+5t+C1​。\n已知 t=0 时 v=0，代入得 0=2(0)2+5(0)+C1​⟹C1​=0。\n所以速度方程为 v=2t2+5t。\n在 t=3 s 时，速度 v(3)=2(3)2+5(3)=2(9)+15=18+15=33 m/s。 1\n位置 x=∫vdt=∫(2t2+5t)dt=32​t3+25​t2+C2​。\n已知 t=0 时 x=5 m，代入得 5=32​(0)3+25​(0)2+C2​⟹C2​=5。\n所以位置方程为 x=32​t3+25​t2+5。\n在 t=3 s 时，位置 x(3)=32​(3)3+25​(3)2+5=32​(27)+25​(9)+5=18+22.5+5=45.5 m。 1\n答案： 在 t=3 s 时，速度为 33 m/s，位置为 45.5 m。\n\n\n解：\n(1) 计算外力所做的功 W：\n功的定义为线积分 W=∫F⋅dr=∫(Fx​dx+Fy​dy)。\n已知 F=3yi+(y2−4x2)j​，所以 Fx​=3y，Fy​=y2−4x2。\n路径为 y=2x2，所以 dy=4xdx。\n积分限：x从0到2，y从0到8。\n将 y=2x2 和 dy=4xdx 代入积分：\nW=∫x=0x=2​(3(2x2)dx+((2x2)2−4x2)(4xdx))\nW=∫02​(6x2dx+(4x4−4x2)(4xdx))\nW=∫02​(6x2+16x5−16x3)dx\nW=[2x3+616​x6−416​x4]02​\nW=[2x3+38​x6−4x4]02​\nW=(2(2)3+38​(2)6−4(2)4)−(0)\nW=(2×8+38​×64−4×16)\nW=16+3512​−64\nW=348+512−192​=3368​ J。 1\n(2) 计算质点动能的变化 ΔK：\n根据功-能定理，合外力所做的功等于质点动能的变化：\nΔK=Wnet​\n由于题目中给出的力 F 就是合外力，所以 ΔK=W=3368​ J。 1\n答案： (1) 外力所做的功为 3368​ J。 (2) 质点动能的变化为 3368​ J。\n\n\n解：\n将小立方体（质量m）和大木块（质量M）视为一个系统。\n由于大木块放在光滑水平面上，且小立方体与弧形槽之间无摩擦，因此在水平方向上，系统不受外力作用，水平动量守恒。 1\n在竖直方向上，系统受重力和地面的支持力，竖直动量不守恒。\n由于没有摩擦力，且只有重力做功（保守力），因此系统的机械能守恒。 1\n设小立方体脱离大木块时，小立方体的速度为 v，大木块的速度为 V。\n小立方体脱离时，其水平速度分量为 vx​，竖直速度分量为 vy​。大木块的速度 V 只有水平分量。\n\n水平动量守恒：\n\n系统初始静止，总动量为零。\n0=mvx​+MV\n⟹V=−Mm​vx​ (负号表示大木块向左运动) (式1)\n\n机械能守恒：\n\n取水平面（小立方体脱离时的位置）为零势能面。\n初始总机械能 Einitial​=mgR (小立方体在顶端，大木块静止)。\n末态总机械能 Efinal​=21​m(vx2​+vy2​)+21​MV2。\n根据机械能守恒：Einitial​=Efinal​\nmgR=21​m(vx2​+vy2​)+21​MV2 (式2)\n\n几何约束/相对运动：\n\n当小立方体脱离大木块时，它在竖直方向上不再受弧形槽的约束，其竖直速度 vy​ 是其相对于地面的竖直速度。\n同时，小立方体在脱离点相对于大木块的水平速度分量是 vx​−V.\n在脱离瞬间，小立方体沿弧形槽的切线方向的速度是水平的。这意味着小立方体相对于地面的速度 v 在脱离点是水平的，即 vy​=0.\n因此，小立方体脱离时的速度大小为 v=vx​.\n将 vy​=0 代入式2：\nmgR=21​mvx2​+21​MV2 (式3)\n将式1 (V=−Mm​vx​) 代入式3：\nmgR=21​mvx2​+21​M(−Mm​vx​)2\nmgR=21​mvx2​+21​MM2m2​vx2​\nmgR=21​mvx2​+21​Mm2​vx2​\nmgR=21​vx2​(m+Mm2​)\nmgR=21​vx2​Mm(M+m)​\nvx2​=m(M+m)2mgRM​=M+m2gRM​\nvx​=M+m2gRM​​\n小立方体脱离时的速度大小为 vx​=M+m2gRM​​。\n大木块的速度大小为 V=Mm​vx​=Mm​M+m2gRM​​。\n答案：\n小立方体脱离大木块时的速度大小为 M+m2gRM​​。\n大木块脱离时的速度大小为 Mm​M+m2gRM​​。\n\n\n解：\n已知：m=10×10−3 kg=0.01 kg，振幅 A=24 cm=0.24 m，周期 T=4.0 s。\n在 t=0 时，x(0)=+24 cm=+A。\n(1) 小球的振动方程：\n角频率 ω=T2π​=4.02π​=2π​ rad/s。\n简谐振动方程的一般形式为 x(t)=Acos(ωt+ϕ0​)。\n将 t=0 和 x(0)=A 代入：\nA=Acos(2π​(0)+ϕ0​)\nA=Acos(ϕ0​)\ncos(ϕ0​)=1\n所以初相位 ϕ0​=0。\n振动方程为 x(t)=0.24cos(2π​t) (SI单位)。 1\n(2) 在 t=0.5 s 时，小球所在的位置及此时所受力的大小：\n将 t=0.5 s 代入振动方程：\nx(0.5)=0.24cos(2π​×0.5)=0.24cos(4π​)\nx(0.5)=0.24×22​​=0.122​≈0.1697 m。 1\n计算弹簧劲度系数 k：\nω=mk​​⟹k=mω2\nk=(0.01 kg)×(2π​ rad/s)2=0.01×4π2​≈0.02467 N/m。\n此时所受力的大小 F=∣−kx∣：\n∣F∣=∣−(0.02467 N/m)×(0.1697 m)∣\n∣F∣≈0.00419 N。 1\n答案：\n(1) 小球的振动方程为 x(t)=0.24cos(2π​t) (SI)。\n(2) 在 t=0.5 s 时，小球的位置约为 0.17 m，此时所受力的大小约为 0.0042 N。\n\n\n解：\n根据高斯定理，对于具有圆柱对称性的电荷分布，电场线沿径向分布。我们选择一个以圆柱轴线为轴心，半径为 r，长度为 L 的圆柱形高斯面。\n高斯定理表达式为 ∮E⋅dA=ϵ0​Qenc​​。\n由于电场线垂直穿过高斯面的侧面，且侧面面积为 2πrL，而端面没有电场线穿过，所以积分简化为 E⋅2πrL=ϵ0​Qenc​​。\n因此，E=2πϵ0​rLQenc​​。 1\n(1) 当 r&lt;R1​ 时：\n高斯面内部没有包围任何电荷，即 Qenc​=0。\n所以，E1​=0。 1\n(2) 当 R1​&lt;r&lt;R2​ 时：\n高斯面内部只包围了内圆柱面上的电荷，其电荷量为 λL。\n所以，Qenc​=λL。\n代入高斯定理简化式：E2​=2πϵ0​rLλL​=2πϵ0​rλ​。\n方向沿径向向外（如果 λ 为正）。 1\n(3) 当 r&gt;R2​ 时：\n高斯面内部包围了内圆柱面上的电荷 λL 和外圆柱面上的电荷 −λL。\n所以，Qenc​=λL+(−λL)=0。\n因此，E3​=0。 1\n答案：\n(1) 当 r&lt;R1​ 时，电场强度 E1​=0。\n(2) 当 R1​&lt;r&lt;R2​ 时，电场强度 E2​=2πϵ0​rλ​，方向沿径向向外。\n(3) 当 r&gt;R2​ 时，电场强度 E3​=0。\n\n\n解：\n(1) 从振动曲线提取参数：\n\n\n振幅 A： 从图中可以看出，最大位移为 0.1 m，所以 A=0.1 m。\n\n\n周期 T： 从图中可以看出，一个完整振动周期为 0.4 s，所以 T=0.4 s。\n\n\n角频率 ω： ω=2π/T=2π/0.4=5π rad/s。\n\n\n初相位 ϕ0​： 原点处质点振动方程为 y(0,t)=Acos(ωt+ϕ0​)。在 t=0 时，y(0,0)=0，且从图中可以看出，在 t=0 之后，位移向正方向增加（即速度为正）。所以 0=Acos(ϕ0​)，cos(ϕ0​)=0。又因为速度 v(0,t)=−Aωsin(ωt+ϕ0​)，在 t=0 时 v(0,0)=−Aωsin(ϕ0​)&gt;0，所以 sin(ϕ0​)&lt;0。因此，ϕ0​=3π/2 或 −π/2。\n计算波数 k：\n\n\n波长 λ： λ=vT=(5 m/s)×(0.4 s)=2 m。\n\n\n波数 k： k=2π/λ=2π/2=π rad/m。\n波动方程： 由于波沿x轴正向传播，方程形式为 y(x,t)=Acos(kx−ωt+ϕ0​)。代入参数：y(x,t)=0.1cos(πx−5πt−π/2) (SI)。 1\n\n\n(2) t=0 时的波形图： 将 t=0 代入波动方程：y(x,0)=0.1cos(πx−π/2)=0.1sin(πx)。绘制此函数图，横轴为 x，纵轴为 y。\n\n\n在 x=0,1,2,… 处，y=0。\n\n\n在 x=0.5,2.5,… 处，y=0.1。\n\n\n在 x=1.5,3.5,… 处，y=−0.1。\n距离波源 0.5 m 处质点的振动曲线： 将 x=0.5 m 代入波动方程：y(0.5,t)=0.1cos(π×0.5−5πt−π/2)=0.1cos(π/2−5πt−π/2)=0.1cos(−5πt)=0.1cos(5πt)。绘制此函数图，横轴为 t，纵轴为 y。这是一个余弦函数，振幅 0.1 m，周期 T=2π/(5π)=0.4 s。 1\n\n\n答案：\n(1) 波动方程为 y(x,t)=0.1cos(πx−5πt−π/2) (SI)。\n(2) t=0 时的波形图为 y(x,0)=0.1sin(πx)。距离波源 0.5 m 处质点的振动曲线为 y(0.5,t)=0.1cos(5πt)。\n\n\n解：\n已知：振幅 A=4 cm，周期 T=2 s。\n平衡位置取作坐标原点。\nt=0 时质点第一次通过 x=−2 cm 处且向x轴负方向运动。\n(1) 写出质点的振动方程：\n角频率 ω=T2π​=22π​=π rad/s。\n简谐振动方程的一般形式为 x(t)=Acos(ωt+ϕ0​)。\n将 t=0 和 x(0)=−2 cm 代入：\n−2=4cos(π(0)+ϕ0​)\n−2=4cos(ϕ0​)\ncos(ϕ0​)=−1/2。\n同时，已知 t=0 时质点向x轴负方向运动，即速度 v(0)&lt;0。\n速度方程 v(t)=−Aωsin(ωt+ϕ0​)。\nv(0)=−Aωsin(ϕ0​)&lt;0，由于 A&gt;0,ω&gt;0，所以 sin(ϕ0​)&gt;0。\n结合 cos(ϕ0​)=−1/2 和 sin(ϕ0​)&gt;0，可知 ϕ0​ 在第二象限。\n所以 ϕ0​=32π​。\n振动方程为 x(t)=4cos(πt+32π​) (SI单位为cm)。 1\n(2) 质点第二次通过 x=−2 cm 处的时刻：\n第一次通过 x=−2 cm 处是在 t=0 时，此时相位为 ϕ1​=32π​。\n当质点第二次通过 x=−2 cm 处时，其相位应为 ϕ2​=ωt2​+ϕ0​。\n由于余弦函数的周期性，且质点是向负方向运动，下一次通过相同位置并向负方向运动的相位是 ϕ1​+2π。\n所以，πt2​+32π​=32π​+2π。\nπt2​=2π\nt2​=2 s。\n或者，从 t=0 处开始，质点向负方向运动，到达负向端点（−4 cm），然后返回，经过平衡位置，再到达正向端点（+4 cm），再返回，第二次经过 −2 cm 处。\n从 x=−2 cm 沿负方向运动到 x=−4 cm 需要 T/6 (从 Acos(ϕ0​) 到 −A 对应 ϕ0​ 从 2π/3 到 π)。\n从 x=−4 cm 运动到 x=−2 cm 需要 T/6 (从 −A 到 Acos(ϕ0​) 对应 ϕ0​ 从 π 到 4π/3)。\n所以，从 t=0 第一次通过 −2 cm 处向负方向运动，到第二次通过 −2 cm 处向负方向运动，正好是一个周期 T。\n所以 t2​=T=2 s。 1\n答案：\n(1) 质点的振动方程为 x(t)=4cos(πt+32π​) (cm)。\n(2) 质点第二次通过 x=−2 cm 处的时刻为 2 s。\n\n"},"学习笔记":{"slug":"学习笔记","filePath":"学习笔记.md","title":"学习笔记","links":[],"tags":[],"content":"好用的小操作\n求数位之和\nint dig(int x)\n{ \n    return (x + 8) % 9 + 1; \n    // 输入123 返回6\n} \n原理：\n任意一个数字 x 可以写成它的各位数字的加权和，形式如下：\nx = a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0\n其中 a_k, a_(k-1), ..., a_0 是 x 的各个数位的数字。\n关键性质：\n我们知道，对于任何整数 n，有以下等式成立：\n10 ≡ 1 (mod 9)\n这意味着，10 对 9 取模的余数是 1。由此可以推出：\n10^k ≡ 1^k = 1 (mod 9) 对于任意整数 k\n应用到数字表达式：\n现在来看数字 x 对 9 的余数，也就是 x % 9：\nx (mod 9) = (a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0) (mod 9)\n由于 10^k ≡ 1 (mod 9)，我们可以将每个项中的 10^k 替换为 1：\nx (mod 9) = (a_k + a_(k-1) + ... + a_1 + a_0) (mod 9)\n也就是说，x 对 9 取模的结果，实际上等于 x 各位数字之和对 9 的余数。\n向上取整\n// 我们需要计算 x / y 向上取整\n \nint new_num = (x + y - 1) / y;\n在环形区间内移动 凯撒密码\nch = (ch - base + shift) % 26 + base;\n\nshift 是凯撒密码中的“位移”量，也就是你想要将字母平移的位数。举个例子，shift = 3 就意味着每个字母会向右移动3个位置。\nbase 是字母的起始点（基准字符），用于确保加密和解密的计算只在字母范围内循环。例如：\n\n如果字母是小写字母（如 &#039;a&#039;），则 base = &#039;a&#039;。\n如果字母是大写字母（如 &#039;A&#039;），则 base = &#039;A&#039;。\n\n\n\n详细解释：\n\nch - base：\n\n这个操作将字符 ch 转换为一个相对 base 的位置。例如，如果 ch 是 &#039;c&#039;，且 base 是 &#039;a&#039;，那么 &#039;c&#039; - &#039;a&#039; 结果为 2，因为 &#039;a&#039; 的 ASCII 值是 97，&#039;c&#039; 是 99，所以 99 - 97 = 2。\n\n\n(ch - base + shift)：\n\n这个操作将字符向右移动 shift 位。比如，如果你想对字母 &#039;c&#039; 进行加密，shift = 3，那么 (2 + 3) 就是 5。\n\n\n% 26：\n\n由于字母表有 26 个字母，这个操作确保结果循环在 26 个字母内。例如，如果位移后的结果大于 &#039;z&#039;，它会回绕到字母表的开始部分。如果 ch 是 &#039;z&#039;，并且 shift = 1，&#039;z&#039; 经过加密会变成 &#039;a&#039;，而不是 &#039;{&#039;。\n\n\n+ base：\n\n最后，加上 base 就是将数字转换回字母字符。例如，5 + &#039;a&#039; 就会变成 &#039;f&#039;，即将 5 映射回字符。\n\n\n\n字符串 子串处理与替换\n1. replace：\nreplace 用于替换字符串中的部分内容，可以替换从某个位置开始的指定长度的字符。\n基本语法：\nstring&amp; replace (size_t pos, size_t len, const string&amp; str);\nstring&amp; replace (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen);\n\npos: 要替换的起始位置。\nlen: 要替换的字符数。\nstr: 替换的内容。\n\n2. substr：\nsubstr 用于获取字符串的子字符串。\n基本语法：\nstring substr (size_t pos = 0, size_t len = npos) const;\n\npos: 子字符串的起始位置。\nlen: 要提取的子字符串的长度（默认为 npos，表示从 pos 到字符串的末尾）。\n\n快速转换进制\nvector&lt;char&gt; lettermap = {&#039;0&#039;, &#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;, &#039;6&#039;, &#039;7&#039;, &#039;8&#039;, &#039;9&#039;, \n                          &#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;, &#039;h&#039;, &#039;i&#039;, &#039;j&#039;, \n                          &#039;k&#039;, &#039;l&#039;, &#039;m&#039;, &#039;n&#039;, &#039;o&#039;, &#039;p&#039;, &#039;q&#039;, &#039;r&#039;, &#039;s&#039;, &#039;t&#039;, \n                          &#039;u&#039;, &#039;v&#039;, &#039;w&#039;, &#039;x&#039;, &#039;y&#039;, &#039;z&#039;};\n \nsigned main()\n{\n    int num, base;\n    cin &gt;&gt; num &gt;&gt; base;\n    \n    string s = &quot;&quot;;\n \n    // 将数字转换为指定进制\n    while (num)\n    {\n        s = lettermap[num % base] + s;  // 从高位到低位构建， 这样不需要\n        num /= base;\n    }\n \n    cout &lt;&lt; s &lt;&lt; &#039; &#039;;\n}\n异或\n异或的性质\n\n\n实质是二进制无进位加法 例如 1011 + 1101 = 0110\n\n\n异或运算满足交换律、结合律，也就是同一批数字，不管异或顺序是什么，最终的结果都是一个\n\n\nn ^ 0 = n, n ^ n = 0  可以结合第一个加法来理解\n\n\n整体异或和如果是x,整体中某个部分的异或和如果是y,那么剩下部分的异或和是 x ^ y 可以结合2的结合律，交换律来理解\n\n\n这些结论最重要的就是1结论，所有其他结论都可以由这个结论推论得到\n其中第4相关的题目最多，利用区间上异或和的性质\n区间异或和的性质\n计算从 0 到 x 的异或和：\n\n通过观察，可以发现异或的规律每四个数重复一次：\n如果 x % 4 == 0，则 xor(0, x) = x\n如果 x % 4 == 1，则 xor(0, x) = 1\n如果 x % 4 == 2，则 xor(0, x) = x + 1\n如果 x % 4 == 3，则 xor(0, x) = 0\n\n计算区间 [l, r] 的异或和：\n假设我们可以计算出 xor(0, r) 和 xor(0, l-1) ，那么： xor(l, r) = xor(0, r) ^ xor(0, l-1)\n异或的骚操作\n\n交换两个数\n\nint a = 1, b = 2;\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n// as a result a equals 2 and b equals 1\n具体过程：\n\n第一步：a = a ^ b; 之后，a 保存的是 a 和 b 异或的结果，即 a 和 b 的混合信息。\n第二步：b = a ^ b; 在这一步中，a 已经存储了 a ^ b，所以 b = (a ^ b) ^ b。根据自反性，b 变成了原来的 a。\n第三步：a = a ^ b; 最后，a = (a ^ b) ^ a，根据自反性，a 变成了原来的 b。\n\n所以，通过这三步异或操作，我们完成了 a 和 b 的交换，而无需使用额外的临时变量。这种方法是非常高效且空间优化的，尤其是在内存受限的情况下。\n\n找到缺失的数字\n\n// 在1~10中随便挖掉一个 让快速找出\n \n// 原理： 缺失的数字 = 所有数异或和 - 剩下数字的异或和\n \nvector&lt;int&gt; v = {1, 2, 3, 4, 6, 7, 8, 9};\n \n// 计算1 ~ 10 的异或和 也就是 xor(0, 10) ^ xor(0, 0) 而xor(0, 0) = 0\n \nint xor_1_to_10 = 10 + 1 = 11;\n \n// 计算v中数字的异或和 应当从0开始\n \nint xor_v = 0;\nfor (int i = 0; i &lt; v.size(); i++) xor_v ^= v[i];\n \n// 计算剩下的数字\n \nint result = xor_1_to_10 ^ xor_v;\n \n例：\nleetcode268\n可以说是异或很好的板子题\nac codes are as follows:\nclass Solution\n{\npublic:\n    int xor_(int x)\n    {\n        if (x % 4 == 0)\n        {\n            return x;\n        }\n        if (x % 4 == 1)\n        {\n            return 1;\n        }\n        if (x % 4 == 2)\n        {\n            return x + 1;\n        }\n        return 0;\n    }\n \n    int missingNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n \n        // calculate xor from 0 to n\n \n        int xor_1_to_n = xor_(n);\n \n        // calculate xor from array\n        int temp = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            temp ^= i;\n        }\n \n        return xor_1_to_n ^ temp;\n    }\n};\n\n\n数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数\n用到的是性质2 可以往上看一眼\nvector&lt;int&gt; v = {1, 1, 1, 1, 2, 2, 3};\nint res = 0;\nfor (auto &amp;&amp; i : v) res ^= i;\nreturn res; \n// as a result res equals 3\n\n\n例：\nleetcode136\nac codes are as follows:\nclass Solution\n{\npublic:\n    int singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int ans = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            ans ^= i;\n        }\n        return ans;\n    }\n};\n\nBrian Kernighan算法-提取出二进制状态中最右侧的1\n\n其实就是lowbit 将在树状数组中反复使用\n对一个正数x取反 得到x ^ 0\n对其结果 + 1 得到 ~x + 1 其实就是相反数-x\n最后做与运算 则有\nint lowbit(x)\n{\n    return x &amp; (-x);\n}\n最后得到的结果在二进制下将至多只有一个1\n\n数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数\n\n原理：设结果a, b 使得 a != b 那么一定有 a 和 b 在二进制的某一位不相同\n那么原数组中一定可以分成两种数字： 第一种在那一位是0 第二种在那一位是1\n我们只需要分别对这两种数字进行异或和 就能筛选出唯一的数字\n思考：二进制下有多少位不相同 有影响吗？\n**ans：**没有影响 我们要做的只是筛选工作 选出来即可\ncode：\nvector&lt;int&gt; v = {1, 1, 2, 3, 3, 4};\n \nint temp = 0;\nfor (auto &amp;&amp;i : v) temp ^= i;\nint lowbit_num = temp &amp; (-temp);\n \n// 得到了这个唯一的&quot;1&quot; 我们如何继续操作？\n// 我们继续用到与运算：如果num 在 lowbit_num的对应位数上是1 那么结果就是num 如果是0 那么结果就是00000000 也就是0\n \nint ans1 = 0;\nfor (auto &amp;&amp;i : v) if (i &amp; lowbit_num) ans1 ^= i;\nans2 = ans1 ^ lowbit_num;\n// 用到了性质4 部分和 = 全体和 ^ 另一部分和\n例:\nleetcode260\nac codes are as follows:\nclass Solution\n{\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        unsigned xor_nums = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            xor_nums ^= i;\n        }\n \n        int lowbit = xor_nums &amp; (-xor_nums);\n \n        int res1 = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            if (lowbit &amp; i)\n            {\n                res1 ^= i;\n            }\n        }\n        return {res1, res1 ^ (int)xor_nums};\n    }\n};\n \n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\n为什么使用 unsigned 类型来避免溢出\n\n补码表示和溢出问题：\n\n在 C++ 中，整数是以补码的形式存储的。\n对于 int 类型，取负数的操作涉及到补码的反转，当 xor_nums 等于 INT_MIN（即 -2147483648）时，-INT_MIN 会导致溢出。因为 INT_MIN 是 -2147483648，其补码表示超出了 int 类型的范围，因此无法表示其取反的结果，导致未定义的行为。\n\n\n使用 unsigned 类型：\n\nunsigned 类型在存储负数时表现不同，因为它不使用补码。无符号整数的范围是 [0, 2^n - 1]，它不涉及负数，因此在进行负数取反时不会出现溢出问题。\n当你将 xor_nums 声明为 unsigned 类型时，它将不会出现负数，因此 -xor_nums 会按照无符号整数的规则进行计算，不会发生溢出。\n\n\n\n\n\n\n我们可以在以下场景尝试使用unsigned：\n位运算中出现了负数\n如果你需要执行位操作时，运算符会作用于负数，例如 a &amp; b、a ^ b 或 a | b，而某些操作可能涉及到负数的补码表示。这时，使用 unsigned 类型可以避免这些负数影响结果，因为无符号整数的操作不会引发负数的补码计算。\n进行最低位 1 查找（x &amp; (-x)）时\n在诸如 x &amp; (-x) 的操作中，目标是找到二进制表示中最低的 1。如果 x 是负数（例如 -2147483648），在 int 类型中执行 -x 可能导致溢出，因为补码表示不能正确处理 INT_MIN。而如果使用 unsigned 类型， x 会被视为无符号数，取负时不会引发溢出问题。\n\n数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数\n\nto be continued…\n\n今天的题目基本上都可以用map去重做， 这里是为了更好的熟悉异或运算\n\n\n\n                  \n                  Important\n                  \n                \n\n\n重要提示\n    void solve()\n    {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n \n        // int left = xor_(l - 1);\n        // int right = xor_(r);\n        // cout &lt;&lt; (left ^ right);\n \n        cout &lt;&lt; xor_(l - 1) ^ xor_(r);\n    }\n注释部分不会报错 而第十行会报错 是因为cout需要一个可以明确的返回值类型而异或操作给不出, 笔者也没有想明白这是为什么)\n总而言之 在异或操作的外面加一个括号可以完美避免这个问题\n\n\n\n二分\nTO START WITH\n今天的内容侧重于我自己对代码流程的理解和思考 建议初步了解二分思想 想要规范书写流程 培养思维逻辑的读者\n不建议对二分思想毫无了解的读者阅读 你会一头雾水的！（确信\n二分搜索\n\n在有序数组中确定target存在还是不存在\n\n\n\n                  \n                  Important\n                  \n                \n\n\n为什么一定要是有序的？\n二分的思想一定程度上依赖于单调性 无序的数组不存在单调性 无法应用二分\n\n\n\nbool isExist(vector&lt;int&gt; &amp;nums, int target)\n{\n    if (nums.empty()) return 0;\n    \n    int l = 0, r = nums.size() - 1, mid;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        // 为什么不直接(r + l) / 2 ? 两个很大的数字相加有可能会超出int 而line9可以保证计算的过程始终讴歌处于[l, r]\n        \n        if (nums[mid] == target) return 1;\n        else if (nums[mid] &lt; target) /* 缩短左边界 */ l = mid + 1;\n        else /* 缩短右边界 */ r = mid - 1;\n    }\n    //进行到这里还没return 就说明没找到\n    return 0;\n}\n\n在有序数组中找&gt;=target的最左位置\n\n\n\n                  \n                  Important\n                  \n                \n\n\n可以被*upper_bound 替代\n\n\n\nint findleft(vector&lt;int&gt; &amp;nums, int target)\n{\n    int l = 0, r = nums.size() - 1, mid;\n    int ans = -1;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        if (nums[mid] &gt;= target) // 满足条件 更新ans 并继续缩小范围\n        {\n            ans = mid;\n            // 如何缩小范围? 这是一个单调的 现在发现数字大了 那么应该缩小右边界\n            r = mid - 1;\n        }\n        else /* 当前数字太小了 那么应该找更大的 缩小左边界 */ l = mid + 1;\n    }\n    return ans; // 如果没有找到结果 将会返回-1\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如果是 &gt;target的最左位置 应该如何思考？\n事实上 我们只需要把line9的 &gt;= 变成 &gt; 即可\n\n\n\n\n在有序数组中找⇐target的最右位置\n\n那么 ⇐target 的最右位置 应该怎么做呢\nint findright(vector&lt;int&gt; &amp;nums, int target)\n{\n\tint l = 0, r = nums.size() - 1, mid;\n\tint ans = -1;\n\t\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2; // 见识过位运算的骚操作之后还是觉得这样写方便一点 少打一个括号\n\t\tif (nums[mid] &lt;= target) // 这是符合要求的 可以更新边界 更新ans\n\t\t{\n\t\t\tans = mid;\n\t\t\t// 如何更新边界呢？找找有没有更大的数满足条件 缩短左边界\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse r = mid - 1;\n\t}\n\treturn ans; // 没找到返回-1\n}\n\n我们的思考重心应该放在 根据 nums[mid] 和 target 的对应关系 在满足条件的时候更新ans 缩短边界\n\n\n二分搜索不一定发生在有序数组上（比如寻找峰值问题）\n\n板子题 leetcode162\nac codes are as follows:\nclass Solution\n{\npublic:\n    int findPeakElement(vector&lt;int&gt; &amp;nums)\n    {\n        auto n = nums.size();\n \n        if (n == 1) // 只有一个元素 那么这个就是极值点\n        {\n            return 0; // 特\n        }\n\t\t// 首先检查nums.front() 和 nums.back()\n        if (nums[0] &gt; nums[1])\n        {\n            return 0;\n        }\n        if (nums[n - 1] &gt; nums[n - 2])\n        {\n            return n - 1;\n        }\n \n        // 现在已经确定 [1, n - 2] 中一定有极值点 可以开始二分搜索\n \n        int l = 1, r = n - 2, mid;\n \n        while(l &lt;= r)\n        {\n            mid = l + (l - l) / 2;\n \n            // 判断是不是极值点 要看nums[mid]和相邻左右的关系\n \n            if (nums[mid] &gt; nums[mid - 1] and nums[mid] &gt; nums[mid + 1])\n            {\n                return mid;\n            }\n            else\n            {\n                if (nums[mid] &lt; nums[mid - 1])\n                {\n                    // 左边呈上升趋势 缩短右边界 在左边查找\n                    r = mid - 1;\n                }\n                else\n                {\n                    // 缩短左边界 在右边查找\n                    l = mid + 1;\n                }\n            }\n        }\n        return mid;\n    }\n};\n二分搜索 with STL\n在 stl 中 我们有 ranges::upper_bound 和 ranges::lower_bound\nvector&lt;int&gt; v = {1, 2, 3, 4, 5};\n \nauto it1 = ranges::upper_bound(v, 2);\n// 返回指向 v[2] = 3 的迭代器\nauto it2 = ranges::lower_bound(v, 2);\n// 返回指向 v[1] = 2 的迭代器\n分析实质\nranges::upper_bound 返回的it1 满足 *it1 &gt; 2*, 而 ranges::lower_bound 返回的 it2 满足 it2 &gt;= 2\n并且他们都是首个满足条件的元素\n所以我们分析可以得到：\n问 &gt;= x 的最小值 可以int it = *ranges::lower_bound(v, x)\n问 &gt; x 的最小值 可以 int it = *ranges::upper_bound(v, x)\n问 &lt; x  的 最大值 其实就是 &gt;= x 的前一个值\n例如 问 &lt; 3 的最小值 其实就是 &gt;= 3  的前一个值 也就是2\n那我们可以写 int it = *(ranges::lower_bound(v, x) - 1)\n同理：问 &lt;= x 的 最大值 其实就是 &gt; x 的 前一个值\n也就是 int it = *(ranges::upper_bound(v, x) - 1)\n总结 and 板子\n\n\n                  \n                  Important\n                  \n                \n\n\n总结一下吧：\n问更大的有现成函数\n问更小的就 计算目标范围的补集（例如问 &lt;= 那么就求&gt;) 把求出来的结果-1 即可\n最后的判断标准：\n问大就判断是否超出右侧区间；\n问小就判断是否超出左侧区间；\n若询问相等 就额外判等\n\n\n\nvoid find(vector&lt;int&gt; &amp;nums, int target)\n{\n    int n = nums.size();\n    \n\t// 求出首个使得num == target 的num的位置 (不存在返回-1)\n\tint it1 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; ((it1 == n or nums[it1] != target) ? -1 : it1) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt;= target 的num的位置 (不存在返回-1)\n\tint it2 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it2 == n ? -1 : it2) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt; target 的num的位置 (不存在返回-1)\n    int it3 = ranges::upper_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it3 == n ? -1 : it3) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt;= target 的num的位置 (不存在返回-1)\n    int it4 = ranges::upper_bound(nums, target) - nums.begin() - 1; // 其实就是it3 - 1!!!!\n    cout &lt;&lt; (it4 &lt; 0 ? -1 : it4) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt; target 的num的位置 (不存在返回-1)\n    int it5 = ranges::lower_bound(nums, target) - nums.begin() - 1; // 其实就是it2 - 1!!!!\n    cout &lt;&lt; (it5 &lt; 0 ? -1 : it5) &lt;&lt; endl;\n}\n例题\nleetcode34\n第一个位置就是 &gt;= x 的第一个元素\n最后一个位置就是 &gt; x 的前一个元素\n思路：\n// 首先 lower出 &gt;= x 的 第一个元素 判断是否与目标值相等 或者是否来到边界(来到边界意味着数组中没有不小于target的元素)\nint num1 = ranges::lower_bound(nums, target) - nums.begin();\n \nif (num1 == nums.size() or nums[num1] != target)\n{\n\treturn {-1, -1};\n}\nelse\n{\n    // 数组中起码有一个 我们就可以upper了\n    int num2 = ranges::upper_bound(nums, target) - nums.begin() - 1;\n    // remember that 直接与begin()相减 求出来的就是下标\n    return {num1, num2};\n}    \n另外：\n我们也可以利用cpp20的 equal_range 函数 来快速获得范围\n{0, 1, 1, 1, 2}\nauto [start, end] = ranges::equal_range(nums, 1); // 此处的auto应该是pair&lt;iterator, iterator&gt;类型\n// start指向nums[1], end指向nums[3]的下一个 也就是 [start, end) 这样一个半开区间\nif (start == end) return {-1, -1};\nreturn {start - nums.begin(), end - 1 - nums.begin()};\n// 如果问长度那么直接end - start即可\nleetcode35\n直接返回 &gt;= target 的第一个元素位置即可\nreturn ranges::lower_bound(nums, target) - nums.begin();\nleetcode704\n跟上面大差不差 搜索到lower之后比较是否相等即可\nauto num = ranges::lower_bound(nums, target) - nums.begin();\nreturn (num != nums.size() and nums[num] == target ? num : -1);\n\n\n                  \n                  Important\n                  \n                \n\n\n当我们需要使用迭代器的时候 要注意有可能返回 nums.emd() 导致 num = n\n这样的情况下nums[num] 是 越界的\n因此 我们应该加上 num == nums.size() 的判断\n\n\n\nleetcode744\n判断 upper是否 == letters.end() 即可\nauto it = ranges::upper_bound(letters, target) - letters.begin();\nreturn (it == letters.size() ? letters.front() : letters[it]);\nleetcode2529\n什么是数目？\n我们不妨做个测试\n{-1, 0, 1}\nlower(0) - begin() 会返回第一个非负数的下标 记为 it 显然 it - 1就是最后一个负数的下标 本例中为0 那么个数就是最后一个下标  0 + 1 也恰好就是 lower(0) - begin()\nlower(1) - begin() 返回第一个正数的下标 本例中为2 个数应为 size() - it其实就是 end() - lower(1)\nint a = ranges::lower_bound(nums, 0) - nums.begin();\nint b = nums.end() - ranges::upper_bound(nums, 0);\nreturn max(a, b);\n二分答案\n解题步骤\n\n估计最终答案可能的范围是什么 经验之谈：为什么叫做二分答案呢？因为二分的就是答案——问什么就二分什么\n分析问题的答案和给定条件之间的单调性，大部分时候只需要用到自然智慧\n建立一个f函数，当答案固定的情况下，判断给定的条件是否达标\n在最终答案可能的范围上不断二分搜索，每次用f函数判断，直到二分结束，找到最合适的答案\n\n核心点：分析单调性、建立f函数\n注意：这个技巧常用且重要，一定要引起重视\n这么说出来可能过于抽象 我们结合例题理解\n二分答案：求最小\nleetcode1283\n问什么就对什么二分， 我们对除数二分\n除数的上下界怎么找？ 下界应该是1 这样可以让sum最大 上界可以选择ranges::max(nums) 这样可以让sum最小\n那我们就确定下来：\n// 对除数二分\n// 除数的范围应该在[1, ranges::max(num)]\n \nint l = 1, r = ranges::max(nums), m, ans;\n随后二分开始\nwhile (l &lt;= r)\n{\n    m = l + (r - l) / 2;\n    // m 是 除数\n    if (f(m, nums, int threshold)) // 满足条件 记录答案 找更小的\n    {\n        ans = m;\n        r = m - 1;\n    }\n    else // 不满足条件 找更大的\n    {\n        l = m + 1;\n    }\n    return ans;\n}\nf函数如下：\nbool f(int m, vector&lt;int&gt; &amp;nums, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;i: nums)\n    {\n        ans += (i + m - 1) / m; // 上取整 注意能不用ceil就不用ceil 可能造成精度丢失\n        if (ans &gt; target) \n        {\n            return 0;\n        }\n    }\n    return 1;\n}\nleetcode2187\n问时间 我们尝试对时间进行二分\n最快时间应该是 ranges::min(time) 此时 totalTrips = 1\n最慢时间应该是 ranges::min(time) * totalTrips\n不难写出如下代码\nlong long minimumTime(vector&lt;int&gt; &amp;time, int totalTrips)\n{\n    // 二分时间\n    long long l = ranges::min(time), r = l * totalTrips, m, ans;\n    while (l &lt;= r)\n    {\n        m = l + (r - l) / 2;\n \n        if (f(m, time, totalTrips)) ans = m, r = m - 1;\n        else l = m + 1;\n    }\n    return ans;\n}\nf函数也就是常规的加一遍：\nbool f(long long m, vector&lt;int&gt;&amp; time, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;t : time)\n    {\n        ans += m / t;\n        if (ans &gt;= target)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}\n难而杂的例题\nleetcode875\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：有没有可能速度为0?\n当且仅当数组全部都是0的时候 每小时0根也肯定可以吃完\n题目中说到香蕉数量&gt;= 1 那么不可能是0\n因此 最慢速度就是1\n思考：最快速度是多少\n应当为 数组中的最大元素 （一堆最多的香蕉）\n思考：速度再快有意义吗？\n没有了 我们需要用到二分法 那么初始的范围小 对我们的二分是有益的\n\n\n\n经过分析 我们可以得出 速度的取值应当在 [1, *max_element(piles.begin(), piles.end())]\n不难发现：随着速度的增大 吃掉所有香蕉用掉的小时数 只可能不严格单调递减  速度变大反而耗时变多的情况是不存在的\n那我们就可以对速度进行二分  进而求出小时数\nac codes are as follows:\nclass Solution\n{\npublic:\n    int minEatingSpeed(vector&lt;int&gt; &amp;piles, int h)\n    {\n        int l = 1, r = *max_element(piles.begin(), piles.end());\n \n        int ans = 0;\n        int mid = 0;\n        while (l &lt;= r)\n        {\n            mid = l + (r - l) / 2;\n            /*\n            这个mid是什么？是速度\n            我们要求什么？求时间\n            因此我们应该遍历整个香蕉数组， 把用时求出来 和 h 进行比较\n            */\n            long long h1 = 0; // h1 就是 用时 实际比赛的时候我们其实可以#define int long long\n            for (auto &amp;&amp;pile : piles)\n            {\n                /*\n                是熟悉的区间分割诶！\n                我的拙劣的讲解视频 BV15QcAefE5j\n                区间是 mid\n                要划分的变量是 pile\n                用时就是 (pile - 1) / mid + 1\n                我们其实也可以写成\n                (pile + mid - 1) / mid\n                \n                by the way 他的本质其实是 pile / mid 结果向上取整\n                */\n \n                h1 += (pile - 1) / mid + 1;\n            }\n \n            if (h1 &lt;= h) // 当前用时达标！更新答案 放慢速度\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标！增加速度\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n这里有一个很实用的技巧 就是把 速度 → 时间 的变化作为函数封装起来\n具体来说我们有\nint f(vector&lt;int&gt; &amp;piles, int k)\n{\n    int ans = 0;\n    \n    for (auto&amp;&amp; p: piles) ans += (p + k - 1) / k;\n    \n    return ans;\n}\n此处被 return 的 ans 将作为 h1 与 h 进行比较\n这也就是我第3步说的 建立f函数\nleetcode410\n看到「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。\n为什么？「元素和的最大值」越小，需要划分出的段数就越多，反之越少。例如示例 1 的 nums = [7,2,5,10,8]，在最大和为 15 时，至少要划分 3 段，比如 [7,2,5],[10],[8]。而在最大和为 18 时，只需要划分 2 段，比如 [7,2,5],[10,8]。\n一般地，二分的值越小，越不能/能满足要求；二分的值越大，越能/不能满足要求。有单调性的保证，就可以二分答案了。\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如何保证二分结果一定能划分成 k 段？如果小于 k 段呢？\n题目要求划分成 k 段，但其实如果能划分成小于 k 段，也可以划分成 k 段。比如划分成 k−1 段，那么把其中的一个长度至少为 2 的段分成两段，这两段的元素和都比原来的一段小，也满足要求。所以题目相当于：把数组划分成至多 k 段，分别计算每一段的元素和，最小化元素和的最大值。\n应当注意的是， k的取值是 1 &lt;= k &lt;= min(50, nums.length) 这意味着k不会取一个天花乱坠的数字 我们能保证大部分情况下k &lt;= nums.size()  这就够了\n\n\n\n题目问我们最大值 我们就尝试二分最大值\n最大的最大值是多少？k = 1 时数组和的最大值最大 就是accumulate(nums.begin(), nums.end())\n最小的最大值是多少？k = nums.size() 时数组和的最大值最小 是 max_element(nums.begin(), nums.end())\n如何把最大值 跟 k 联系起来？\nf函数参考如下：\nint f(vector&lt;int&gt; nums, int m)\n    {\n        int ans = 1, sum = 0; // 一开始只需要分一段\n \n        for (auto &amp;&amp;i : nums)\n        {\n            if (sum + i &lt;= m) // 如果最大值没超过 那么最大值可以继续增加\n            {\n                sum += i;\n            }\n            else // 超过了就需要增加一段了 与此同时 sum 更新为新的一段\n            {\n                ans++;\n                sum = i;\n            }\n        }\n        return ans;\n    }\n有了这个函数 我们就找到了最大值和段数的关系 那么我们只需要不断二分最大值 让段数逐渐接近k就行\nac codes are as follows:\nint splitArray(vector&lt;int&gt; &amp;nums, int k)\n    {\n        long long sum = accumulate(nums.begin(), nums.end(), 0ll);\n        // 二分的是最大值 要求的答案是k\n        // k 可以尽可能小 因为小于k段却满足条件 我们大可以把其中的一些段分开 也不会影响答案\n        long long ans = 0;\n \n        long long l = *max_element(nums.begin(), nums.end()), r = sum, mid, need;\n        while (l &lt;= r)\n        {\n            // 必须让每一部分的累加和 &lt;= mid， 请问划分成几个部分才够？\n \n            mid = l + (r - l) / 2;\n \n            need = f(nums, mid); // need 是最大值为 mid 所需要的段数\n \n            if (need &lt;= k) // 达标 更新答案 缩小右区间 找更小的最大值\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标 缩小左区间 找更大的最大值\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n\n                  \n                  Important\n                  \n                \n\n\n在f函数中 我们就可以适当的暴力一点 因为f是为二分服务的 而二分本身复杂度就已经很低了\n\n\n\n看完这两题是不是有一点体会了？有的兄弟有的，这样的例题还有一堆\n现在是 20250114 00：01：32\n牛客 机器人跳跃问题\n看到问能量值 那我们尝试二分能量值\n首先要确定能量值的边界\n我们来分析题目：能量值比楼房的高度小 反而要减少 比楼房的高度高 反而要增大\n那我们只需要让他的高度比所有的楼房都要高 不就一定能通过吗\n因此 r = *max_element(v.begin(), v.end())\n那么我们最起码要让他安然无恙的通过最矮的楼房 否则就必定无法通过\n因此 l = *min_element(v.begin(), v.end())\n\n\n                  \n                  Important\n                  \n                \n\n\n最大值最小值的写法在cpp20中已经得到了进一步优化\n我们可以使用 ranges::max(v)  和 ranges::min(v) 来快速求数组的最大 最小值\n\n\n\n那我们写f函数的目的也就随之确定下来， 即：\n给定一个能量值 判断这个能量值是否可以通过所有楼房\nbool f(vector&lt;int&gt; v /* 所有楼房高度 */, int e /* 能量 */, int max_ /* 最大建筑高度 */)\n{\n    for (auto &amp;&amp;i: v)\n    {\n        if (e &gt; i) e += (e - i);\n        else e -= (i - e);\n        \n        // 判断是否达到上边界\n        if (e &gt;= max) return 1;\n        // 判断是否变成负数\n        if (e &lt; 0) return 0;\n    }\n    return 1;\n}\n有了f函数 我们就可以写出二分答案的流程\nvoid solve()\n{\n\tint n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; v(n);\n    for (auto &amp;&amp;i: v) cin &gt;&gt; i;\n    \n    auto l = ranges::min(v), r = ranges::max(v);\n    auto max_ = r;\n    \n    int mid, ans;\n    \n    while (l &lt;= r)\n    {\n        mid = l + (r - l) / 2; // 时刻牢记 mid 是初始能量\n        \n        // 给定能量 用f来验证是否满足题意\n        if (f(v, mid, max_)) // 满足条件 找更小的\n        {\n            ans = mid;\n            r = mid - 1;\n        }\n        else // 不满足条件 找更大的\n        {\n            l = mid + 1;\n        }\n    }\n    cout &lt;&lt; ans;\n}\nleetcode719\nac codes are as follows:\nclass Solution\n{\npublic:\n    int f(vector&lt;int&gt; nums, int lim)\n    {\n        int ans = 0;\n        int r = 0;\n        for (int l = 0; l &lt; nums.size(); l++)\n        {\n            while (r &lt; nums.size() and nums[r] - nums[l] &lt;= lim)\n            {\n                r++;\n            }\n            ans += r - l - 1;\n        }\n        return ans;\n    }\n \n    int smallestDistancePair(vector&lt;int&gt; &amp;nums, int k)\n    {\n        ranges::sort(nums);\n \n        long long l = 0, r = nums.back() - nums.front();\n \n        long long mid, ans, cur;\n \n        while (l &lt;= r)\n        {\n            // 我们再对数字差作二分\n            mid = l + (r - l) / 2;\n            // 要验证是否是第k小 只需要遍历看看 差值 &lt;= mid 的 是否有k个\n            if (f(nums, mid) &gt;= k) // 有可能有更小的 因为 f里面提到 差值 &lt;= mid 即可\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\nf函数的构造比较复杂 值得细品…\nleetcode2141\n并查集\n并查集解决的是怎样的问题呢？就是对集合的 合并 查询\n要想比较高效的完成合并查询工作 我们需要两个数组：father 和  sz， 一个模拟递归的栈stk\n板子：\n初始化：\nvector&lt;int&gt; father, siz;\nstack&lt;int&gt; stk;\n \nvoid init(int n) {\n    father.resize(n);\n    siz.resize(n, 1);\n    ranges::iota(father, 0ll);  // father[i] 初始时指向自己\n}\n完全体：\n// 查找父节点，路径压缩\nint ffind(int i) {\n    while (father[i] != i) {\n        // 递归查找并压缩路径, 使用栈优化递归\n        stk.push(i);\n        i = father[i];\n    }\n    while (!stk.empty())\n    {\n        father[stk.top()] = i; // 将栈中的节点都指向根节点\n        stk.pop();\n    }\n    return father[i];\n}\n \n// 合并两个集合，按秩合并\nvoid union(int i, int j) {\n    int rootI = ffind(i);\n    int rootJ = ffind(j);\n \n    if (rootI != rootJ) {\n        // 按树的大小（秩）合并\n        if (siz[rootI] &lt; siz[rootJ]) {\n            swap(rootI, rootJ);  // 确保 rootI 永远是较大的树\n        }\n        father[rootJ] = rootI;  // 将 rootJ 的根节点指向 rootI\n        siz[rootI] += siz[rootJ];  // 更新 rootI 的大小\n    }\n}\n \nbool issame(int i, int j)\n{\n\treturn ffind(i) == ffind(j);\n}\n精简化写法：\nint ffind(int n)\n{\n    if (n != father[n])\n    {\n        father[n] = ffind(father[n]);\n    }\n    return father[n];\n}\n \nvoid funion(int i, int j)\n{\n\tfather[i] = j;\n}\n \nbool issame(int i, int j)\n{\n    return ffind(i) == ffind(j);\n}\nluoguP3367\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j)\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n    init(n);\n    int a, b, c;\n    while (m--)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        b--, c--; // 0 based\n        if (a == 1)\n        {\n            funion(b, c);\n        }\n        else\n        {\n            cout &lt;&lt; (issame(b, c) ? &#039;Y&#039; : &#039;N&#039;) &lt;&lt; endl;\n        }\n    }\n}\nDFS\n板子：\nvector&lt;pair&lt;int, int&gt;&gt; d = {{1, 0}, {0, 1}{-1, 0}, {0, -1}};\n \nvoid dfs(int i, int j, vector&lt;vector&lt;int&gt;&gt; grid)\n{\n    if (i &lt; 0 or i == grid.size() or j &lt; 0 or j == grid[0].size() or grid[i][j] != 0)\n    {\n        return;\n    }\n    \n    grid[i][j] = 2; // 与原先不同的标记\n    \n    for (auto &amp;&amp;[x, y]: d)\n    {\n        dfs(i + x, j + y, grid);\n    }\n}\n图\n图的表示\n邻接表\nunordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj; // v1, v2, val\n邻接矩阵\n图的遍历\ndfs\nbfs\n图算法\n最小生成树 （MST，Minimum Spanning Tree）\n什么是最小生成树？ 最小生成树是所有节点的最小联通子图， 即：用最小的成本（边的权值）将所有的节点连接到一起\n假如存在 n 个节点 那么必定可以用 n - 1 条边将他们连接到一起， 如何选择这 n - 1 条边就是任务所在\nprim\n\n\n                  \n                  Important\n                  \n                \n\n\n\n解锁的点的放入 set、解锁的边的集合叫 heap（小根堆）。一开始 set 和 heap 都为空。\n可从任意点开始，开始点加入到 set，开始点的所有边加入到 heap\n从 heap 中弹出权值最小的边 e，查看边 e 所去往的点 x\n\n如果 x 已经在 set 中，边 e舍弃，重复步骤3\n如果 x不在 set 中，边 e 属于最小生成树，把 x 加入 set ，重复步骤3\n\n\n当 heap 为空，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m; // n为顶点数，m为边数\n    cin &gt;&gt; n &gt;&gt; m;\n    // prim\n    set&lt;int&gt; nodes; // 存储已访问的节点\n \n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq; // 小顶堆，存储边{权重,目标顶点}\n \n    int MSTweight = 0; // 最小生成树的总权重\n \n    int v1, v2, val; // v1,v2为边的两个顶点，val为边的权重\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表存储图，adj[u]存储u的所有邻边{顶点,权重}\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        // 无向图需要添加两条边\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    pq.push({0, 1}); // 从顶点1开始，初始权重为0\n \n    while (pq.size())\n    {\n        auto [curw, cur] = pq.top(); // curw为当前边的权重，cur为当前顶点\n        pq.pop();\n \n        if (nodes.count(cur)) // 如果当前顶点已访问，跳过\n        {\n            continue;\n        }\n \n        nodes.insert(cur); // 将当前顶点标记为已访问\n        MSTweight += curw; // 将当前边的权重加入最小生成树的总权重\n \n        // 遍历当前顶点的所有邻边\n        for (auto &amp;&amp;[next, nextw] : adj[cur]) // next为邻接顶点，nextw为边权重\n        {\n            if (!nodes.count(next)) // 如果邻接顶点未访问\n            {\n                pq.push({nextw, next}); // 将边加入优先队列\n            }\n        }\n    }\n    if (nodes.size() != n) // 如果访问的顶点数不等于总顶点数，说明图不连通\n    {\n        cout &lt;&lt; &quot;orz&quot;; // 输出无解\n    }\n    else\n    {\n        cout &lt;&lt; MSTweight; // 输出最小生成树的总权重\n    }\n}\nkruskal\n\n\n                  \n                  Important\n                  \n                \n\n\n\n把所有的边，根据权值从小到大排序，从权值小的边开始考虑\n如果连接当前的边不会形成环，就选择当前的边\n如果连接当前的边会形成环，就不要当前的边\n考察完所有边之后，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m, v1, v2, val;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    struct Data\n    {\n        int v1, v2, val;\n    };\n    vector&lt;Data&gt; datas;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        v1--, v2--;\n        if (v1 != v2)\n        {\n            datas.push_back({v1, v2, val});\n        }\n    }\n \n    // kruskal\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri - rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n \n    ranges::sort(datas, [](Data &amp;a, Data &amp;b)\n                 { return a.val &lt; b.val; });\n \n    init(5001);\n    int ans = 0, count = 0;\n \n    vector&lt;bool&gt; visited(n, 0);\n    for (auto &amp;&amp;[v1, v2, val] : datas)\n    {\n        if (!issame(v1, v2))\n        {\n            visited[v1] = visited[v2] = 1;\n            ans += val;\n            funion(v1, v2);\n            count++;\n        }\n    }\n \n    if (count == n - 1)\n    {\n        cout &lt;&lt; ans;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;orz&quot;;\n    }\n}\n拓扑排序\nluoguB3644\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    int num;\n \n    // 没有边权的邻接表\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj;\n    // 入度\n    vector&lt;int&gt; indegree(n + 1, 0); // 1 based\n    vector&lt;int&gt; result;\n \n    for (int i = 1; i &lt;= n; i++)\n    {\n        adj[i];\n        while (cin &gt;&gt; num)\n        {\n            if (num == 0)\n            {\n                break;\n            }\n            adj[i].push_back(num);\n            indegree[num]++; // 入度， 入度！\n        }\n    }\n \n    // 拓扑\n    queue&lt;int&gt; que;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        // 入度为0 可以作为开头 假如队列\n        if (indegree[i] == 0)\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    for (auto &amp;&amp;i : result)\n    {\n        cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n    }\n}\nKMP\nvector&lt;int&gt; getnext(string s)\n{\n\tint n = s.size();\n\tvector&lt;int&gt; v(n, 0);\n\tint j = 0; // 前缀长度\n\tfor (int i = 1; i &lt; n; i++)\n\t{\n\t\twhile (j and s[i] != s[j])\n\t\t{\n\t\t\tj = v[j - 1];\n\t\t}\n\t\tif (s[i] == s[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tv[i] = j;\n\t}\n\treturn v;\n}\n \n "},"学习规划":{"slug":"学习规划","filePath":"学习规划.md","title":"学习规划","links":[],"tags":[],"content":"好的！根据你的目标（2个月从1250-1300提升到1600+），我为你制定了一份详细的训练计划，重点突破关键知识点和提升比赛策略。以下是具体方案：\n\n一、基础巩固阶段（第1-2周）\n目标：夯实基础算法，确保简单题快速AC\n\n每日训练：\n\n每天刷5道800-1000分的题目（Codeforces题库筛选）\n重点类型：贪心、模拟、基础数学（质数、GCD）、简单字符串处理\n\n\n核心知识点：\n\n前缀和与差分数组（解决区间操作问题）\n二分查找（模板题必须秒杀）\n基础DFS/BFS（棋盘类问题）\n\n\n专项突破：\n\n完成Codeforces上所有800-1000分的greedy和math标签题目\n学习Errichto的二分查找教程\n\n\n\n\n二、中级提升阶段（第3-5周）\n目标：掌握中级算法，突破1300-1500分段瓶颈\n\n每日训练：\n\n每天3道1300分题目 + 1道1500分题目（重点攻克）\n参加至少2场Div.3/Div.4虚拟比赛并复盘\n\n\n核心知识点：\n\n动态规划（背包问题、LIS、简单状压DP）\n并查集（处理连通性问题）\n树状数组/线段树（单点修改+区间查询）\n\n\n关键技巧：\n\n学习预处理和状态压缩技巧\n掌握STL高阶用法（lower_bound、priority_queue等）\n练习动态规划经典题单\n\n\n\n\n三、高级突破阶段（第6-7周）\n目标：攻克1600分段核心考点\n\n每日训练：\n\n每天2道1600分题目（重点图论/数论）\n参加Div.2虚拟比赛，专注解决前4题\n\n\n核心知识点：\n\n图论（Dijkstra、Floyd、拓扑排序）\n数论（欧拉定理、快速幂、组合数学）\n复杂DP（区间DP、树形DP）\n\n\n专项资源：\n\n学习Codeforces Edu的图论课程\n完成1500-1600分数段精选题单\n\n\n\n\n四、冲刺阶段（第8周）\n目标：模拟实战，优化比赛策略\n\n每日训练：\n\n每天1场虚拟比赛（Div.2或Div.3）\n重点复盘错题（使用CF Analytics分析弱点）\n\n\n比赛技巧：\n\n前30分钟必须解决A/B题（简单题零失误）\n学会快速判断题目难度（通过过题人数/题目位置）\n掌握Hack技巧（Div.3/Div.4比赛关键加分项）\n\n\n心理建设：\n\n训练时使用CPTimer模拟真实比赛压力\n学习比赛心理调节技巧\n\n\n\n\n五、关键辅助工具\n\n代码模板：\n\n准备标准化的快读模板、常用算法模板\n整理个人错题本（记录易错边界条件）\n\n\n学习社区：\n\n加入Codeforces讨论组（关注官方Telegram频道）\n观看SecondThread的解题直播\n\n\n\n\n六、预期进度检查点\n\n第2周结束：稳定通过Div.3的A-C题\n第5周结束：能解决50%的1500分题目\n第7周结束：在虚拟比赛中达到Rank 1500以内\n第8周结束：正式比赛冲击1600+\n\n\n注意事项：\n\n每天保证至少3小时高效训练（建议拆分为：1小时刷题+1小时学习+1小时复盘）\n遇到难题卡壳不超过30分钟，立刻看题解并重写代码\n重点题目要反复重做（如第一次做错，标记后3天/1周后重做）\n\n按照这个计划严格执行，1600分是完全可达的！需要任何具体题目推荐或知识点详解，可以随时问我。Good luck!\n以下是专为你定制的两个月每日训练计划，整合图论渐进学习与英语提升，每个阶段都包含详细的日程表：\n\n整体框架\n\n每周6天训练 + 1天模拟赛/复盘\n每日时间：3.5小时（算法2.5h + 英语1h）\n核心原则：图论与其他知识点交替学习，避免认知疲劳\n\n\n第1-2周：图论基础与英语奠基\n目标：掌握基础图论算法，建立英语术语反射\n每日模板\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时间段任务类型具体内容9:00-9:30英语晨读精读昨日图论题题干，整理3个专业术语（如adjacency list）10:00-11:30算法训练分块学习：- 40min BFS/DFS基础- 50min 并查集变式15:00-16:00专题突破图论与前置知识结合：- 前缀和+网格BFS（如CF1921D）20:00-20:30英语巩固听TTS朗读今日题目并跟读21:00-21:30错题复盘重写今日错误代码（禁用翻译工具）\n周计划表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n周一周二周三周四周五周六BFS模板题3道并查集+连通分量DFS回溯模板网格类BFS特训动态规划基础虚拟比赛+精析例题1例题2例题3例题4例题5选择最近的Div3全真模拟\n\n第3-4周：图论进阶与英语加速\n目标：掌握最短路径基础，提升读题流畅度\n每日模板升级\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时间段新增内容算法训练新增Dijkstra模板（先用邻接矩阵版再学堆优化）英语训练开始尝试无词典阅读（允许查词但记录生词到Anki）\n核心题单\n图论突破包（每日1主1辅）\n\n\nB. Road Construction 1300\n（并查集判断连通性，英语重点：connectivity）\n\n\nC. Dijkstra? 1900→改编版\n（简化版：仅需输出最短路径长度，改编后≈1400）\n\n\nB. Burglar and Matches 900\n（贪心+结构体排序，英语重点：capacity）\n\n\n组合训练\n周三/六特训：\n\n上午：图论+贪心（如CF1933E)\n下午：图论+前缀和（如CF1921D)\n\n\n第5-6周：图论综合与英语实战\n目标：掌握拓扑排序/环检测，英语读题时间≤8分钟\n重点突破\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n知识点训练策略英语强化拓扑排序从Kahn算法入手→CF510C整理排序相关术语（lex order等）环检测用DFS染色法解决CF1763B区分cycle/loop/circular记忆化搜索结合DP解决树形问题→CF161D树形结构术语（subtree, root等）\n每日流程优化\n09:00-09:30 英语听力：听2道题面音频并复述约束条件\n10:00-11:00 图论新算法学习+模板默写\n11:15-12:00 对应练习题（如拓扑排序应用）\n15:00-16:00 综合训练（图论+其他知识点）\n20:00-20:30 生词Anki复习+造句练习\n21:00-21:30 代码重构训练（将旧题改用新算法实现）\n\n第7-8周：冲刺整合与英语自由\n目标：稳定解决1600分图论题，英语读题零翻译\n决胜策略\n\n\n模式识别训练：\n\n将题目按”图论特征词”分类（如出现”shortest path”立即想到BFS/Dijkstra）\n\n\n\n高频考点突击：\n\n每周一/三/五：图论+数论（如CF1328E)\n每周二/四：图论+贪心（如CF1933E)\n周六：全真模拟赛（强制英语环境）\n\n\n\n终极检验工具：\n\n使用Codeforces Problem Similarity Finder查找薄弱点\n完成Graph Theory EDU最终测试\n\n\n\n\n完整每日计划表（以第3周周二为例）\n今日重点：Dijkstra算法基础 + 英语术语内化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时间任务详细内容/链接9:00英语晨读精读CF20C题干，划出路径相关词汇10:00算法学习观看WilliamFiset的Dijkstra教程（前30分钟）10:30代码默写手写Dijkstra邻接矩阵版模板（参考模板库）11:00基础练习完成改编版CF20C（仅求最短距离）15:00综合训练解决CF1933E（实际是BFS但假装用Dijkstra思考）16:00对比分析比较BFS和Dijkstra在该题的适用性20:00英语巩固听写3道题目的输入输出描述（使用TTS工具）21:00错题重做重做本周内所有图论错题（限时模式）\n\n弹性调节机制\n\n\n若当日任务完成度&lt;70%，次日自动启动补强模式：\n\n减少新知识点学习时间50%\n增加同类题练习数量（×2）\n启用中文辅助解析（仅限当日）\n\n\n\n若连续3天正确率&gt;90%，开启加速通道：\n\n提前学习下一阶段内容\n解锁1600+精选题库\n\n\n\n需要某日的详细题单或遇到瓶颈时的具体突破方案，请提供具体日期和当前进度！"},"数论/EXGCD":{"slug":"数论/EXGCD","filePath":"数论/EXGCD.md","title":"EXGCD","links":[],"tags":[],"content":"扩展欧几里得算法（ExGCD）\n常见考查场景：\n\n求解线性不定方程（Diophantine Equation）。\n解决线性同余方程。\n在中国剩余定理（CRT）中合并方程时计算逆元。\n需要找出贝祖系数来表示 gcd 的线性组合。\n\n典型题目与分析\n\n\n线性不定方程求解\n\n题目描述：给定 a、b 和 c，判断方程ax + by = c是否有整数解，并输出其中一组解。\n考查点：先用 exgcd 求 \\gcd(a,b) ，再判断 c 是否为其倍数。\n分析：如果 ccc 能被 \\gcd(a,b) 整除，则将 exgcd 得到的基本解乘以c/\\gcd(a,b) 即为解。重点在于参数的调整。\n\n\n\n求解模线性方程\n\n题目描述：求解同余方程ax \\equiv c \\ (\\bmod\\ m) 的所有解。\n考查点：判断 \\gcd(a,m) 是否整除 c ；若可解，利用 exgcd 求出基本解，再写出通解形式。\n分析：考查对同余方程解的参数描述和解集刻画。\n\n\n\n求最小非负解\n\n题目描述：在方程 x + by = c 或同余 ax \\equiv b \\ (\\bmod\\ m) 中，要求输出满足某个变量最小非负的解。\n考查点：得到基本解后，通过加减模的周期（或平移参数）调整到非负区域。\n分析：需要灵活应用 exgcd 得到的通解形式，并利用模运算找到最优解。\n\n\n\n鸡兔同笼（或硬币问题）\n\n题目描述：经典问题：鸡和兔子总数和总脚数已知，求鸡和兔子的数量。\n考查点：将问题转化为 2x + 4y = n 的线性方程，并用 exgcd 求解。\n分析：先判断方程可解性，然后找到基本解，再根据问题约束（非负整数）筛选合适的解。\n\n\n\n中国剩余定理（CRT）的实现\n\n题目描述：给定一组同余方程，求一个最小正整数满足所有方程。\n考查点：在每一步合并两个同余方程时，用 exgcd 计算模逆元来构造合并公式。\n分析：考查对 exgcd 在 CRT 算法中作用的理解，重点在于正确处理模数不互质情况（通常题目保证互质）。\n\n\n"},"数论/GCD":{"slug":"数论/GCD","filePath":"数论/GCD.md","title":"GCD","links":[],"tags":[],"content":"int gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n典型题目与分析\n\n\n基础 GCD 题目\n\n题目描述：给定两个整数 a 和 b，求它们的最大公约数。\n考查点：直接使用欧几里得算法。\n分析：这是最简单的数论题，考查递归或迭代实现欧几里得算法，时间复杂度 O(\\log \\min(a,b))。\n\n\n\nGCD 与 LCM 的关系\n\n题目描述：给定两个数，要求同时输出它们的最大公约数和最小公倍数。\n考查点：利用公式  \\text{lcm}(a,b) = \\frac{a \\times b}{\\gcd(a,b)}；同时检验对大数运算和溢出问题的处理。\n分析：先求 gcd，再计算 lcm。注意要用长整型防止乘法溢出。\n\n\n\n数组全局 GCD\n\n题目描述：给定一个数组，求数组中所有元素的 gcd。\n考查点：迭代计算多个数的 gcd。\n分析：从数组左边第一个元素开始，依次计算 \\text{gcd}(res, a[i])，时间复杂度  O(n \\log M)（M 为元素上界）。\n\n\n\n区间 GCD 查询\n\n题目描述：给定一个数组和多个区间查询，每个查询询问区间内所有数的 gcd。\n考查点：数据结构与数论结合，如用线段树或稀疏表实现区间 gcd 查询。\n分析：预处理时间 O(n\\log n)，每个查询O(\\log n)（或 O(1) 的稀疏表版本），适合在线查询问题。\n\n\n\nGCD 累加问题（GCD Sum）\n\n题目描述：求数组中所有满足 i &lt; j 的数对(a_i, a_j) 的 gcd 之和。\n考查点：数论求和技巧和分解思路，有时需要反过来统计每个数作为 gcd 的贡献。\n分析：直接枚举会超时，通常需要利用筛法或反向思考“对每个可能的公因子统计贡献”，考查对数论性质的深入理解。\n\n\n\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\t// 统计每个因子的频率\n\tmap&lt;int, int&gt; mp;\n\tvector&lt;int&gt; v(n);\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; v[i];\n\t\tmp[v[i]]++;\t\n\t}\n \n\t// 对每个d 查看数组中有多少个数字 使得d是其因数\n\tmap&lt;int, int&gt; d;\n\tfor (int i = 1; i &lt;= ranges::max(v); i++)\n\t{\n\t\tfor (int j = i; j &lt;= ranges::max(v); j += i)\n\t\t{\n\t\t\td[i] += mp[j];\n\t\t}\n\t}\n\tint ans = 0;\n\t// 从大到小计算答案 用容斥原理扣除更大因子的贡献\n\tmap&lt;int, int&gt; f;\n\tfor (int i = ranges::max(v); i &gt;= 1; i--)\n\t{\n\t\tauto pr = d[i] * (d[i] - 1) / 2;\n\t\tfor (int k = 2; k * i &lt;= ranges::max(v); k++)\n\t\t{\n\t\t\tpr -= f[k * i];\n\t\t}\n\t\tans += i * pr;\n\t\tf[i] = pr;\n\t}\n\tcout &lt;&lt; ans;\n}"},"有感":{"slug":"有感","filePath":"有感.md","title":"有感","links":[],"tags":[],"content":"一千天啦～祝贺祝贺，按照markdown格式这里可以插入一张图片，点开能看到我们亲嘴子\n感觉朋友圈子里谈到一千天的人也不多吧，亮亮那个闷骚没有发什么长篇大论，王健涵我也不知道一千天没有，打完这段话我就去问问\n上大学半年 我们对很多事情都有了新的体会，聊天的内容也越来越沉重，越来越现实。大概对于我而言，能跟有些人说上话真的得得益于同学这层纽带，好比在社会上见了宇轩我得叫周总，但是有同学情谊在我居然可以叫他儿子。\n之前看到过一个视频，说建议男生在大学谈一段恋爱，因为这是”翻盘的最好机会，大学里的白富美会因为你唱歌好听跟你约会，然而出了社会没人会搭理你”，我们还一起讨论过这个视频，得出的结论是这种行为虽不仁义却十分真实，现在的大学已经慢慢的退出了分配财富的舞台，有时候不免感觉“这么努力还不如找富婆包养来的实在”。也正是因为这样，我居然会在一些时候突然觉得黄景怡是一个虚无缥缈的存在，好像她这段时间只是用来陪我过家家，时间一到就去跟什么大国的王室联姻，从此只能在新闻上看到她和她的宫殿\n我自认为不是一个非常成功的人，很有个性但是没什么能耐，感觉高三飘了一年被高考打回现实了，一年前的今天我可能还跟刘佳南两个半夜不睡觉搬凳子出去阳台吹牛逼然后被陈超穿着树懒睡衣出来说“哥们你们吵死我了”，现在的爱好变成了跟他约着出去打台球的时候喝点小酒然后互相诉苦，发泄对这个很操蛋的世界的不满\n家境不提也罢，偏偏她又那么有才华，我在大学更加努力。我不止一次跟黄景怡说“我真的很怕给不起彩礼 让你过得不舒服”云云，黄景怡也反复跟我说“没关系， 跟你在一起的话没什么钱也是可以的” 。每每想到能让她说出这样有点主观有点扯淡的话，我就觉得我又有活着的动力了\n黄景怡是一个很聪明，很心细的人，在解人意这方面有先天性的优势。但她不是一个外向的人，导致很多时候她都是自我内耗 然后自己解了自己的人意 如果说我在这段恋爱关系中帮到了她什么，大概也就只有“让她变得自信起来”  她现在会跟我分享自己好看的和摆了鬼脸的照片，有精致的也有披头散发的，她不再害怕跟我打视频通话，也允许我在朋友圈发她的 被抓拍照片 看到她的思维，她的伤心难过事一点一点暴露在我面前，我有点接受不了，因此说过“不想听你的负面情绪”这种很极端的言论，但是她没有放弃 在恋爱中一点点把解人意的技巧传授给我，导致我的脾气随着恋爱变好了（有吗？一些人说有）也感觉不再是木头脑袋，也发现女孩子没有那么莫名其妙那么难哄。\n跨省异地恋 是非常 非常 非常痛苦的 我本身情况特殊，父母都是来深打工的，导致我虽然在深圳长大但是逢年过节还是得回老家，哈尔滨的大雪把寒假时间（从我的认知中）延长到了六十天，但我们见面的次数竟寥寥无几 挽着手逛街之后总要分别，每到这时候她就说不想分开，其实我也不想分开，也许我们受不了的其实不是分开，而是长时间未能见面短暂满足心愿又被迫很快分离的愿望破碎感。\n所以我不会后悔1月2号下午做的那个 一个人做十六个半小时硬座去北京的 疯狂决定，也很期待五月一号那个五天假期我们去哪玩\n越写越感觉我其实对她没那么好，黄景怡你是怎么看上我这人的呢？我们两个能情投意合的谈一千天之多 究竟是射箭的还是牵红线的立了功？\n开了学我们都一堆课要忙 更没什么机会聊天，感觉我礼物也不会送，话也说不好听，但是她说要跟我过一辈子诶，那我是应该努努力 ^^\n她已经完完全全的改变了我，让我有了吃饭的时候拍照给她分享食物的习惯（并因此被大学舍友喷是恋爱脑），让我有了更加辩证，更加全面的思考态度 而不是一个非黑即白的人，跟我说了很多为人处世的道理 让我三天可见的朋友圈挂了一堆恋爱日常的置顶，让我在冰城每天都很想她\n所以我打了这些字，放在朋友圈请大家见证：==我不想做一个只会画饼的人，我会尽我的努力让我们俩过得更好 =="},"未命名":{"slug":"未命名","filePath":"未命名.md","title":"未命名","links":[],"tags":[],"content":"最小项的性质\n\n在输入变量的任意取值组合下，有且仅有一个最小项的值为1\n全体最小项的或运算结果为1 即\\sum m = 0\n任意两个最小项的与运算结果为0 即 m_1 \\times m_2 = 0\n具有相邻的两个最小项进行或运算，结果可以合并成一个与项，合并可以消去一个取值互补的变量，留下取值不变的变量。例如：\n\nABC + AB\\overline{C} = AB\n译码器\n译码 是 编码的逆过程，译码器可以将输入的二进制码翻译，给出相应的输出信号。（多入 多出）\n施密特触发器\n原理：\n\n如果 V_i 从 0 开始逐渐增加，当 V_i &lt; V_{th2} 时，施密特触发器的输出 V_o 为高电平1 晶体管截止。\nV_i 继续增加，如果 V_{th2} &lt; V_i &lt; V_{th1} ，输出 V_o 保持高电平不变。\nV_i 再增加，一旦 V_i &gt; V_{th1} 时，V_o 由高电平跳转为低电平，晶体管导通。V_i 在增加，仍是V_i &gt; V_{th1}，电路输出端保持低电平不变。\n如果 V_i 由大于 V_{th1} 的电压值逐渐下降，在\n\n\n有 V_i \\; V_{th1} \\; V_{th2} \\; V_o 其中， V_i 比 V_{th2} 小的时候 施密特触发器输出V_o 是高电平，使得晶体管截止\n\n特点：\n\n允许输入信号为缓慢变化的信号。\n有两个阈值电压。\n有两个稳定状态。\n\n应用：\n脉冲的整形和产生"},"深度学习/python":{"slug":"深度学习/python","filePath":"深度学习/python.md","title":"python","links":[],"tags":[],"content":"os 模块的作用：\nos 是 Python 的标准库模块，用于与操作系统交互，核心功能包括：\n\n路径操作：\n\nos.path.join(path1, path2)：将路径拼接成系统兼容格式（自动处理 / 或 \\）。\n例如：os.path.join(&quot;data&quot;, &quot;train&quot;) → &quot;data/train&quot;（Linux）或 &quot;data\\\\train&quot;（Windows）。\n\n\n目录遍历：\n\nos.listdir(path)：列出指定路径下的所有文件和子目录名称（返回字符串列表）。\n\n\n文件/目录管理：\n\n创建、删除、重命名文件/目录（如 os.makedirs()、os.remove()）。\n\n\n环境信息：\n\n获取操作系统类型、环境变量等（如 os.name, os.getenv()）。\n\n\n\n\nImage 模块的作用（来自 PIL 库）：\nImage 是 Python Imaging Library (PIL) 的核心模块，现由 Pillow 维护，用于图像处理。核心功能包括：\n\n图像加载：\n\nImage.open(path)：从文件加载图像，返回一个 PIL.Image.Image 对象。\n\n\n图像操作：\n\n裁剪、旋转、缩放、滤波、颜色转换等（如 img.resize(), img.convert()）。\n\n\n图像保存：\n\n将图像保存为不同格式（如 img.save(&quot;output.jpg&quot;)）。\n\n\n图像数据访问：\n\n获取像素数据（如 img.getdata()）、图像尺寸（如 img.size）等。\n\n\n\n\nimg 的数据类型：\nimg = Image.open(img_item_path)\n\n类型：PIL.Image.Image 对象。\n本质：这是一个封装了图像像素数据的类实例，包含以下关键属性：\n\nimg.mode：图像模式（如 &#039;RGB&#039;, &#039;L&#039; 表示灰度图）。\nimg.size：图像尺寸（如 (width, height)）。\nimg.format：图像格式（如 &#039;JPEG&#039;, &#039;PNG&#039;）。\n\n\n内存中的数据：图像像素值以二进制形式存储在对象内部，需通过 np.array(img) 或 torchvision.transforms.ToTensor() 转换为数值数组（如 NumPy 数组或 PyTorch 张量）才能用于深度学习模型。\n\n\n代码流程解析：\ndef __getitem__(self, idx):\n    img_name: str = self.img_path[idx]            # 获取第 idx 个文件名（str）\n    img_item_path: str = os.path.join(self.path, img_name)  # 拼接完整路径（str）\n    img = Image.open(img_item_path)              # 加载图像，得到 PIL.Image.Image 对象\n\nimg_name：str 类型，表示单个图像文件名（如 &quot;cat.jpg&quot;）。\nimg_item_path：str 类型，表示图像文件的完整路径（如 &quot;./data/train/cat.jpg&quot;）。\nimg：PIL.Image.Image 类型，表示加载后的图像对象。\n\n\n后续处理建议（深度学习场景）：\nPIL.Image.Image 对象不能直接输入神经网络，需进一步转换：\n\n转换为 NumPy 数组：\nimport numpy as np\nimg_array = np.array(img)  # 形状为 (height, width, channels)，值范围 [0, 255]\n\n转换为 PyTorch 张量：\nfrom torchvision import transforms\ntransform = transforms.ToTensor()\nimg_tensor = transform(img)  # 形状为 (channels, height, width)，值范围 [0.0, 1.0]\n\n标准化（常见预处理）：\nnormalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\nimg_normalized = normalize(img_tensor)  # 标准化后的张量\n\n\n\n总结：\n\nos 模块：处理文件系统路径和目录遍历，确保代码跨平台兼容。\nImage 模块：加载和处理图像，返回 PIL.Image.Image 对象。\nimg 的类型：PIL.Image.Image，需进一步转换为数值数组或张量才能用于深度学习模型。\n"},"深度学习/神经网络与深度学习笔记":{"slug":"深度学习/神经网络与深度学习笔记","filePath":"深度学习/神经网络与深度学习笔记.md","title":"神经网络与深度学习笔记","links":[],"tags":[],"content":"神经网络\n如同大脑需要神经元配合一样，深度学习也需要相应的网络。一个典型的神经网络包含一层层的节点，每一层节点的输入都是前一层或多层的输出（有点像动态规划）。现在的神经网络可以达到几十层甚至上千层，我们称之为深度神经网络。\n认识这个世界\n人之所以能够区分生活中常见的事物，是因为我们感知的信号传递给了大脑；大脑将复杂的信号处理分类，最后得到正确的结果。\n计算机也是如此。在学习过程中，它将大量的不同物体之间的异同点变成神经网络的参数。当你给计算机一张动物图片时，它就能通过对图片的分析，告诉你它是不是小猫。\n深度学习就这样通过构建多层的人工神经网络来模拟人类大脑的信息处理和学习机制，从海量的数据中学习到丰富的规律和知识，从而实现对大量数据的高效处理和分析，解决复杂任务。\n如今，我们可以使用现有的工具快速构建这样的人工神经网络：\n\n\nPython: 一种编程语言，以其简洁、强大、易于学习而著称。\n\n\nPyTorch: 专为Python设计的用于构建和训练深度神经网络的工具包。作为一款流行的深度学习框架，PyTorch以其简洁灵活的特性，让我们能够轻松构建、训练和部署深度学习模型。\n\n\n计算机如何识别你书写的数字？\n让我们看看PyTorch的解题思路。解决这个问题总共需要5步：准备数据、定义模型、训练模型、评估模型、做出预测。\n1. 准备数据\n当我们学习时遇到一道做不出来的题该怎么办？我们会去求助老师，会和同学讨论，或者是寻找学习资料的帮助。当计算机遇到复杂问题时也是这样，不过它用的学习资料都是特定的数据。深度学习框架PyTorch提供了日常练习所需的基础数据集，我们可以从PyTorch里导入手写数字分类数据集，并使用Python来进行可视化展示。\n就算有这样的数据，计算机又是怎么看出我写的数字的呢？其实很简单，我们看到的图和计算机看到的图是不一样的。计算机将图片进行分割，根据图片的颜色信息将其转化成各种通道的数据信息并保存下来，这样计算机就能很好地记住这张图了。\n2. 定义模型\n在正式开始前，我们需要几个概念：卷积层、池化层、全连接层。\n\n\n卷积层: 是计算机认识一张图片最基础的步骤，它将一张图像变成一系列0∼1之间的数据矩阵。\n\n\n池化层: 可以理解为把原来很大的图像矩阵压缩变成一张更小、更容易计算的图像矩阵。\n\n\n全连接层: 计算机还要把这张更小的图像展开成一段数据（过程大概有点类似中序遍历算术表达式？）。这个过程被称为全连接层。\n\n\n而这段处理完的数据就是这张图片的“身份证”了。计算机就用这样的方式认识了这张照片，神经网络的模型也是这样产生的。\n下面是一个这些概念的简要总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念功能作用卷积层提取图像特征，将图像转化为数据矩阵。识别图像中的边缘、纹理等基本特征。池化层压缩图像矩阵，减少数据量和计算复杂度。保留重要特征，同时减少过拟合的风险。全连接层将处理后的图像数据展开成一维向量，进行高级特征组合和分类。整合所有特征，最终输出分类结果或预测值。\n3. 训练模型\n在定义好模型之后就可以开始训练模型了。训练模型的过程实际上就是将训练数据输入模型，计算损失并调整更新模型参数，这样重复进行多个周期，直到模型很好地学到了训练数据里的特征。\n简单来说，训练模型就是我们把大量的已经标定的手写数字图片作为数据告诉计算机，在不断学习复习的过程中，计算机的考试成绩越来越好的过程。\n在这个过程中，我们需要定义损失函数和优化器：\n\n\n损失函数: 用于衡量模型预测的准确性。\n\n\n优化器: 用于调整模型的参数。\n\n\n在这个例子中，我们使用交叉熵损失作为损失函数；使用随机梯度下降作为优化器。\n下面是关于损失函数和优化器的总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念作用示例（手写数字识别）损失函数衡量模型预测结果与真实值之间的差异。交叉熵损失优化器根据损失函数的结果，调整模型参数以最小化损失。随机梯度下降（SGD）\n4. 评估模型 / 预测\n最后我们当然要给计算机检查一下卷子，看看它学得怎么样了。我们随便写下计算机没见过的某个数字，让它用训练好的模型判断一下，看看是不是和我们写下的数字一致。\nPyTorch五步解题法回顾\nPyTorch的解题思路可以概括为以下五步：\n\n\n准备数据\n\n\n定义模型\n\n\n训练模型\n\n\n评估模型\n\n\n做出预测\n\n\n神经网络架构基础\n以一个典型的神经网络为例，其基本构成包括：\n\n\n输入层（Inputs）：接收原始数据。\n\n\n权重（Weights）：每个输入数据与不同的权重相乘。\n\n\n偏差（Bias）：与加权后的输入数据相加。\n\n\n激活函数（Activation Function）：对加权和与偏差的结果进行非线性变换，得到输出。\n\n\n输出层（Output）：将结果传递给下一层神经网络，直至损失函数收敛到最小，得到最终结果。\n\n\n卷积神经网络（CNN）简介与LeNet-5示例\n卷积神经网络是专门为图像输入设计的网络。以经典的LeNet-5为例，它于20世纪90年代推出，是早期成功的CNN架构之一，专为手写数字识别设计，奠定了后续CNN发展的基础。\nLeNet-5包含以下核心要素：\n\n\n卷积层（Convolutional Layer）：用于提取图像特征，生成特征图。\n\n\n池化层（Pooling Layer）：对特征图进行降维，提取最突出的元素。\n\n\n全连接层（Fully Connected Layer）：在特征提取后进行分类预测。\n\n\nLeNet-5图像处理过程示例：\n\n\n原始输入：一张32x32像素的手写数字图像。\n\n\n第一卷积层处理：图像转换为6个28x28像素的特征图。\n\n\n第一池化层作用：特征图降维至6个14x14像素的图像。\n\n\n第二卷积层处理：数据进一步变为16个10x10像素的特征图。\n\n\n第二池化层作用：特征图尺寸减小为16个5x5像素的图像。\n\n\n全连接层处理：网络最终输出一个10维向量，每一维代表一个数字类别的预测概率。 通过这一系列层层深入的处理，LeNet-5能够有效地识别和分类手写数字图像，随着数据量的减少，特征的精确度逐渐增高。\n\n\nPyTorch实操：数据准备\n实操的第一步是准备数据，这包括数据下载、数据格式转换和数据集划分。\n1. 数据下载：MNIST数据集\n手写数字分类是流行的图像分类任务。MNIST数据集包含了6万个用于训练的手写数字样本和1万个用于测试的样本。每个样本都是一个28x28像素的灰度图像，表示0-9的单一数字。该数据集经过预处理，数字位于图像中心，便于研究人员专注于模型构建。\nPyTorch通过torchvision API提供了直接下载和加载MNIST数据集的便捷功能。\n2. 数据格式转换：PIL图像到PyTorch Tensor\n图像数据通常以PIL图像格式（像素数组）存在。为了让计算机程序更容易理解和处理，我们需要将其转换为PyTorch Tensor格式。ToTensor工具可以完成这项工作，它不仅转换格式，还会将每个像素的亮度值（0-255整数）归一化到0-1之间的浮点数。其中，0表示黑色，1表示白色，0到1之间的值表示不同程度的灰色。\n3. 数据集划分：使用Batch和DataLoader\n为了解决每次遍历整个数据集可能导致的效率低下和内存不足问题，深度学习中通常将数据划分为更小的“批次”（batch）。一个batch可以理解为总数据集中的一小部分子数据集。\n这种做法的优势在于：\n\n\n效率提升：模型可以更快地进行小幅度的调整，而不是等待长时间进行一次大的调整。\n\n\n内存优化：避免一次性加载所有数据导致的内存溢出。\n\n\nPyTorch提供了DataLoader工具，可以方便地实现数据集的批次划分和加载功能。通过枚举方式不断进行训练，实现高效的模型优化。\n可视化训练数据示例\n我们使用的数据集是一个形状为Height x Width的二维矩阵（Height和Width都是28）。这个二维矩阵的每个元素都是一个介于0到1之间的浮点数，表示像素值的归一化强度。通过Python循环，可以随机抽样并展示训练集中的25个数据可视化图案。"},"现成的算法函数":{"slug":"现成的算法函数","filePath":"现成的算法函数.md","title":"现成的算法函数","links":[],"tags":[],"content":"下面是关于 C++ 中许多有用的 STL 函数的详细介绍，包括但不限于 partial_sum、accumulate、transform 等。这些函数主要来自 &lt;algorithm&gt; 和 &lt;numeric&gt; 头文件。\n\n1. Accumulate and Reduction Functions\n1.1 std::accumulate\n\n\n功能：累加范围内的值，支持自定义操作。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nT accumulate(InputIterator first, InputIterator last, T init);\nT accumulate(InputIterator first, InputIterator last, T init, BinaryOperation op);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nint sum = std::accumulate(nums.begin(), nums.end(), 0); // 15\nint product = std::accumulate(nums.begin(), nums.end(), 1, std::multiplies&lt;int&gt;()); // 120\n\n\n1.2 std::reduce (C++17)\n\n\n功能：类似 accumulate，但可以并行处理。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nT reduce(ExecutionPolicy&amp;&amp; policy, InputIterator first, InputIterator last, T init);\nT reduce(InputIterator first, InputIterator last, T init, BinaryOperation op);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4};\nint sum = std::reduce(nums.begin(), nums.end(), 0); // 10\n\n\n\n2. Transformation and Manipulation Functions\n2.1 std::transform\n\n\n功能：对范围内的每个元素应用函数，存储结果。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nOutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\nOutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4};\nstd::vector&lt;int&gt; squares(nums.size());\nstd::transform(nums.begin(), nums.end(), squares.begin(), [](int x) { return x * x; });\n\n\n2.2 std::adjacent_difference\n\n\n功能：计算相邻元素的差并存储结果。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nOutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);\nOutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation op);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 4, 7};\nstd::vector&lt;int&gt; diff(nums.size());\nstd::adjacent_difference(nums.begin(), nums.end(), diff.begin()); // {1, 1, 2, 3}\n\n\n\n3. Prefix and Partial Operations\n3.1 std::partial_sum\n\n\n功能：计算前缀和，支持自定义操作。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nOutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);\nOutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation op);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4};\nstd::vector&lt;int&gt; prefixSums(nums.size());\nstd::partial_sum(nums.begin(), nums.end(), prefixSums.begin()); // {1, 3, 6, 10}\n\n\n\n4. Sorting and Partitioning Functions\n4.1 std::sort\n\n\n功能：对范围内的元素排序。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid sort(RandomIt first, RandomIt last);\nvoid sort(RandomIt first, RandomIt last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {4, 2, 1, 3};\nstd::sort(nums.begin(), nums.end()); // {1, 2, 3, 4}\n\n\n4.2 std::stable_sort\n\n\n功能：稳定排序，保持相等元素的顺序。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid stable_sort(RandomIt first, RandomIt last);\nvoid stable_sort(RandomIt first, RandomIt last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {4, 2, 1, 3};\nstd::stable_sort(nums.begin(), nums.end()); // {1, 2, 3, 4}\n\n\n4.3  std::partition\n\n\n功能：将范围内的元素重新排列，使得满足条件的元素位于前半部分。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIterator partition(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nstd::partition(nums.begin(), nums.end(), [](int x) { return x % 2 == 0; }); // {2, 4, 3, 1, 5}\n\n\n4.4 std::partition_point\n\n\n功能：在已按条件分区的范围中找到分区点。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIterator partition_point(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {2, 4, 3, 1, 5}; // 已按条件分区\nauto it = std::partition_point(nums.begin(), nums.end(), [](int x) { return x % 2 == 0; }); // 指向 3\n\n\n\n5. Searching and Counting\n5.1 std::find\n\n\n功能：在范围内查找等于指定值的元素。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nInputIterator find(InputIterator first, InputIterator last, const T&amp; value);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4};\nauto it = std::find(nums.begin(), nums.end(), 3); // 指向 3\n\n\n5.2 std::count\n\n\n功能：计算范围内等于指定值的元素个数。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\ncount(InputIterator first, InputIterator last, const T&amp; value);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 3, 4};\nint count = std::count(nums.begin(), nums.end(), 3); // 2\n\n\n\n6. Unique and Set Operations\n6.1 std::unique\n\n\n功能：移除范围内的连续重复元素。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIt unique(ForwardIt first, ForwardIt last);\nForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate p);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 1, 2, 2, 3};\nauto it = std::unique(nums.begin(), nums.end()); // {1, 2, 3}\nnums.erase(it, nums.end());\n\n\n6.2 std::set_union\n\n\n功能：计算两个有序范围的并集。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nOutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\n\n示例\n：\nstd::vector&lt;int&gt; a = {1, 2, 3};\nstd::vector&lt;int&gt; b = {2, 3, 4};\nstd::vector&lt;int&gt; result;\nstd::set_union(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result)); // {1, 2, 3, 4}\n\n\n7. Numerical and Arithmetic Operations\n7.1 std::inner_product\n\n\n功能：计算两个范围的内积。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nT inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);\nT inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 op1, BinaryOperation2 op2);\n\n\n示例\n：\nstd::vector&lt;int&gt; a = {1, 2, 3};\nstd::vector&lt;int&gt; b = {4, 5, 6};\nint result = std::inner_product(a.begin(), a.end(), b.begin(), 0); // 1*4 + 2*5 + 3*6 = 32\n\n\n7.2 std::iota\n\n\n功能：为范围填充递增值。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\nvoid iota(ForwardIterator first, ForwardIterator last, T value);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums(5);\nstd::iota(nums.begin(), nums.end(), 1); // {1, 2, 3, 4, 5}\n\n\n\n8. Permutation and Combination\n8.1 std::next_permutation\n\n\n功能：生成范围内元素的下一个排列。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nbool next_permutation(BidirectionalIt first, BidirectionalIt last);\nbool next_permutation(BidirectionalIt first, BidirectionalIt last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3};\nstd::next_permutation(nums.begin(), nums.end()); // {1, 3, 2}\n\n\n8.2 std::prev_permutation\n\n\n功能：生成范围内元素的上一个排列。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nbool prev_permutation(BidirectionalIt first, BidirectionalIt last);\nbool prev_permutation(BidirectionalIt first, BidirectionalIt last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 3, 2};\nstd::prev_permutation(nums.begin(), nums.end()); // {1, 2, 3}\n\n\n\n9. Search Algorithms\n9.1 std::binary_search\n\n\n功能：检查有序范围内是否包含某值。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nbool binary_search(ForwardIt first, ForwardIt last, const T&amp; value);\nbool binary_search(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nbool found = std::binary_search(nums.begin(), nums.end(), 3); // true\n\n\n9.2 std::lower_bound\n\n\n功能：找到有序范围中不小于某值的第一个位置。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value);\nForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 3, 3, 5, 7};\nauto it = std::lower_bound(nums.begin(), nums.end(), 3); // 指向第一个3\n\n\n9.3 std::upper_bound\n\n\n功能：找到有序范围中大于某值的第一个位置。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value);\nForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 3, 3, 5, 7};\nauto it = std::upper_bound(nums.begin(), nums.end(), 3); // 指向5\n\n\n\n10. Set Operations\n10.1 std::set_difference\n\n\n功能：计算两个有序范围的差集。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nOutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\n\n示例\n：\nstd::vector&lt;int&gt; a = {1, 2, 3};\nstd::vector&lt;int&gt; b = {2, 3, 4};\nstd::vector&lt;int&gt; result;\nstd::set_difference(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result)); // {1}\n\n\n10.2 std::set_intersection\n\n\n功能：计算两个有序范围的交集。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nOutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\n\n示例\n：\nstd::vector&lt;int&gt; a = {1, 2, 3};\nstd::vector&lt;int&gt; b = {2, 3, 4};\nstd::vector&lt;int&gt; result;\nstd::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::back_inserter(result)); // {2, 3}\n\n\n\n11. Copying and Filling\n11.1 std::copy\n\n\n功能：复制范围的元素到另一位置。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nOutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3};\nstd::vector&lt;int&gt; copy(nums.size());\nstd::copy(nums.begin(), nums.end(), copy.begin());\n\n\n11.2 std::fill\n\n\n功能：将范围内的所有元素赋值为指定值。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid fill(ForwardIterator first, ForwardIterator last, const T&amp; value);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums(5);\nstd::fill(nums.begin(), nums.end(), 42); // {42, 42, 42, 42, 42}\n\n\n11.3 std::generate\n\n\n功能：用生成器函数填充范围内的元素。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid generate(ForwardIterator first, ForwardIterator last, Generator g);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums(5);\nint n = 1;\nstd::generate(nums.begin(), nums.end(), [&amp;n]() { return n++; }); // {1, 2, 3, 4, 5}\n\n\n\n12. Functional Modifications\n12.2 std::replace\n\n\n功能：将范围内的所有匹配值替换为新值。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 2};\nstd::replace(nums.begin(), nums.end(), 2, 42); // {1, 42, 3, 42}\n\n\n\n13. Heap Operations\n13.1 std::make_heap\n\n\n功能：将范围的元素重排为堆。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid make_heap(RandomAccessIterator first, RandomAccessIterator last);\nvoid make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {3, 1, 4, 1, 5};\nstd::make_heap(nums.begin(), nums.end()); // 堆化后的顺序：{5, 3, 4, 1, 1}\n\n\n13.2 std::push_heap\n\n\n功能：将一个元素插入到堆中。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid push_heap(RandomAccessIterator first, RandomAccessIterator last);\nvoid push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {3, 1, 4};\nstd::make_heap(nums.begin(), nums.end());\nnums.push_back(5);\nstd::push_heap(nums.begin(), nums.end()); // 堆化后的顺序：{5, 3, 4, 1}\n\n\n13.3 std::pop_heap\n\n\n功能：移除堆的最大元素（将其移动到范围末尾）。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid pop_heap(RandomAccessIterator first, RandomAccessIterator last);\nvoid pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {3, 1, 4, 5};\nstd::make_heap(nums.begin(), nums.end());\nstd::pop_heap(nums.begin(), nums.end()); // 堆化后顺序：{4, 3, 1}，5在最后\nnums.pop_back(); // 删除最后的最大值\n\n\n\n14. String Manipulation\n14.1 std::getline\n\n\n功能：从输入流中读取一整行。\n\n\n头文件：&lt;string&gt;\n\n\n原型\n：\nstd::istream&amp; getline(std::istream&amp; is, std::string&amp; str);\nstd::istream&amp; getline(std::istream&amp; is, std::string&amp; str, char delim);\n\n\n示例\n：\nstd::string input;\nstd::getline(std::cin, input); // 输入 &quot;Hello, World!&quot;，变量 input 为 &quot;Hello, World!&quot;\n\n\n14.2 std::stoi / std::stol / std::stof / std::stod\n\n\n功能：将字符串转换为整数、长整数或浮点数。\n\n\n头文件：&lt;string&gt;\n\n\n原型\n：\nint stoi(const std::string&amp; str, std::size_t* idx = 0, int base = 10);\nlong stol(const std::string&amp; str, std::size_t* idx = 0, int base = 10);\nfloat stof(const std::string&amp; str, std::size_t* idx = 0);\ndouble stod(const std::string&amp; str, std::size_t* idx = 0);\n\n\n示例\n：\nstd::string s = &quot;42&quot;;\nint n = std::stoi(s); // n = 42\n\n\n15. Other Utilities\n15.1 std::min_element / std::max_element\n\n\n功能：返回范围内最小值或最大值的迭代器。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nForwardIterator min_element(ForwardIterator first, ForwardIterator last);\nForwardIterator max_element(ForwardIterator first, ForwardIterator last);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {3, 1, 4, 1, 5};\nauto min_it = std::min_element(nums.begin(), nums.end()); // 指向 1\nauto max_it = std::max_element(nums.begin(), nums.end()); // 指向 5\n\n\n15.2 std::distance\n\n\n功能：计算两个迭代器之间的距离。\n\n\n头文件：&lt;iterator&gt;\n\n\n原型\n：\ntypename std::iterator_traits&lt;Iterator&gt;::difference_type distance(InputIterator first, InputIterator last);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nint dist = std::distance(nums.begin(), nums.end()); // 5\n\n\n\n16. Randomized Algorithms\n16.1 std::random_shuffle (已弃用，建议用 std::shuffle)\n\n\n功能：随机重排范围内的元素。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid random_shuffle(RandomAccessIterator first, RandomAccessIterator last);\n\n\n示例\n：\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nstd::random_shuffle(nums.begin(), nums.end()); // 随机顺序\n\n\n16.2 std::shuffle\n\n\n功能：用给定的随机数生成器随机重排范围内的元素。\n\n\n头文件：&lt;algorithm&gt;\n\n\n原型\n：\nvoid shuffle(RandomAccessIterator first, RandomAccessIterator last, URNG&amp;&amp; g);\n\n\n示例\n：\n#include &lt;random&gt;\nstd::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::shuffle(nums.begin(), nums.end(), gen); // 随机顺序\n\n\n\n17. Bit Manipulation\n17.1 std::bitset\n\n\n功能：提供操作位序列的工具。\n\n\n头文件：&lt;bitset&gt;\n\n\n原型\n：\ntemplate&lt;size_t N&gt; class bitset;\n\n\n示例\n：\nstd::bitset&lt;8&gt; bs(&quot;1100&quot;);\nbs.set(0); // {1101}\nbs.flip(1); // {1111}\n\n\n17.2 std::popcount (C++20)\n\n\n功能：计算一个整数的二进制表示中 1 的个数。\n\n\n头文件：&lt;bit&gt;\n\n\n原型\n：\nint popcount(unsigned int x);\n\n\n示例\n：\n#include &lt;bit&gt;\nint count = std::popcount(42); // 42 的二进制是 101010，popcount = 3\n\n\n\n18. Numeric Algorithms\n18.1 std::gcd\n\n\n功能：计算两个数的最大公约数。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\ntemplate&lt;class T&gt; T gcd(T x, T y);\n\n\n示例\n：\n#include &lt;numeric&gt;\nint g = std::gcd(42, 56); // g = 14\n\n\n18.2 std::lcm\n\n\n功能：计算两个数的最小公倍数。\n\n\n头文件：&lt;numeric&gt;\n\n\n原型\n：\ntemplate&lt;class T&gt; T lcm(T x, T y);\n\n\n示例\n：\n#include &lt;numeric&gt;\nint l = std::lcm(6, 8); // l = 24\n\n"},"离散1":{"slug":"离散1","filePath":"离散1.md","title":"离散1","links":[],"tags":[],"content":"谓词逻辑推理规则详解（引入与消去）\n一、概念总览\n在形式逻辑中，常用的规则分为两类：\n\n引入规则（Introduction，记作 I）：用于构造新的逻辑结构。\n消去规则（Elimination，记作 E）：用于从已有逻辑结构中提取信息。\n\n我们根据不同逻辑符号来解释这两种规则的使用方式。\n\n二、各类逻辑符号的 I / E 使用详解\n1. 蕴涵（→）\n\n如果你的目标是证明 “A → B”，那么你需要使用“→ 引入”规则。\n\n方法是：假设 A，然后推导出 B，最后得到 A → B。\n\n\n如果你已经知道 A → B，而且你也知道 A，那么你就可以使用“→ 消去”规则，得出 B。这就是著名的“Modus Ponens”。\n\n2. 合取（∧）\n\n如果你想证明 “A ∧ B”，需要使用“∧ 引入”规则。\n\n方法是：分别证明出 A 和 B，然后合并起来。\n\n\n如果你已经有 A ∧ B，并且你只想使用 A（或 B），就用“∧ 消去”规则。\n\n可以分别取出 A 或 B 单独使用。\n\n\n\n3. 析取（∨）\n\n如果你想得到 “A ∨ B”，用“∨ 引入”规则。\n\n举例：你已经知道 A，就可以推出 A ∨ B。\n\n\n如果你已经有 A ∨ B，想进一步得出一个命题 C，就要使用“∨ 消去”规则。\n\n方法是：你要分别从 A 推出 C，从 B 也推出 C，然后才能得出 C。\n\n\n\n4. 否定（¬）\n\n如果你想证明 ¬A，就要用“¬ 引入”规则。\n\n方法是：假设 A 为真，然后推出矛盾（比如 A 与 ¬A 同时成立），从而得到 ¬A。\n\n\n如果你已经有 A 和 ¬A，那就可以推出矛盾（Contradiction），这是“¬ 消去”规则。\n\n5. 全称量词（∀）\n\n如果你要证明 ∀x P(x)，就用“∀ 引入”规则（又叫 UG，一般化规则）。\n\n你需要在证明中让变量 x 保持“任意性”，不能依赖某个具体的假设。\n\n\n如果你已经有 ∀x P(x)，你想用其中某个具体 x，比如 a，那就使用“∀ 消去”规则（又叫 US，通用特例）。\n\n直接推出 P(a)。\n\n\n\n6. 存在量词（∃）\n\n如果你想证明 ∃x P(x)，就用“∃ 引入”规则。\n\n举个具体的例子 a，只要 P(a) 成立，就能推出 ∃x P(x)。\n\n\n如果你已经知道 ∃x P(x)，并想基于它推出某个结论 C，就用“∃ 消去”规则。\n\n方法是：设 P(a) 成立，前提是 a 是新变量，不能出现在任何假设中，然后基于这个假设去推导 C。\n\n\n\n\n三、常用推理技巧\n技巧 1：目标是构造某种逻辑结构（比如 A→B、A∧B、∀xP(x)）时，使用“引入”规则。\n技巧 2：目标是利用某个已有的逻辑结构来提取结论（比如从 A→B 和 A 得出 B），使用“消去”规则。\n技巧 3：处理量词时注意变量的作用域。\n\n∀消去可以任意替换变量\n∃消去时引入的新变量不能依赖其他假设\n\n"},"离散数学-充分复习":{"slug":"离散数学-充分复习","filePath":"离散数学 充分复习.md","title":"离散数学 充分复习","links":[],"tags":[],"content":"集合论\n给定两集合 A、B 全集S 求各种东西\n交并补很显然 需要特别注意 补集也有叫余集的 A在C中的补集等于A在C中的余集\n差集 A - B 就是A有B没有的\n对称差 A \\triangle B 就是并集减去交集\n笛卡尔积 A \\times B 就是A中拿一个元素 B中拿一个元素 得到的集合应该形如 \\{(a_{1},b_{1}),(a_{2},b_{2})...(a_{n},b_{m})\\}\n幂集 2^{A} 就是空集开始 A本身结尾的那个超大集合\n证明两个集合相等\n就是证明AB两个集合互为对方的子集\n要证明两个集合 A 和 B 互为对方的子集（即 A⊆B 且 B⊆A ），从而证明 A=B ，可以按照以下步骤进行：\n1. 证明 A⊆B\n目标 ：证明集合 A 中的所有元素都属于集合 B 。\n方法 ：\n\n任取元素 ：设 x∈A 。\n逻辑推导 ：根据集合 A 的定义和已知条件，推导出 x∈B 。\n结论 ：由 x 的任意性，得出 A⊆B 。\n示例 ： 假设 A={x∈Z∣x 是偶数} ，B={x∈Z∣xmod2=0} 。\n证明 A⊆B ：\n设 x∈A ，则 x 是偶数，即存在整数 k 使得 x=2k 。\n因此 xmod2=0 ，故 x∈B 。\n结论：A⊆B 。\n\n2. 证明 B⊆A\n目标 ：证明集合 B 中的所有元素都属于集合 A 。\n方法 ：\n\n任取元素 ：设 x∈B 。\n逻辑推导 ：根据集合 B 的定义和已知条件，推导出 x∈A 。\n结论 ：由 x 的任意性，得出 B⊆A 。\n\n示例 （接上例）：\n证明 B⊆A ：\n\n设 x∈B ，则 xmod2=0 ，即 x 是偶数。\n因此 x∈A 。\n结论：B⊆A 。\n\n最后得到：\n\n若 A⊆B 且 B⊆A ，则 A=B 。\n\n用运算定律证明对称差满足结合律\n兄弟 这他妈是啥？搜了我都没看懂\n映射\n判断给定映射是否是单射 满射 双射 给出证明\n\\begin{align*}\n&amp;双射\\begin{cases}\n单射 \\ \\ \n\\forall x_{1}, x_{2} \\in 定义域,\\  x_{1} \\neq x_{2} \\implies f(x_{1}) \\neq f(x_{2})\n\\\\\n满射 \\ \\ \n\\forall y \\in 值域,\\  \\exists x \\in 定义域 \\ 使得 \\ f(x) = y\n\\end{cases}\\\\\n\\end{align*}\n我们通常可以把单射和单调性结合起来理解 单调性不变 那么就是单射\n至于满射 我们需要结合定义域和至于判断\n双射需要同时满足单射和满射的条件\n求f, g, h 的合成结果，求逆\n例如f \\circ g 我们可以理解成 f(g(x)) 这样一来先后关系就一目了然了\n映射 f 可求逆的前提条件是 f 是双射\n因此我们需要留一个心眼 求逆的时候重新看一遍所求映射是不是双射\n比如：f(x) = x + 15\\ \\  g(x) = 15x + 1 x,\\ y \\in R  让我们求逆\n逆通常表示成 f^{-1}(y)\\ \\  g^{-1}(y)\n对于 f 显然满足双射的条件 可以得到 f^{-1}(y) = y - 15\n对于 g 发现 y = 2 时, 不存在x \\in R 使得 f(x) = y 因此 g根本不存在逆\n二元关系\n给定集合A 关系R 判断对于A来说 R是否是等价关系 偏序关系\n我们有：\n\\begin{align*}\n&amp;等价关系\\begin{cases}\n自反性\\\\\\\\\n对称性\\\\\\\\\n传递性\n\\end{cases}\n\\end{align*}\n我们把x, y满足R关系 写作 xRy 因此有如下定义：\n自反性：\\forall x \\in A,\\ xRx\n对称性：若 \\, xRy,\\ 则有yRx\n传递性：若 \\ xRy,\\ yRz\\ ,\\ 则有 \\,xRz\n我们有：\n\\begin{align*}\n偏序关系（偏序集）\\begin{cases}\n自反性\\\\\\\\\n反对称性\\\\\n\\\\\n传递性\n\\end{cases}\n\\end{align*}\n反对称性：若 \\, xRy\\ 的同时有\\ yRx,\\ 则x=y\n自行证明即可\n如何求关系的复合运算 逆运算 闭包运算 用关系矩阵求 用关系矩阵的乘法运算求传递闭包\n不会捏\n图论\n无向图，邻接矩阵\n无向图就是没有方向的图\n邻接矩阵就是把图用矩阵表示出来 比如a b 中间有一条无向边 那么 v[a][b] = 1, v[b][a] = 1\n判断图是不是 欧拉图 哈密顿图\n欧拉回路：经过每条边恰好一次的闭合路径（起点 终点 相同）\n欧拉图：存在欧拉回路的图\n欧拉路径：经过每条边恰好一次 而且起点终点不相同的图\n哈密顿回路 ：一条经过图中每个顶点恰好一次 的闭合路径（起点 终点 相同）。\n哈密顿图 ：存在哈密顿回路的图。\n哈密顿路径 ：经过每个顶点一次 起点和终点不同的路径。\n如何判断？\n判断前提：如果图不是连通的 就什么图都不是了  连通性：任意两个顶点可以到达\n欧拉图：所有顶点的度数 deg(v) 都是偶数\n哈密顿图是一个NP完全问题，判断起来比欧拉图复杂得多，但我们仍有一些充分条件和必要条件可以辅助判断\n若顶点数 n &gt;= 3 ：\n\nDirac 定理：若每个顶点的度数 deg(v) &gt;= \\frac{n}{2} 则是哈密顿图\nOre 定理：若对任意两个不相邻的顶点 u, v 有 deg(u) + deg(v) &gt;= n 则是哈密顿图\n\n需要特别注意的是 即使一个图不满足这两个定理 它仍然有可能是哈密顿图 在这种情况下 我们不仿自己动笔画一画 看能不能在图中 构造出一个 经过所有点恰好一次 的 闭合回路\n欧拉图 哈密顿图 的应用\n一笔画问题，邮递员问题 属于欧拉图的应用\n旅行商问题，任务调度问题 属于哈密顿图的应用\n建议自己ai问一下题干 然后看能不能观察出这是xxx图的应用\n能观察出来 基本上就差不多了\n树\n树的六个基本性质\n无圈性（无环性）：树中不存在环\n连通性：任意两个顶点可以到达\n唯一路径性：任意两个顶点的路径唯一\n边数公式：（边数 = 顶点数 - 1）\n极小连通性：删除任意边导致不连通\n极大无圈性：增加任意边导致有环\n判断图是不是平面图\n没找到例题\n有向树\n用二元有序树表示算术表达式（前中后序）\n算术表达式的写法：\n符号在上 字母在下\n加减在上 乘除在下\n前中后序 说的是 根 的顺序 可以具体查询ai来理解\n近世代数\n判断给定代数系统是不是群\n一个代数系统包含一个集合A和一个关系* 通常写作（A,* )\n\\begin{align*}\n群\\begin{cases}\n半群\\begin{cases}\n封闭性\\\\\n\\\\\n结合律\n\\end{cases}\\\\\\\\\n\n幺半群 \\to 单位元\\\\\\\\\n\n\\to 逆元\n\\end{cases}\n\\end{align*}\n封闭性和结合律都是比较显然的 现在重点讲单位元和逆元。\n单位元：\\forall a \\in A, \\ e \\in A,\\ 使得\\ a* e=a成立 解出e e被称作单位元\n对于不同的a e应当是唯一的\n逆元：\\forall a \\in A, \\ \\exists a^{-1} \\in A,\\ 使得 a*a^{-1}=e\\ 成立 解出a^{-1} 对于不同的a a^{-1} 可以是不唯一的 但是如果有一个a不存在a^{-1} 那么这个代数系统就没有逆元 也就不是群\n格 / 布尔代数\n判断给定代数系统是否是偏序集，格，有界格，有补格，分配格，布尔代数\n偏序集：也就是偏序关系 满足自反 反对称 传递\n格：特殊的偏序集，对代数系统中任意两个元素都存在 最小上界（记作 a∨b ) 和 最大下界(记作 a∧b )\n有界格：特殊的格，存在 最大元素 (记作 1) 和 最小元素 (记作 0) ！！\n有补格：特殊的有界格，对代数系统中任意元素都存在补元 使得同时满足 1 和 0\n分配格：特殊的格，满足分配律 \\begin{align*}\na∧(b∨c)=(a∧b)∨(a∧c) \\\\\na∨(b∧c)=(a∨b)∧(a∨c)\n\\end{align*}\n布尔代数：有补的分配格\n概念很多 需要多看几遍\n数理逻辑\n对于给定问题，求结论 / 求结论的有效性\n相对板子的题，自行推导即可。步骤是：\n\n符号化\n推理\n\n求一个命题公式的主析取范式 / 主合取范式\n主析取范式：极小项的或 对应结果是 1 的行\n主合取范式：极大项的与 对应结果是 0 的行\n析取 指的是逻辑或\n合取 指的是逻辑与\n数电怎么做 这个就怎么做\n\n列真值表 000 001 010 写出来\n找到结果 是 1 / 0 的行\n按照要求 先与再或 / 先或再与\n\n谓词逻辑\n求一个谓词公式的命题表示的真值\n涉及部分 德摩根定律 类似的技巧 需要结合具体题目来理解\n通常就是把那个命题写清晰一点 判断是 1 还是 0 即可\n使用谓词公式表示任意命题（符号化）\n符号化有些地方比较恶心 需要结合往年真题逐题分析\n近世代数 考 群 布尔代数\n图论 基本概念 最小生成树 有向图 / 有向树\n数理逻辑 命题 谓词\n集合论 老三样 都是简单题"},"算竞常用-C++-STL-用法":{"slug":"算竞常用-C++-STL-用法","filePath":"算竞常用 C++ STL 用法.md","title":"算竞常用 C++ STL 用法","links":[],"tags":[],"content":"C++ 标准模板库 (STL, Standard Template Library)：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).\n\n示例：\n\n算法：sort(a.begin(), a.end())\n容器：priority_queue&lt;int&gt; pque\n仿函数：greater&lt;int&gt;()\n迭代器：vector&lt;int&gt;::iterator it = a.begin()\n\n1 前言\nSTL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 往往 更顺利。\n不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。\n接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。\n2 常用容器\n2.1 内容总览\n打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。\n\n\n顺序容器\n\n\n array\n\n\n vector\n\n\n deque\n\n\n forward_list\n\n\n list\n\n\n\n\n关联容器\n\n set\n map\n multiset\n multimap\n\n\n\n无序关联容器\n\n unordered_set\n unordered_map\n unordered_multiset\n unordered_multimap\n\n\n\n容器适配器\n\n stack\n queue\n priority_queue\n flat_set\n flat_map\n flat_multiset\n flat_multimap\n\n\n\n字符串\n\n string (basic_string&lt;char&gt;)\n\n\n\n对与元组\n\n pair\n tuple\n\n\n\n2.2 向量 vector\n#include &lt;vector&gt;\n连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。\n2.2.1 常用方法\n构造\nvector&lt;类型&gt; arr(长度, [初值])\n时间复杂度：O(n)\n常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.\nvector&lt;int&gt; arr;         // 构造int数组\nvector&lt;int&gt; arr(100);    // 构造初始长100的int数组\nvector&lt;int&gt; arr(100, 1); // 构造初始长100的int数组，初值为1\n \nvector&lt;vector&lt;int&gt;&gt; mat(100, vector&lt;int&gt; ());       // 构造初始100行，不指定列数的二维数组\nvector&lt;vector&lt;int&gt;&gt; mat(100, vector&lt;int&gt; (666, -1)) // 构造初始100行，初始666列的二维数组，初值为-1\n构造二维数组的奇葩写法，千万别用：\nvector&lt;int&gt; arr[100];         // 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图\nvector&lt;int&gt; arr[100](100, 1); // 语法错误！\nvector&lt;int&gt; arr(100, 1)[100]; // 语法错误！\nvector&lt;int&gt; arr[100] {{100, 1}, 这里省略98个 ,{100, 1}}; // 正确但奇葩，使用列表初始化\n尾接 &amp; 尾删\n\n.push_back(元素)：在 vector 尾接一个元素，数组长度 +1.\n.pop_back()：删除 vector 尾部的一个元素，数组长度 -1\n\n时间复杂度：均摊 O(1)\n// init: arr = []\narr.push_back(1);\n// after: arr = [1]\narr.push_back(2);\n// after: arr = [1, 2]\narr.pop_back();\n// after: arr = [1]\narr.pop_back();\n// after: arr = []\n中括号运算符\n和一般数组一样的作用\n时间复杂度：O(1)\n获取长度\n.size()\n获取当前 vector 的长度\n时间复杂度：O(1)\nfor (int i = 0; i &lt; arr.size(); i++)\n    cout &lt;&lt; a[i] &lt;&lt; endl;\n清空\n.clear()\n清空 vector\n时间复杂度：O(n)\n判空\n.empty()\n如果是空返回 true 反之返回 false.\n时间复杂度：O(1)\n改变长度\n.resize(新长度, [默认值])\n修改 vector 的长度\n\n如果是缩短，则删除多余的值\n如果是扩大，且指定了默认值，则新元素均为默认值**（旧元素不变）**\n\n时间复杂度：O(n)\n2.2.2 适用情形\n一般情况 vector 可以替换掉普通数组，除非该题卡常。\n有些情况普通数组没法解决：n\\times m 的矩阵，1\\leq n,m\\leq 10^6 且 n\\times m \\leq 10^6\n\n如果用普通数组 int mat[1000010][1000010]，浪费内存，会导致 MLE。\n如果使用 vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))，完美解决该问题。\n\n另外，vector 的数据储存在堆空间中，不会爆栈。\n2.2.3 注意事项\n提前指定长度\n如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 .push_back(). 因为 vector 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。\n// 优化前: 522ms\nvector&lt;int&gt; a;\nfor (int i = 0; i &lt; 1e8; i++)\n    a.push_back(i);\n// 优化后: 259ms\nvector&lt;int&gt; a(1e8);\nfor (int i = 0; i &lt; a.size(); i++)\n    a[i] = i;\n当心 size_t 溢出\nvector 获取长度的方法 .size() 返回值类型为 size_t，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 [0,2^{32}).\nvector&lt;int&gt; a(65536);\nlong long a = a.size() * a.size(); // 直接溢出变成0了\n2.3 栈 stack\n#include &lt;stack&gt;\n通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。\n2.3.1 常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例构造stack&lt;类型&gt; stkstack&lt;int&gt; stk;进栈.push(元素)stk.push(1);出栈.pop()stk.pop();取栈顶.top()int a = stk.top();查看大小 / 清空 / 判空略略\n2.3.2 适用情形\n如果不卡常的话，就可以直接用它而不需要手写栈了。\n另外，vector 也可以当栈用，vector 的 .back() 取尾部元素，就相当于取栈顶，.push_back() 相当于进栈，.pop_back() 相当于出栈。\n2.3.3 注意事项\n不可访问内部元素！下面都是错误用法\nfor (int i = 0; i &lt; stk.size(); i++)\n    cout &lt;&lt; stk[i] &lt;&lt; endl;\nfor (auto ele : stk)\n    cout &lt;&lt; stk &lt;&lt; endl;\n2.4 队列 queue\n#include &lt;queue&gt;\n通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。\n2.4.1 常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例构造queue&lt;类型&gt; quequeue&lt;int&gt; que;进队.push(元素)que.push(1);出队.pop()que.pop();取队首.front()int a = que.front();取队尾.back()int a = que.back();查看大小 / 清空 / 判空略略\n2.4.2 适用情形\n如果不卡常的话，就可以直接用它而不需要手写队列了。\n2.4.3 注意事项\n不可访问内部元素！下面都是错误用法\nfor (int i = 0; i &lt; que.size(); i++)\n    cout &lt;&lt; que[i] &lt;&lt; endl;\nfor (auto ele : que)\n    cout &lt;&lt; ele &lt;&lt; endl;\n2.5 优先队列 priority_queue\n#include &lt;queue&gt;\n提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。\n2.5.1 常用方法\n构造\npriority_queue&lt;类型, 容器, 比较器&gt; pque\n\n类型：要储存的数据类型\n容器：储存数据的底层容器，默认为 vector&lt;类型&gt;，竞赛中保持默认即可\n比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义\n\npriority_queue&lt;int&gt; pque1;                            // 储存int的大顶堆\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; // 储存int的小顶堆\n\n对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。\n\n其他\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例进堆.push(元素)que.push(1);出堆.pop()que.pop();取堆顶.top()int a = que.top();查看大小 / 判空略略\n进出队复杂度 O(\\log n)，取堆顶 O(1).\n2.5.2 适用情形\n持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 n，插入操作数量 k.\n\n每次插入后进行快速排序：k\\cdot n\\log n\n使用优先队列维护：k\\cdot\\log n\n\n2.5.3 注意事项\n仅堆顶可读\n只可访问堆顶，其他元素都无法读取到。下面是错误用法：\ncout &lt;&lt; pque[1] &lt;&lt; endl;\n所有元素不可写\n堆中所有元素是不可修改的。下面是错误用法：\npque[1] = 2;\npque.top() = 1;\n如果你恰好要修改的是堆顶元素，那么是可以完成的：\nint tp = pque.top();\npque.pop();\npque.push(tp + 1);\n2.6 集合 set\n#include &lt;set&gt;\n提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n集合三要素解释setmultisetunordered_set确定性一个元素要么在集合中，要么不在✔✔✔互异性一个元素仅可以在集合中出现一次✔❌（任意次）✔无序性集合中的元素是没有顺序的❌（从小到大）❌（从小到大）✔\n2.6.1 常用方法\n构造\nset&lt;类型, 比较器&gt; st\n\n类型：要储存的数据类型\n比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义\n\nset&lt;int&gt; st1;               // 储存int的集合（从小到大）\nset&lt;int, greater&lt;int&gt;&gt; st2; // 储存int的集合（从大到小）\n\n对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。\n\n遍历\n可使用迭代器进行遍历：\nfor (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it)\n    cout &lt;&lt; *it &lt;&lt; endl;\n基于范围的循环（C++ 11）：\nfor (auto &amp;ele : st)\n    cout &lt;&lt; ele &lt;&lt; endl;\n其他\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例插入元素.insert(元素)st.insert(1);删除元素.erase(元素)st.erase(2);查找元素.find(元素)auto it = st.find(1);判断元素是否存在.count(元素)st.count(3);查看大小 / 清空 / 判空略略\n增删查时间复杂度均为 O(\\log n)\n2.6.2 适用情形\n\n元素去重：[1,1,3,2,4,4]\\to[1,2,3,4]\n维护顺序：[1,5,3,7,9]\\to[1,3,5,7,9]\n元素是否出现过：元素大小 [-10^{18},10^{18}]，元素数量 10^6，vis 数组无法实现，通过 set 可以完成。\n\n2.6.3 注意事项\n不存在下标索引\nset 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。下面是错误用法：\ncout &lt;&lt; st[0] &lt;&lt; endl;\n元素只读\nset 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. 下面是错误用法：\ncout &lt;&lt; *st.begin() &lt;&lt; endl; // 正确。可读。\n*st.begin() = 1;             // 错误！不可写！\n不可用迭代器计算下标\nset 的迭代器不能像 vector 一样相减得到下标。下面是错误用法：\nauto it = st.find(2);      // 正确，返回2所在位置的迭代器。\nint idx = it - st.begin(); // 错误！不可相减得到下标。\n2.7 映射 map\n#include &lt;map&gt;\n提供对数时间的有序键值对结构。底层原理是红黑树。\n映射：\n\\begin{matrix}\r\n1&amp;\\to&amp;2\\\\\r\n2&amp;\\to&amp;2\\\\\r\n3&amp;\\to&amp;1\\\\\r\n4&amp;\\to&amp;5\\\\\r\n&amp;\\vdots\r\n\\end{matrix}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n性质解释mapmultimapunordered_map互异性一个键仅可以在映射中出现一次✔❌（任意次）✔无序性键是没有顺序的❌（从小到大）❌（从小到大）✔\n2.7.1 常用方法\n构造\nmap&lt;键类型, 值类型, 比较器&gt; mp\n\n键类型：要储存键的数据类型\n值类型：要储存值的数据类型\n比较器：键比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义\n\nmap&lt;int, int&gt; mp1;               // int-&gt;int 的映射（键从小到大）\nmap&lt;int, int, greater&lt;int&gt;&gt; st2; // int-&gt;int 的映射（键从大到小）\n\n对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。\n\n遍历\n可使用迭代器进行遍历：\nfor (map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); ++it)\n    cout &lt;&lt; it-&gt;first &lt;&lt; &#039; &#039; &lt;&lt; it-&gt;second &lt;&lt; endl;\n基于范围的循环（C++ 11）：\nfor (auto &amp;pr : mp)\n    cout &lt;&lt; pr.first &lt;&lt; &#039; &#039; &lt;&lt; pr.second &lt;&lt; endl;\n结构化绑定 + 基于范围的循环（C++17）：\nfor (auto &amp;[key, val] : mp)\n    cout &lt;&lt; key &lt;&lt; &#039; &#039; &lt;&lt; val &lt;&lt; endl;\n其他\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例增 / 改 / 查元素中括号mp[1] = 2;查元素（返回迭代器）.find(元素)auto it = mp.find(1);删除元素.erase(元素)mp.erase(2);判断元素是否存在.count(元素)mp.count(3);查看大小 / 清空 / 判空略略\n增删改查时间复杂度均为 O(\\log n)\n2.7.2 适用情形\n需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(map&lt;string, int&gt; mp)\n2.7.3 注意事项\n中括号访问时默认值\n如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。\nmap&lt;char, int&gt; mp;\ncout &lt;&lt; mp.count(&#039;a&#039;) &lt;&lt; endl; // 0\nmp[&#039;a&#039;];                       // 即使什么都没做，此时mp[&#039;a&#039;]=0已经插入了\ncout &lt;&lt; mp.count(&#039;a&#039;) &lt;&lt; endl; // 1\ncout &lt;&lt; mp[&#039;a&#039;] &lt;&lt; endl;       // 0\n不可用迭代器计算下标\nmap 的迭代器不能像 vector 一样相减得到下标。下面是错误用法：\nauto it = mp.find(&#039;a&#039;);      // 正确，返回2所在位置的迭代器。\nint idx = it - mp.begin();   // 错误！不可相减得到下标。\n2.8 字符串 string\n#include &lt;string&gt;\n顾名思义，就是储存字符串的。\n2.8.1 常用方法\n构造\n构造函数：string(长度, 初值)\nstring s1;           // 构造字符串，为空\nstring s2 = &quot;awa!&quot;;  // 构造字符串，并赋值awa!\nstring s3(10, &#039;6&#039;);  // 构造字符串，通过构造函数构造为6666666666\n输入输出\nC++\nstring s;\ncin &gt;&gt; s;\ncout &lt;&lt; s;\nC\nstring s;\nchar buf[100];\nscanf(&quot;%s&quot;, &amp;buf);\ns = buf;\nprintf(&quot;%s&quot;, s.c_str());\n其他\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n作用用法示例修改、查询指定下标字符[]s[1] = &#039;a&#039;;是否相同==if (s1 == s2) ...字符串连接+string s = s1 + s2;尾接字符串+=s += &quot;awa&quot;;取子串.substr(起始下标, 子串长度)string sub = s.substr(2, 10);查找字符串.find(字符串, 起始下标)int pos = s.find(&quot;awa&quot;);\n数值与字符串互转（C++11）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n源目的函数int / long long / float / double / long doublestringto_string()stringintstoi()stringlong longstoll()stringfloatstof()stringdoublestod()stringlong doublestold()\n2.8.2 适用情形\n非常好用！建议直接把字符数组扔了，赶快投入 string 的怀抱。\n2.8.3 注意事项\n尾接字符串一定要用 +=\nstring 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.\n通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。\n// 优化前: 15139ms\nstring s;\nfor (int i = 0; i &lt; 5e5; i++)\n    s = s + &quot;a&quot;;\n \n// 优化后: &lt; 1ms (计时器显示0)\nstring s;\nfor (int i = 0; i &lt; 5e5; i++)\n    s += &quot;a&quot;;\n.substr() 方法的奇葩参数\n一定要注意，C++ string 的取子串的第一个参数是子串起点下标，第二个参数是子串长度。\n第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。\n.find() 方法的复杂度\n该方法实现为暴力实现，时间复杂度为 O(n^2).\n不要幻想 STL 内置了个 O(n) 的 KMP 算法\n2.9 二元组 pair\n#include &lt;utility&gt;\n顾名思义，就是储存二元组的。\n2.9.1 常用方法\n构造\npair&lt;第一个值类型, 第二个值类型&gt; pr\n\n第一个值类型：要储存的第一个值的数据类型\n第二个值类型：要储存的第二个值的数据类型\n\npair&lt;int, int&gt; p1;\npair&lt;int, long long&gt; p2;\npair&lt;char, int&gt; p3;\n// ...\n赋值\n老式\npair&lt;int, char&gt; pr = make_pair(1, &#039;a&#039;);\n列表构造 C++11\npair&lt;int, char&gt; pr = {1, &#039;a&#039;};\n取值\n直接取值\n\n取第一个值：.first\n取第二个值：.second\n\npair&lt;int, char&gt; pr = {1, &#039;a&#039;};\nint awa = pr.first;\nchar bwb = pr.second;\n结构化绑定 C++17\npair&lt;int, char&gt; pr = {1, &#039;a&#039;};\nauto &amp;[awa, bwb] = pr;\n判同\n直接用 == 运算符\npair&lt;int, int&gt; p1 = {1, 2};\npair&lt;int, int&gt; p2 = {1, 3};\nif (p1 == p2) { ... } // false\n2.9.2 适用场景\n所有需要二元组的场景均可使用，效率和自己定义结构体差不多。\n2.9.3 注意事项\n无\n3 迭代器简介\n3.1 迭代器是什么？\n不搞抽象，直接举例。\n对于一个 vector，我们可以用下标遍历：\nfor (int i = 0; i &lt; a.size(); i++)\n    cout &lt;&lt; a[i] &lt;&lt; endl;\n我们同时也可以用迭代器来遍历：\nfor (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it)\n    cout &lt;&lt; *it &lt;&lt; endl;\n\na.begin() 是一个迭代器，指向的是第一个元素\na.end() 是一个迭代器，指向的是最后一个元素再后面一位\n上述迭代器具有自增运算符，自增则迭代器向下一个元素移动\n迭代器与指针相似，如果对它使用解引用运算符，即 *it，就能取到对应值了\n\n3.2 为何需要迭代器？\n很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。\n迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。\n例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：\nfor (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it)\n    cout &lt;&lt; *it &lt;&lt; endl;\n3.3 迭代器用法\n对于 vector 容器，它的迭代器功能比较完整，以它举例：\n\n.begin()：头迭代器\n.end()：尾迭代器\n.rbegin()：反向头迭代器\n.rend()：反向尾迭代器\n迭代器 + 整型：将迭代器向后移动\n迭代器 - 整型：将迭代器向前移动\n迭代器 ++：将迭代器向后移动 1 位\n迭代器 --：将迭代器向前移动 1 位\n迭代器 - 迭代器：两个迭代器的距离\nprev(it)：返回 it 的前一个迭代器\nnext(it)：返回 it 的后一个迭代器\n\n对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）\n3.4 常见问题\n.end() 和 .rend() 指向的位置是无意义的值\n对于一个长度为 10 的数组：for (int i = 0; i &lt; 10; i++)，第 10 位是不可访问的\n对于一个长度为 10 的容器：for (auto it = a.begin(); it != a.end(); ++it)，.end 是不可访问的\n不同容器的迭代器功能可能不一样\n迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。\n删除操作时需要警惕\n为什么 3 没删掉？\nvector&lt;int&gt; a{1, 2, 3, 4};\nfor (auto it = a.begin(); it != a.end(); ++it)\n    if (*it == 2 || *it == 3)\n        a.erase(it);\n// a = [1, 3, 4]\n为啥 RE 了？\nvector&lt;int&gt; a{1, 2, 3, 4};\nfor (auto it = a.begin(); it != a.end(); ++it)\n    if (*it == 4)\n        a.erase(it);\n建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）\n4 常用算法\n4.1 内容总览\n打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。\n（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）\n\n\n算法库 Algorithm\n\n count()\n find()\n fill()\n swap()\n reverse()\n shuffle() C++11\n unique()\n sort()\n lower_bound() / upper_bound()\n max() / min()\n max_element() / min_element()\n prev_permutation() / next_permutation()\n\n\n\n数学函数 cmath\n\n abs()\n exp()\n log() / log10() / log2()\n pow()\n sqrt()\n sin() / cos() / tan()\n asin() / acos() / atan()\n sinh() / cosh() / tanh()\n asinh() / acosh() / atanh() C++11\n ceil() / floor()\n round() C++11\n\n\n\n数值算法 numeric\n\n iota() C++11\n accumulate()\n gcd() C++17\n lcm() C++17\n\n\n\n伪随机数生成 random\n\n mt19937\n random_device()\n\n\n\n4.2 swap()\n交换两个变量的值\n用法示例\ntemplate&lt; class T &gt;\nvoid swap( T&amp; a, T&amp; b );\nint a = 0, b = 1;\nswap(a, b);\n// now a = 1, b = 0\n \nint arr[10] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nswap(arr[4], arr[6]);\n// now arr = {0, 1, 2, 3, 6, 5, 4, 7, 8, 9}\n注意事项\n这个 swap 参数是引用的，不需要像 C 语言一样取地址。\n4.3 sort()\n使用快速排序给一个可迭代对象排序\n用法示例\ntemplate&lt; class RandomIt, class Compare &gt;\nvoid sort( RandomIt first, RandomIt last, Compare comp );\n默认排序从小到大\nvector&lt;int&gt; arr{1, 9, 1, 9, 8, 1, 0};\nsort(arr.begin(), arr.end());\n// arr = [0, 1, 1, 1, 8, 9, 9]\n如果要从大到小，则需要传比较器进去。\nvector&lt;int&gt; arr{1, 9, 1, 9, 8, 1, 0};\nsort(arr.begin(), arr.end(), greater&lt;int&gt;());\n// arr = [9, 9, 8, 1, 1, 1, 0]\n如果需要完成特殊比较，则需要手写比较器。\n比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 \\star：\n\n若 a\\star b，则比较器函数应当返回 true\n若 a\\not\\star b，则比较器函数应当返回 false\n\n**注意：**如果 a=b，比较器函数必须返回 false\nbool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)\n{\n    if (a.second != b.second)\n        return a.second &lt; b.second;\n    return a.first &gt; b.first;\n}\n \nint main()\n{\n    vector&lt;pair&lt;int, int&gt;&gt; arr{{1, 9}, {2, 9}, {8, 1}, {0, 0}};\n\tsort(arr.begin(), arr.end(), cmp);\n    // arr = [(0, 0), (8, 1), (2, 9), (1, 9)]\n}\n4.4 lower_bound() / upper_bound()\n在已升序排序的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。找不到则返回尾迭代器。\n\nlower_bound(): 寻找 \\geq x 的第一个元素的位置\nupper_bound(): 寻找 &gt;x 的第一个元素的位置\n\n怎么找 \\leq x / &lt; x 的第一个元素呢？\n\n&gt;x 的第一个元素的前一个元素（如果有）便是 \\leq x 的第一个元素\n\\geq x 的第一个元素的前一个元素（如果有）便是 &lt;x 的第一个元素\n\n返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。\n用法示例\ntemplate&lt; class ForwardIt, class T &gt;\nForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );\nvector&lt;int&gt; arr{0, 1, 1, 1, 8, 9, 9};\nvector&lt;int&gt;::iterator it = lower_bound(arr.begin(), arr.end(), 7);\nint idx = it - arr.begin();\n// idx = 4\n我们通常写成一行：\nvector&lt;int&gt; arr{0, 1, 1, 1, 8, 9, 9};\nidx = lower_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4\nidx = lower_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 4\nidx = upper_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4\nidx = upper_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 5\n4.5 reverse()\n反转一个可迭代对象的元素顺序\n用法示例\ntemplate&lt; class BidirIt &gt;\nvoid reverse( BidirIt first, BidirIt last );\nvector&lt;int&gt; arr(10);\niota(arr.begin(), arr.end(), 1);\n// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nreverse(arr.begin(), arr.end());\n// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n4.6 max() / min()\n返回最大值 / 最小值的数值\n用法示例\nint mx = max(1, 2); // 2\nint mn = min(1, 2); // 1\n在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：\n// Before C++11\nint mx = max(max(1, 2), max(3, 4)); // 4\nint mn = min(min(1, 2), min(3, 4)); // 1\n \n// After C++11\nint mx = max({1, 2, 3, 4}); // 4\nint mn = min({1, 2, 3, 4}); // 1\n4.7 unique()\n消除数组的重复相邻元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。\n例如：[1,1,4,5,1,4]\\to[1,4,5,1,4,\\underline?]，下划线位置为返回的迭代器指向。\ntemplate&lt; class ForwardIt &gt;\nForwardIt unique( ForwardIt first, ForwardIt last );\n用法示例\n单独使用 unique 并不能达成去重效果，因为它只消除相邻的重复元素。但是如果序列有序，那么它就能去重了。\n但是它去重后，序列尾部会产生一些无效数据：[1,1,2,4,4,4,5]\\to[1,2,4,5,\\underline?,?,?]，为了删掉这些无效数据，我们需要结合 erase.\n最终，给 vector 去重的写法便是：\nvector&lt;int&gt; arr{1, 2, 1, 4, 5, 4, 4};\nsort(arr.begin(), arr.end());\narr.erase(unique(arr.begin(), arr.end()), arr.end());\n4.8 数学函数\n所有函数参数均支持 int / long long / float / double / long double\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n公式示例f(x)=\\lvert x\\rvertabs(-1.0)f(x)=e^xexp(2)f(x)=\\ln xlog(3)f(x,y)=x^ypow(2, 3)f(x)=\\sqrt xsqrt(2)f(x)=\\lceil x\\rceilceil(2.1)f(x)=\\lfloor x\\rfloorfloor(2.1)f(x)=\\left&lt;x\\right&gt;rount(2.1)\n注意事项\n由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。\n\n原文地址：codeforces.com/blog/entry/107717\n\n\n\\lfloor\\frac{a}{b}\\rfloor\n\n别用：floor(1.0 * a / b)\n要用：a / b\n\n\n\\lceil\\frac{a}{b}\\rceil\n\n别用：ceil(1.0 * a / b)\n要用：(a + b - 1) / b  （\\lceil\\frac{a}{b}\\rceil=\\lfloor\\frac{a+b-1}{b}\\rfloor）\n\n\n\\lfloor\\sqrt a\\rfloor\n\n别用：(int) sqrt(a)\n要用：二分查找 io.zouht.com/7.html\n\n\na^b\n\n别用：pow(a, b)\n要用：快速幂 io.zouht.com/18.html\n\n\n\\lfloor\\log_2 a\\rfloor\n\n别用：log2(a)\n要用：__lg （不规范，但是这是竞赛）/ bit_width（C++20 可用）\n\n\n\n4.9 gcd() / lcm()\n（C++17）返回最大公因数 / 最小公倍数\nint x = gcd(8, 12); // 4\nint y = lcm(8, 12); // 24\n如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 __gcd().\n当然，gcd / lcm 函数也挺好写，直接写也行（欧几里得算法）：\nint gcd(int a, int b)\n{\n    if (!b)\n        return a;\n    return gcd(b, a % b);\n}\n \nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}"},"组合数板子":{"slug":"组合数板子","filePath":"组合数板子.md","title":"组合数板子","links":[],"tags":[],"content":"const int MAXN = 1e7;\nconst int MOD = 1e9 + 7;\n \nvector&lt;int&gt; fact(MAXN), invfact(MAXN);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n\tint ans = 1;\n\twhile (exp)\n\t{\n\t\tif (exp &amp; 1)\n\t\t{\n\t\t\tans = ans * base % MOD;\n\t\t}\n\t\tbase = base * base % MOD;\n\t\texp &gt;&gt;= 1;\n\t}\n\treturn ans;\n}\n \nint inv(int x)\n{\n\treturn ksm(x, MOD - 2);\n}\n \nvoid pre()\n{\n\tif (inited) return;\n\tinited = 1;\n\tfact[0] = 1;\n\tfor (int i = 1; i &lt; MAXN; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t}\n \n\tinvfact[MAXN - 1] = inv(fact[MAXN - 1]);\n\tfor (int i = MAXN - 2; i &gt;= 0; i--)\n\t{\n\t\tinvfact[i] = invfact[i + 1] * (i + 1) % MOD;\n\t}\n}\n \nint comb(int n, int k)\n{\n\tif (!inited) pre();\n\tif (k &lt; 0 or k &gt; n) return 0;\n\treturn fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}"},"贪心套路/P1":{"slug":"贪心套路/P1","filePath":"贪心套路/P1.md","title":"P1","links":["贪心套路/P2"],"tags":[],"content":"题目1\n题目1\n题目1\n题目1\n题目1\n题目1\nP2"},"贪心套路/P2":{"slug":"贪心套路/P2","filePath":"贪心套路/P2.md","title":"P2","links":["模下快速幂","贪心套路/P3"],"tags":[],"content":"题目1\n现需要将一根长为正整数n的竹子砍为若干段\n每段长度均为正整数\n请返回每段竹子长度的最大乘积是多少\n答案需要对1000000007取模\n前置知识：模下快速幂\n观察得到：\nn = 4 -&gt; 2 * 2 -&gt; 4 % 3 = 1\nn = 5 -&gt; 3 * 2 -&gt; 5 % 3 = 2\nn = 6 -&gt; 2 * 2 -&gt; 6 % 3 = 0\nn = 7 -&gt; 3 * 2 * 2 -&gt; 7 % 3 = 1\nn = 8 -&gt; 3 * 3 * 2 -&gt; 8 % 3 = 2\nn = 9 -&gt; 3 * 3 * 3 -&gt; 9 % 3 = 0\n \n进而\nn &lt;= 3 特判\nn &gt; 3 时\nif (n % 3 == 0)\n{\n\treturn quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 1)\n{\n\tn -= 4;\n\treturn 4 * quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 2)\n{\n\tn -= 2;\n\treturn 2 * quickmod(3, n / 3, mod) % mod;\n}\n \n也可以这么写：\nauto tail = n % 3 == 0 ? 1 : (n % 3 == 1 ? 4 : 2);\nauto power = tail == 1 ? n : (n - tail) / 3;\nreturn quickmod(3, power, mod) * tail % mod;\n题目2\n一个数字n一定要分成k份 得到的乘积最大是多少\n数字n 和 k 有可能到达{10}^{12}\n结果需要对 1e9 + 7 取模\n先计算平均值 再算多多少\nint n, k, mod = 1e9 + 7;\ncin &gt;&gt; n &gt;&gt; k;\nauto a = n / k;\nauto b = n % k;\nauto ans1 = quickmod(a + 1, b, mod);\nauto ans2 = quickmod(a, k - b, mod);\nreturn ans1 * ans2 % mod;\n题目3\n给若干会议的开始，结束时间\n参加某个会议的期间 不能参加其他会议\n返回能参加的最大会议数量\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[v1, v2] : v)\n{\n\tcin &gt;&gt; v1 &gt;&gt; v2;\n}\n \n// 贪心策略 结束时间早的早排\nranges::sort(v, [](auto &amp;v1, auto &amp;v2) { return v1.second &lt; v1.second; });\nint ans = 1;\nauto [beg, en] = v[0];\nfor (int i = 1; i &lt; n; i++)\n{\n\tauto [curbe, curen] = v[i];\n\tif (curbe &gt;= en)\n\t{\n\t\ten = curen;\n\t\tans++;\n\t}\n}\nreturn ans;\n题目4\n给定若干会议的开始，结束时间\n任何会议的召开期间 你只需要抽出一天来参加\n但是 同一天只能参加一个会议\n返回你能参加的最大会议数量\n\n思路：\n等价于牛客寒假H\n两种做法 一种是维护一个小根堆 一种是集合 + 二分\n\n二分做法\nint n, ans = 0, last = -1;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[a, b] : v) cin &gt;&gt; a &gt;&gt; b; last = max(last, b);\nranges::sort(v, [](auto &amp;&amp;v1, auto &amp;&amp;v2)\n{\n\tauto [a, b] = v1, [c, d] = v2;\n\treturn a == c ? b &lt; d : a &lt; c;\t\n});\nset&lt;int&gt; st;\nfor (int i = 1; i &lt;= last; i++) st.insert(i);\n \nfor (auto &amp;&amp;[a, b] : v)\n{\n\tauto it = st.lower_bound(a);\n\tif (it != st.end() and *it &lt;= r)\n\t{\n\t\tans++;\n\t\tst.erase(*it);\n\t}\n}\n \ncout &lt;&lt; ans;\n小根堆做法：\nint n, ans = 0;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nmap&lt;int, vector&lt;int&gt;&gt; mp;\nfor (auto &amp;&amp;[a, b] : v) \n{\n\tcin &gt;&gt; a &gt;&gt; b;\n\tmp[a].emplace_back(b);\n}\n \npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nint index = 1;\nfor (auto &amp;&amp;i : mp[index]) pq.push(i);\nwhile (pq.size())\n{\n\twhile (pq.size() and pq.top() &lt; index) pq.pop();\n\tif (!pq.empty()) \n\t{\n\t\tpq.pop();\n\t\tans++;\n\t\tindex++;\n\t\tfor (auto &amp;&amp;i : mp[index]) pq.push(i);\n\t}\n}\ncout &lt;&lt; ans;\n题目5\n给你n个项目，对于每一个项目i\n有一个纯利润prefits[i] 和启动该项目需要的最小资本 capital[i]\n最初你的资本是w 完成一个项目的时候你将获得纯利润 添加到你的总资本中\n从给定项目中选择最多k个不同项目的列表 最大化你的最终资本ans\nint n, w, k; \ncin &gt;&gt; n &gt;&gt; w &gt;&gt; k; \nvector&lt;pair&lt;int, int&gt;&gt; projects(n); // pair&lt;capital, profit&gt; \nfor (int i = 0; i &lt; n; i++) \n{ \n\tcin &gt;&gt; projects[i].second; // profit \n} \nfor (int i = 0; i &lt; n; i++) \n{\n\tcin &gt;&gt; projects[i].first; // capital \n} \n// 按启动资本排序\nranges::sort(projects);\n// 优先队列保存利润，默认是大顶堆 \npriority_queue&lt;int&gt; pq; \nint index = 0; \nfor (int i = 0; i &lt; k; i++) \n{ \n\t// 将所有启动资本小于等于当前资金的项目加入优先队列 \n\twhile (index &lt; n &amp;&amp; projects[index].first &lt;= w) \n\t{ \n\t\tpq.push(projects[index].second); \n\t\tindex++; \n\t} \n\t// 如果没有可做的项目，则退出 \n\tif (pq.empty()) break; \n\t// 选择当前利润最大的项目 \n\tw += pq.top(); \n\tpq.pop(); \n} \ncout &lt;&lt; w;\n题目6\n给定一个非负数组v 计算任何两个数差值的绝对值\n如果v中没有 将绝对值加入到v里 但是只加入一次\n直到arr大小固定 返回最终长度\n结论：求出这个数组中所有数字的gcd 记为num\n这个数组中所有数字的最大值 记为max\n那么\nfor (int i = num; i &lt;= max; i += num) // 所有的i都会在这个数组中\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n;i ++) \n{\n\tcin &gt;&gt; v[i];\n\tmp[v[i]]++;\n}\nint ans = n, num = gcd(v[0], v[1]);\nfor (int i = 2; i &lt; n; i++) num = gcd(num, v[i]);\n// 现在num是所有数字的最大公约数\nint maxnum = ranges::max(v);\nfor (int i = num; i &lt;= max; i += num) ans += (mp.count(i) == 0);\ncout &lt;&lt; ans;\nP3"},"贪心套路/P3":{"slug":"贪心套路/P3","filePath":"贪心套路/P3.md","title":"P3","links":["贪心套路/P4"],"tags":[],"content":"题目1\n给一个整数数组nums 需要找出一个连续子数组\r\n如果对这个子数组进行升序排序 那么整个数组都会变成升序排序\r\n请你找出这个最小的连续子数组\n// 这个空着不写 看下次能不能想起来\n题目2\n给很多个有序数组 返回一个长度最小的区间 [a, b] 使得每一个数组中都有一个数字在这个区间中\n用一个最小堆维护最小值 最大堆维护最大值\n题目3\n组团买票\r\n景区里一共有m个项目，景区的第i个项目有如下两个参数：\r\ngame[i] = { Ki, Bi }，Ki、Bi一定是正数\r\nKi代表折扣系数，Bi代表票价，举个例子 : Ki = 2, Bi = 10\r\n如果只有1个人买票，单张门票的价格为 : Bi - Ki * 1 = 8\r\n所以这1个人游玩该项目要花8元\r\n如果有2个人买票，单张门票的价格为 : Bi - Ki * 2 = 6\r\n所以这2个人游玩该项目要花6 * 2 = 12元\r\n如果有5个人买票，单张门票的价格为 : Bi - Ki * 5 = 0\r\n所以这5个人游玩该项目要花5 * 0 = 0元\r\n如果有更多人买票，都认为花0元(因为让项目倒贴钱实在是太操蛋了)\r\n于是可以认为，如果有x个人买票，单张门票的价格为 : Bi - Ki * x\r\nx个人游玩这个项目的总花费是 : max { x * (Bi - Ki * x), 0 }\r\n单位一共有n个人，每个人最多可以选1个项目来游玩，也可以不选任何项目，由你去按照上面的规则，统一花钱购票\r\n你想知道自己需要准备多少钱，就可以应付所有可能的情况，返回这个最保险的钱数\r\n1 &lt;= M、N、Ki、Bi &lt;= 10^5\n\n其实就是要找出景区公园赚最多钱的情况\n\n如何让公园最赚钱？\r\n我们只需要把人 挨个送到最赚钱的项目去\r\n如何统计这个指标？\r\n假设现在来了a人 每个人要付的钱就是b - k * a\r\n现在又来了一个 每个人要付的钱就变成了 b - k * (a + 1) - k * a\n题目4\n平均值最小累加和\r\n给定数组v 长度为n 需要从中划分出 k 组\r\n返回每组的平均值累加起来的 最小值\n\n思路：\r\n其实就是把前k - 1 个数单独放一组， 剩下的n - k + 1 个大数字求平均值 然后累加\n\n题目5\n执行所有任务的最少初始电量\r\n每一个任务有两个参数，需要耗费的电量 a 、至少多少电量才能开始这个任务 b\r\n返回手机至少需要多少的初始电量，才能执行完所有的任务\r\n现在是m m 需要 &gt;= b 执行完任务之后变成m - a\n\n结论：耗费 - 至少的差值越小 越先进行; 耗费 - 至少的差值越大 越先倒推\n\n题目6\n两个0和1数量相等区间的最大长度\r\n给出一个长度为n的01串，现在请你找到两个区间\r\n使得这两个区间中，1的个数相等，0的个数也相等\r\n这两个区间可以相交，但是不可以完全重叠，即两个区间的左右端点不可以完全一样\r\n现在请你找到两个最长的区间，满足以上要求\r\n返回区间最大长度\n011010 的两个区间 分别是 01101 11010\n\n可能性1 找到区间最左侧 最右侧 的0\n可能性2 找到区间最左侧 最右侧 的1\n两者求最大值即可\n\nP4"},"贪心套路/P4":{"slug":"贪心套路/P4","filePath":"贪心套路/P4.md","title":"P4","links":["贪心套路/P5"],"tags":[],"content":"题目1\n给你一个数组 对于其中的奇数 你可以让他*＝ 2 对于其中的偶数 你可以让他 /= 2 记这个数组最大值与最小值之差为 偏移量 返回偏移量的最小值\n\n思路：\n对于所有的奇数 我们可以先 *＝ 2 让它获得被除的机会 接下来 我们只需要用multiset 维护这个数组 然后不断对最大值除以二 并记录偏移量即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nmultiset&lt;int&gt; mst;\nfor (int i = 0; i &lt; n; i++)\n{\n\tif (v[i] &amp; 1) v[i] *= 2;\n\tmst.insert(v[i]);\n}\n \nint ans = *mst.rbebin() - *mst.begin();\nwhile (*mst.rbegin() % 2 == 0)\n{\n\tauto num = *mst.rbegin();\n\tmst.erase(num);\n\tnum /= 2;\n\tmst.insert(num);\n\tans = min(ans, *mst.rbebin() - *mst.begin());\n}\ncout &lt;&lt; ans;\n题目2\n森林中有很多只兔子 你问了一些兔子”有几只兔子跟你颜色相同？” 兔子们的回答绝对真实 但是你可能只问了一部分兔子 现在你得到了兔子们的回答answer 求森林中至少有多少只兔子\n\n思路：\n对于所有回答一样的兔子，对他们分组 每n + 1 只兔子分为一组，最后乘n + 1 就得到了答案\n\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nwhile (n--)\n{\n\tint num;\n\tcin &gt;&gt; num;\n\tmp[num]++;\n}\n \nint ans = 0;\n \nfor (auto &amp;&amp;[k, v] : mp)\n{\n\t// 每n + 1只分为一组 也就是总数 / n + 1 向上取整\n\tauto a = (v + (k + 1) - 1) / (k + 1);\n\tans += a * (k + 1);\n}\n \ncout &lt;&lt; ans;\n\n总结：\n向上取整的操作通常应用于对某个目标分组，比如\n现在有七十个学生，每辆车最多可以垃50个 请问一共需要用几辆车\n这种时候分组策略就是总数 / 分组依据 然后向上取整\n也就是ans = (a + b - 1) / b\n\n题目3\n给定两个数组nums和target 你可以对nums的任意两个元素作变换（其中一个+= 2 另外一个-= 2 返回你要操作多少次才能使得这两个数组相等 （可以证明一定存在相等策略\n\n思路：这道题的简化背景其实是 给两个数组 可以对其中一个的任意元素增减 返回使得这两个数组元素相等的最小操作次数\n对两个数组都排序，就显而易见的得出答案了\n\n那么对于这一题 我们需要注意到，每次增加减少2 不会改变他们的奇偶性——所以我们应该对奇偶性分组\n分组之后 我们直接记录变换次数然后除以二即可\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n), t(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; t[i];\n \nauto change = [&amp;](vector&lt;int&gt; &amp;v) -&gt; void\n{\n\tvector&lt;int&gt; odd, even;\n\tfor (int i = 0; i &lt; n; i++)\n\t{\n\t\tif (v[i] &amp; 1)\n\t\t{\n\t\t\todd.emplace_back(v[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\teven.emplace_back(v[i]);\n\t\t}\n\t}\n\tranges::sort(odd);\n\tranges::sort(even);\n\todd.insert(odd.end(), all(even));\n\tv = odd;\n};\n \nchange(v);\nchange(t);\n \nint ans = 0;\nfor (int i = 0; i &lt; n; i++) ans += abs(v[i] - t[i]) / 2;\ncout &lt;&lt; ans / 2;\n\n总结：\n下次遇到增减2的时候 要注意这不会改变奇偶性\n\n题目4\n部门要挑选两个员工去参加竞赛，每一个员工有a b 两个指标 部门会把两个员工的两个指标分别取平均值得到A B 求min(A,B)的最大值\n\n思路：\nn^2 的思路是容易想到的，但是我们不允许这样的复杂度 在此基础上 我们应当保证尽可能取消内层循环\n我们应当使用abs(a_1 - b_1) &lt; abs(a_2 - b_2) 来sort 这样一来 我们有：\n对于任意 v[i] (abs(a - b) == k) 它前面的所有a和b一定满足abs(a - b) ⇐ k 也就是说 相加之后不会改变min所在的位置\n因此 我们直接设置两个变量记录最大值最小值即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].first &gt;&gt; v[i].second;\nranges::sort(v, [](auto a, auto b) { \nreturn abs(a.first - a.second &lt; b.first - b.second;) });\n \nint max1 = a.first, max2 = a.second, ans = 0;\nfor (int i = 1; i &lt; n; i++)\n{\n\tans = min(v[i].first + max1, v[i].second + max2);\n\tmax1 = max(max1, v[i].first);\n\tmax2 = max(max2, v[i].second);\n}\ncout &lt;&lt; ans * 0.1 / 2;\n题目5\n题目6\nP5"},"贪心套路/P5":{"slug":"贪心套路/P5","filePath":"贪心套路/P5.md","title":"P5","links":[],"tags":[],"content":"题目1\n跳跃游戏ii\r\n给你一个数组v v[i] 表示从i开始最多能跳几格，求到达n - 1下标的最少次数\n\n思路：\r\n我们设置一个变量right 来维护当前跳跃的范围，endd来维护当前可以到达的最大格子，ans 来记录答案\n\n操作过程如下：\n\n每走到一个新的格子 判断当前格子在不在跳跃可达的范围内，如果不行的话 说明需要一次额外的跳跃，此时ans++, right = endd\n每走到一个新的格子 更新end = max(end, i + v[i])\r\n代码：\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\n \nint ans = 0, right = 0, endd = 0;\nfor (int i = 0 ; i &lt; n; i++)\n{\n\tendd = max(endd, i + v[i]);\n\tif (i == right)\n\t{\n\t\tif (i == endd)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tright = endd;\n\t}\n}\n题目2\n浇水问题：\r\n给你一个数组v 其中 v[i] 表示第i个地方有一个水管 浇水可以覆盖[i - v[i], i + v[i]] 求使得整个花园都能浇到水的最少水管数目 如果无法完全覆盖，返回－1\n\n思路：\r\n我们先创建一个新的数组right 其中right[i] 表示第i个位置开始 能到达的范围\r\n例如：v[3] = 2 那么v[3] 可以覆盖[1, 5] 的范围 那么 right[1] = max(right[1], 5)\n\n\n随后，这个问题就跟题目一一模一样了\n\n代码：\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt;v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nvector&lt;int&gt; right(n);\nfor (int i = 0; i &lt; n; i++) right[i - v[i]] = max(right[i - v[i]], i + v[i]);\n \nint ans = 0, curright = 0, nextright = 0;\nfor (int i = 0; i &lt; n; i++)\n{\n\tnextright = max(nextright, right[i]);\n\tif (i == curright)\n\t{\n\t\tif (i == nextright)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tcurright = nextright;\n\t}\n}\ncout &lt;&lt; ans;\n题目3\n题目4\n题目5\n题目6"},"贪心套路/贪心":{"slug":"贪心套路/贪心","filePath":"贪心套路/贪心.md","title":"贪心","links":[],"tags":[],"content":"贪心算法通常具有以下几个重要性质：\n1. 贪心选择性质\n\n局部最优：每一步都做出当前看起来最优的选择\n不可撤销：一旦做出选择，不会回溯修改\n子问题独立：当前决策不依赖于后续决策 1\n\n示例：\n// 常见的贪心模式\nwhile(有选择) {\n    choice = 选择当前最优解;\n    result = 将选择添加到结果中;\n    problem = 在剩余问题上继续;\n}\n2. 最优子结构性质\n\n问题的最优解包含子问题的最优解\n子问题之间相互独立，不存在交叉影响\n\n3. 特征识别\n贪心问题通常具有以下特征：\n\n排序帮助：\n\n// 很多贪心问题第一步是排序\nsort(arr.begin(), arr.end()); // 按某种规则排序\n\n局部决策：\n\nfor(int i = 0; i &lt; n; i++) {\n    // 每一步只考虑当前最优\n    if(isGood(current)) {\n        ans = max(ans, current);\n    }\n}\n\n不需要回溯：\n\n// 贪心通常是单向遍历\n// 不需要考虑之前的决策\nvisited[current] = true; // 标记已访问\n// 不会再修改visited[current]\n4. 正确性证明方法\n贪心算法的正确性证明通常包含：\n\n归纳证明：\n\n\n证明局部最优能导致全局最优\n证明不存在更优解\n\n\n反证法：\n\n\n假设存在更优解\n证明可以通过贪心策略得到相同或更优结果\n\n\n交换论证：\n\n\n证明任何非贪心策略都可以通过交换变成贪心策略\n且交换不会使结果变差\n\n5. 常见贪心策略\n\n选择排序：\n\n// 按照某种规则排序后遍历\nsort(intervals.begin(), intervals.end());\nfor(auto interval : intervals) {\n    // 处理每个区间\n}\n\n优先队列：\n\npriority_queue&lt;int&gt; pq;\n// 维护当前最优选择\nwhile(!pq.empty()) {\n    int top = pq.top();\n    pq.pop();\n    // 处理最优选择\n}\n\n双指针：\n\nint left = 0, right = n-1;\nwhile(left &lt; right) {\n    // 从两端向中间处理\n    // 每次选择最优的移动方向\n}\n6. 反例识别\n不适合用贪心的情况：\n\n需要考虑全局最优\n当前决策依赖于后续决策\n存在多个相互影响的约束条件\n\n记住：贪心算法的关键是证明局部最优能导致全局最优！"},"题解/cf/2116/11":{"slug":"题解/cf/2116/11","filePath":"题解/cf/2116/11.md","title":"11","links":[],"tags":[],"content":"(0404)_{10} = (110010100)_{2} = 0100"},"题解/cf/2116/A":{"slug":"题解/cf/2116/A","filePath":"题解/cf/2116/A.md","title":"A","links":[],"tags":[],"content":"把其中一个打死就行\nauto r1 = max(a, c), r2 = max(b + d);\ncout &lt;&lt; (r1 &gt;= r2 ? &quot;Gellyfish&quot; : &quot;Flower&quot;);"},"题解/cf/2116/B":{"slug":"题解/cf/2116/B","filePath":"题解/cf/2116/B.md","title":"B","links":[],"tags":[],"content":"注意到 2^n = 2^{n - 1} + 2^{n - 1} 所以对于任意一个 i 我们统计出 [0, i]上最大的a_j和b_k 那么肯定有a_j &gt; a_{i - j} 和 b_k &gt; b_{i - k} 所以可以认为所求值是由max(a_j, b_k) 决定的\r\n即：\nint j = 0, k = 0;\nfor (int i = 0; i &lt; n; i++)\n{\n\tif (a[i] &gt; a[j]) j = i;\n\tif (b[i] &gt; b[k]) k = i;\n \n\tif (a[j] &gt; b[k]) cout &lt;&lt; ksm(2, a[j] + b[i - j]);\n\telse if (a[j] == b[k]) cout &lt;&lt; ksm(2, a[j] + max(b[i - j], a[i - k]));\n\telse cout &lt;&lt; ksm(2, b[k] + a[i - k]);\n\tcout &lt;&lt; &#039; &#039;;\n}"}}