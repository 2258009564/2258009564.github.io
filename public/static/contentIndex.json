{"BEGINNING":{"slug":"BEGINNING","filePath":"BEGINNING.md","title":"BEGINNING","links":["对暴搜的研究/学习笔记"],"tags":["begin"],"content":"heading 1\nheading 2\nheading 3\nheading 4\nheading 5\nheading 6\nbold\nitalic\n\nbullet item 1\nbullet item 2\n\nnested item\n\n\nbullet item 1\n\n\nno.1\nno.2\n\n学习笔记\nlink text\nHighlight Text\n～～ dont know why i cant use strikethrough ～～\n\n checkbox\n put ‘x’\n\n\n\n                  \n                  Node\n                  \n                \n\n\n1\n\n\n\n\n%这是一个注释%\n\n以下是 latex 教程\n\n+\n-\n\\times\n\\div\n=\n\\neq \n(a + b)\n\\{a + b\\}\n[a + b]\n\\frac{a}{b}\n\na^2\nx_1\n\\sqrt{a}\n\\alpha \\times \\beta = \\gamma\n\\sum_{i = 1}^{n} i\n\\Sigma_{i = 1}^{n} i\n\\Pi_{i = 1}^{n} i"},"Quick-LaTeX-readme":{"slug":"Quick-LaTeX-readme","filePath":"Quick LaTeX readme.md","title":"Quick LaTeX readme","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShorthandStringShorthandStringShorthandStringsq\\sqrt{}bb\\mathbb{}bf\\mathbf{}te\\text{}inf\\inftybi\\binom{#cursor}{#tab}cd\\cdotqu\\quadti\\timesal\\alphabe\\betaga\\gammaGa\\Gammade\\deltaDe\\Deltaep\\epsilonze\\zetaet\\etath\\thetaTh\\Thetaio\\iotaka\\kappala\\lambdaLa\\Lambdamu\\munu\\nuxi\\xiXi\\Xipi\\piPi\\Pirh\\rhosi\\sigmaSi\\Sigmata\\tauup\\upsilonUp\\Upsilonph\\phiPh\\Phich\\chips\\psiPs\\Psiom\\omegaOm\\Omega"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"Welcome to my GitHub page!\nhere u will find many of my crazy ideas and rubbish-like thoughts. You might find some gems, you might find some… well, let’s just call them ‘experimental features’ that never quite made it past the concept stage. But hey, it’s all part of the learning (and coding) journey!\nSo, pull up a chair, grab a coffee, and explore at your own risk! Who knows, you might even find something that sparks your own next big (or wonderfully weird) idea.\nAnyway, it’s late, my brain’s officially fried from all the ‘idea-generating,’ and now I just gotta catch some Z’s. Hope you found something interesting here – or at least had a chuckle!"},"什么大创/大创中期答辩演讲":{"slug":"什么大创/大创中期答辩演讲","filePath":"什么大创/大创中期答辩演讲.md","title":"大创中期答辩演讲","links":[],"tags":[],"content":"各位评委、老师，大家好。\n我叫梁震宇 ，是“理智先锋娱乐互动工作室”的负责人 。今天，我将向大家展示一个将中国古代科学智慧与现代游戏体验深度融合的创业项目。\n\n(幻灯片切换：项目背景与团队实力)\n我们想解决一个问题：如何让今天的年轻人，尤其是学生，真正爱上科学，同时深刻感受我们自己文化的魅力？传统课本的知识是静态的，而历史题材的游戏又常常忽略了其中蕴含的科学光芒。\n我们的答案，是创造一种全新的互动体验。为此，我们立足于北宋科学家沈括的科学巨著——《梦溪笔谈》 。我们不仅仅是讲述历史，而是邀请玩家化身时空旅者，亲手去“复现”那些沉睡在古籍中的科学实验 。\n我们的核心价值，就是将古风叙事与物理知识结合 ，通过角色扮演和游戏化的方式 ，极大地降低科学的学习门槛 ，最终培养玩家的文化认同感与科学精神 。\n支撑这个愿景的，是一个充满实战经验的团队。我们的核心成员，曾荣获CCPC程序设计竞赛东北地区铜牌、中国大学生计算机设计大赛国家级三等奖等多项荣誉 。我们的指导老师梅险老师，在计算机博弈与游戏设计领域拥有深厚的项目经验和多项国家级荣誉 。我们不仅有热情，更有将想法变为现实的技术实力。\n\n(幻灯片切换：游戏核心设计与特色)\n接下来，我为大家介绍游戏的核心设计。\n我们的游戏设计了五章史诗级的冒险 。每一章都围绕一个核心的科学问题展开，比如第一章的“小孔成像”和第二章的“光的反射与折射” 。这不只是简单的知识灌输，我们的教育目标巧妙地融入了玩法之中 。例如，玩家需要亲手调整装置，才能观察到“光沿直线传播”的现象 。同时，游戏还融合了物理、历史等多学科知识 ，比如在“汴京的挑战”一章中，玩家需要运用流体力学知识来解决水患问题 。\n为了区别于市场上的其他产品，我们设计了三大差异化机制： 第一，科学实验系统 。玩家可以自主设计实验方案，系统会根据操作的逻辑性进行评分，真正深化对科学原理的理解 。\n第二，历史沉浸设计 。游戏中的许多关键对话和线索，都直接引自《梦溪笔谈》原著，解锁隐藏剧情，增强文化沉浸感 。\n第三，跨时空叙事 。玩家在古都汴京做出的决策，会影响到他在现代博物馆中看到的展览，构建一种奇妙的时空联动体验 。\n\n(幻灯片切换：开发路线与未来规划)\n目前，我们正严格按照开发路线图推进。从2024年底的市场调研，到今年上半年的游戏制作，我们已经完成了核心玩法的开发 。接下来，我们将在8到10月进行发行运营 。\n我们的发行策略非常清晰： 首先，通过众筹模式启动，比如资助10元解锁隐藏章节，50元获得一枚精美的宋代科学仪器徽章，以此凝聚第一批核心用户 。\n其次，我们将在Steam平台进行试发行，以“大学生创新创业项目”的身份，用极具吸引力的1元定价，快速获取国区玩家的宝贵反馈 。\n同时，我们会在B站、抖音等多平台进行内容推广，通过开发日志、幕后花絮等形式，与玩家建立紧密的联系 。\n\n(幻灯片切换：初步成果与用户反馈)\n目前，我们的努力已经初见成效。\n这是我们制作的游戏官网和部分游戏截图 。大家可以看到，从关卡设计到动态效果，我们都力求细节。比如，在“磨针成指南针”的环节，我们制作了专门的动画效果，给予玩家“亲手操作”的沉浸感 。在探索任务中，也有实时的声音和文字提示，引导玩家顺利通关 。\n我们搭建了工作室的基本架构，分为市场、技术和美术策划三大部门，由各专业同学负责，高效协作 。\n我们诚挚地邀请各位访问我们的官网，亲身体验游戏的试玩版 。\n总结而言，“理智先锋”正在做一件非常有意义的事：我们不只是在开发一款游戏，更是在打造一个可以玩的“数字文化遗产”，一座连接过去与未来的桥梁。我们希望通过这部作品，让科学和传统文化，变得触手可及、趣味盎然。\n我的汇报到此结束，谢谢大家。"},"什么大创/大创答辩":{"slug":"什么大创/大创答辩","filePath":"什么大创/大创答辩.md","title":"大创答辩","links":[],"tags":[],"content":"第一章 项目目的与团队能力验证\n1. 项目核心价值：寓教于乐 × 古风传承\n\n\n文化赋能教育：\n\n科学史的活化：以《梦溪笔谈》为蓝本，将沈括的科学探索转化为可交互体验，让玩家“亲手验证”古代科学原理（如磁针偏角实验、小孔成像）。\n古风叙事魅力：\n\n美术风格：宋代水墨画风+工笔场景（汴京街市、梦溪园建筑考据历史文献）。\nNPC对话：严格引用《梦溪笔谈》原文（如“方家以磁石磨针锋，则能指南”）。\n\n\n跨学科融合：物理知识（光学/磁学/流体力学）与历史人文结合，培养玩家科学思维与文化认同。\n\n\n\n差异化竞争力：\n\n填补市场空白：当前Steam平台缺乏“中国古代科学+角色扮演”题材，同类游戏《Kerbal太空计划》侧重现代航天，本作专注本土化科学启蒙。\n轻量化学习门槛：通过游戏机制降低科学理解难度（如“光影之谜”章节用拖拽镜面直观演示反射定律）。\n\n\n\n2. 团队能力验证\n\n技术实力：\n\n成员累计获省级及以上奖项6项，包括：\n\nACM国际大学生程序设计竞赛东北三省赛区铜奖（技术能力证明）\n全国大学生电子商务竞赛二等奖（创新与商业思维）\n高校数字创意教学技能大赛优秀奖（跨学科协作能力）\n\n\n\n\n开发经验：\n\n熟练使用RPG Maker VX引擎开发，自主开发物理模拟插件（支持实时光影追踪、水流动力学）。\n内测版本已吸引200+玩家体验，平均单次游戏时长43分钟，核心章节通关率达68%。\n\n\n\n\n第二章 项目研究内容（游戏核心设计）\n1. 五章史诗冒险：科学探索之旅\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n章节核心科学问题玩法设计教育目标时空漩涡小孔成像原理在图书馆场景中通过调整孔洞形状、光源位置，观察成像规律理解光的直线传播特性光影之谜光的反射与折射协助沈括改良“覆盆镜”实验，需通过镜面反射点燃蜡烛掌握反射定律与实际应用汴京的挑战流体力学与水利工程设计分水堰模型，通过调整坝体角度解决洪水泛滥问题运用伯努利原理分析水流压力梦溪园的奇遇地磁场与磁针偏角在实验室中重复沈括磁针实验，记录不同材料对磁偏角的影响理解地磁南极与地理北极差异回归与传承科学方法论总结选择现代实验设备复现古代实验，对比古今科技差异培养批判性思维与历史视角\n2. 差异化机制设计\n\n科学实验系统：所有章节均包含可交互实验台，玩家需自主设计实验步骤（如“先固定光源，再移动挡板”），系统根据操作逻辑性评分。\n历史沉浸设计：\n\n穿越回现代后，玩家需在图书馆数字档案中查找《梦溪笔谈》原文，解锁隐藏剧情。\nNPC对话严格参照《梦溪笔谈》原文记载（如“方家以磁石磨针锋，则能指南”）。\n\n\n跨时空叙事：汴京章节决策影响现代图书馆展品陈列（如成功解决水患可解锁“北宋水利模型”数字展柜）。\n\n\n第三章 项目研究路线与进度\n1. 开发路线图\n\n第一阶段（已完成）：\n\n完成5个章节架构设计，2章可交互原型开发（时空漩涡、光影之谜）。\n物理模拟插件基础功能实现（小孔成像、磁针偏角实验）。\n\n\n第二阶段（进行中）：\n\n开发汴京水利工程章节，优化伯努利原理模拟算法。\n制作Steam商店页原型，启动内测用户招募。\n\n\n第三阶段（计划中）：\n\n完成全章节联调，制作宣传视频与开发者日志。\n对接中小学科学课程，开发配套教学资源包。\n\n\n\n2. 未来规划\n\nSteam平台发行：\n\n定价38元标准版，配套教学版定制内容（含教师手册、课堂任务包）。\n计划2024年Q3上线，同步启动校园推广。\n\n\n资金筹集方案：\n\n二维码众筹：阶梯回报（10元档解锁隐藏章节，50元档赠宋代科学仪器徽章）。\n虚拟资助体系：开发“学徒等级系统”，资助者可获游戏内专属称号（如“沈括首席弟子”）。\n\n\n\n\n第四章 项目初步成果展示\n1. 团队荣誉与奖项\n\n技术类：\n\nACM国际大学生程序设计竞赛东北三省赛区铜奖\n\n\n创新类：\n\n全国大学生电子商务竞赛二等奖\n\n\n设计类：\n\n高校数字创意教学技能大赛优秀奖\n\n\n\n2. 游戏近况与验证\n\n技术成果：\n\n自主研发物理引擎：支持实时光影追踪、磁针偏角动态计算。\n可交互实验台原型：玩家操作记录与逻辑评分系统。\n\n\n用户反馈：\n\n内测版本吸引200+玩家体验，平均单次游戏时长43分钟，核心章节通关率68%。\n用户评论：“通过游戏真正理解了小孔成像原理”（B站UP主实况视频弹幕）。\n\n\n\n3. 游戏介绍网页\n\n网址：Science Student’s Fantasy Journey\n核心内容：\n\n五章冒险故事线完整介绍\n游戏特色与美术风格展示\n立即下载试玩入口\n\n\n\n\n可视化建议\n\n必配素材：\n\n游戏主界面截图（宋代山水画风+章节选择界面）。\n「光影之谜」章节实验流程GIF（拖拽镜面点燃蜡烛）。\n沈括角色设定图（宋代文人服饰+手持《梦溪笔谈》手卷）。\n\n\n增强说服力：\n\n对比图：展示“传统教材讲解” vs “游戏内实验流程”的知识传递效率。\n文化考据资料：汴京水利工程设计参考《营造法式》的文献截图。\n\n\n\n"},"什么神经网络/python":{"slug":"什么神经网络/python","filePath":"什么神经网络/python.md","title":"python","links":[],"tags":[],"content":"os 模块的作用：\nos 是 Python 的标准库模块，用于与操作系统交互，核心功能包括：\n\n路径操作：\n\nos.path.join(path1, path2)：将路径拼接成系统兼容格式（自动处理 / 或 \\）。\n例如：os.path.join(&quot;data&quot;, &quot;train&quot;) → &quot;data/train&quot;（Linux）或 &quot;data\\\\train&quot;（Windows）。\n\n\n目录遍历：\n\nos.listdir(path)：列出指定路径下的所有文件和子目录名称（返回字符串列表）。\n\n\n文件/目录管理：\n\n创建、删除、重命名文件/目录（如 os.makedirs()、os.remove()）。\n\n\n环境信息：\n\n获取操作系统类型、环境变量等（如 os.name, os.getenv()）。\n\n\n\n\nImage 模块的作用（来自 PIL 库）：\nImage 是 Python Imaging Library (PIL) 的核心模块，现由 Pillow 维护，用于图像处理。核心功能包括：\n\n图像加载：\n\nImage.open(path)：从文件加载图像，返回一个 PIL.Image.Image 对象。\n\n\n图像操作：\n\n裁剪、旋转、缩放、滤波、颜色转换等（如 img.resize(), img.convert()）。\n\n\n图像保存：\n\n将图像保存为不同格式（如 img.save(&quot;output.jpg&quot;)）。\n\n\n图像数据访问：\n\n获取像素数据（如 img.getdata()）、图像尺寸（如 img.size）等。\n\n\n\n\nimg 的数据类型：\nimg = Image.open(img_item_path)\n\n类型：PIL.Image.Image 对象。\n本质：这是一个封装了图像像素数据的类实例，包含以下关键属性：\n\nimg.mode：图像模式（如 &#039;RGB&#039;, &#039;L&#039; 表示灰度图）。\nimg.size：图像尺寸（如 (width, height)）。\nimg.format：图像格式（如 &#039;JPEG&#039;, &#039;PNG&#039;）。\n\n\n内存中的数据：图像像素值以二进制形式存储在对象内部，需通过 np.array(img) 或 torchvision.transforms.ToTensor() 转换为数值数组（如 NumPy 数组或 PyTorch 张量）才能用于深度学习模型。\n\n\n代码流程解析：\ndef __getitem__(self, idx):\n    img_name: str = self.img_path[idx]            # 获取第 idx 个文件名（str）\n    img_item_path: str = os.path.join(self.path, img_name)  # 拼接完整路径（str）\n    img = Image.open(img_item_path)              # 加载图像，得到 PIL.Image.Image 对象\n\nimg_name：str 类型，表示单个图像文件名（如 &quot;cat.jpg&quot;）。\nimg_item_path：str 类型，表示图像文件的完整路径（如 &quot;./data/train/cat.jpg&quot;）。\nimg：PIL.Image.Image 类型，表示加载后的图像对象。\n\n\n后续处理建议（深度学习场景）：\nPIL.Image.Image 对象不能直接输入神经网络，需进一步转换：\n\n转换为 NumPy 数组：\nimport numpy as np\nimg_array = np.array(img)  # 形状为 (height, width, channels)，值范围 [0, 255]\n\n转换为 PyTorch 张量：\nfrom torchvision import transforms\ntransform = transforms.ToTensor()\nimg_tensor = transform(img)  # 形状为 (channels, height, width)，值范围 [0.0, 1.0]\n\n标准化（常见预处理）：\nnormalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\nimg_normalized = normalize(img_tensor)  # 标准化后的张量\n\n\n\n总结：\n\nos 模块：处理文件系统路径和目录遍历，确保代码跨平台兼容。\nImage 模块：加载和处理图像，返回 PIL.Image.Image 对象。\nimg 的类型：PIL.Image.Image，需进一步转换为数值数组或张量才能用于深度学习模型。\n"},"什么神经网络/神经网络与深度学习笔记":{"slug":"什么神经网络/神经网络与深度学习笔记","filePath":"什么神经网络/神经网络与深度学习笔记.md","title":"神经网络与深度学习笔记","links":[],"tags":[],"content":"神经网络\n如同大脑需要神经元配合一样，深度学习也需要相应的网络。一个典型的神经网络包含一层层的节点，每一层节点的输入都是前一层或多层的输出（有点像动态规划）。现在的神经网络可以达到几十层甚至上千层，我们称之为深度神经网络。\n认识这个世界\n人之所以能够区分生活中常见的事物，是因为我们感知的信号传递给了大脑；大脑将复杂的信号处理分类，最后得到正确的结果。\n计算机也是如此。在学习过程中，它将大量的不同物体之间的异同点变成神经网络的参数。当你给计算机一张动物图片时，它就能通过对图片的分析，告诉你它是不是小猫。\n深度学习就这样通过构建多层的人工神经网络来模拟人类大脑的信息处理和学习机制，从海量的数据中学习到丰富的规律和知识，从而实现对大量数据的高效处理和分析，解决复杂任务。\n如今，我们可以使用现有的工具快速构建这样的人工神经网络：\n\n\nPython: 一种编程语言，以其简洁、强大、易于学习而著称。\n\n\nPyTorch: 专为Python设计的用于构建和训练深度神经网络的工具包。作为一款流行的深度学习框架，PyTorch以其简洁灵活的特性，让我们能够轻松构建、训练和部署深度学习模型。\n\n\n计算机如何识别你书写的数字？\n让我们看看PyTorch的解题思路。解决这个问题总共需要5步：准备数据、定义模型、训练模型、评估模型、做出预测。\n1. 准备数据\n当我们学习时遇到一道做不出来的题该怎么办？我们会去求助老师，会和同学讨论，或者是寻找学习资料的帮助。当计算机遇到复杂问题时也是这样，不过它用的学习资料都是特定的数据。深度学习框架PyTorch提供了日常练习所需的基础数据集，我们可以从PyTorch里导入手写数字分类数据集，并使用Python来进行可视化展示。\n就算有这样的数据，计算机又是怎么看出我写的数字的呢？其实很简单，我们看到的图和计算机看到的图是不一样的。计算机将图片进行分割，根据图片的颜色信息将其转化成各种通道的数据信息并保存下来，这样计算机就能很好地记住这张图了。\n2. 定义模型\n在正式开始前，我们需要几个概念：卷积层、池化层、全连接层。\n\n\n卷积层: 是计算机认识一张图片最基础的步骤，它将一张图像变成一系列0∼1之间的数据矩阵。\n\n\n池化层: 可以理解为把原来很大的图像矩阵压缩变成一张更小、更容易计算的图像矩阵。\n\n\n全连接层: 计算机还要把这张更小的图像展开成一段数据（过程大概有点类似中序遍历算术表达式？）。这个过程被称为全连接层。\n\n\n而这段处理完的数据就是这张图片的“身份证”了。计算机就用这样的方式认识了这张照片，神经网络的模型也是这样产生的。\n下面是一个这些概念的简要总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念功能作用卷积层提取图像特征，将图像转化为数据矩阵。识别图像中的边缘、纹理等基本特征。池化层压缩图像矩阵，减少数据量和计算复杂度。保留重要特征，同时减少过拟合的风险。全连接层将处理后的图像数据展开成一维向量，进行高级特征组合和分类。整合所有特征，最终输出分类结果或预测值。\n3. 训练模型\n在定义好模型之后就可以开始训练模型了。训练模型的过程实际上就是将训练数据输入模型，计算损失并调整更新模型参数，这样重复进行多个周期，直到模型很好地学到了训练数据里的特征。\n简单来说，训练模型就是我们把大量的已经标定的手写数字图片作为数据告诉计算机，在不断学习复习的过程中，计算机的考试成绩越来越好的过程。\n在这个过程中，我们需要定义损失函数和优化器：\n\n\n损失函数: 用于衡量模型预测的准确性。\n\n\n优化器: 用于调整模型的参数。\n\n\n在这个例子中，我们使用交叉熵损失作为损失函数；使用随机梯度下降作为优化器。\n下面是关于损失函数和优化器的总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念作用示例（手写数字识别）损失函数衡量模型预测结果与真实值之间的差异。交叉熵损失优化器根据损失函数的结果，调整模型参数以最小化损失。随机梯度下降（SGD）\n4. 评估模型 / 预测\n最后我们当然要给计算机检查一下卷子，看看它学得怎么样了。我们随便写下计算机没见过的某个数字，让它用训练好的模型判断一下，看看是不是和我们写下的数字一致。\nPyTorch五步解题法回顾\nPyTorch的解题思路可以概括为以下五步：\n\n\n准备数据\n\n\n定义模型\n\n\n训练模型\n\n\n评估模型\n\n\n做出预测\n\n\n神经网络架构基础\n以一个典型的神经网络为例，其基本构成包括：\n\n\n输入层（Inputs）：接收原始数据。\n\n\n权重（Weights）：每个输入数据与不同的权重相乘。\n\n\n偏差（Bias）：与加权后的输入数据相加。\n\n\n激活函数（Activation Function）：对加权和与偏差的结果进行非线性变换，得到输出。\n\n\n输出层（Output）：将结果传递给下一层神经网络，直至损失函数收敛到最小，得到最终结果。\n\n\n卷积神经网络（CNN）简介与LeNet-5示例\n卷积神经网络是专门为图像输入设计的网络。以经典的LeNet-5为例，它于20世纪90年代推出，是早期成功的CNN架构之一，专为手写数字识别设计，奠定了后续CNN发展的基础。\nLeNet-5包含以下核心要素：\n\n\n卷积层（Convolutional Layer）：用于提取图像特征，生成特征图。\n\n\n池化层（Pooling Layer）：对特征图进行降维，提取最突出的元素。\n\n\n全连接层（Fully Connected Layer）：在特征提取后进行分类预测。\n\n\nLeNet-5图像处理过程示例：\n\n\n原始输入：一张32x32像素的手写数字图像。\n\n\n第一卷积层处理：图像转换为6个28x28像素的特征图。\n\n\n第一池化层作用：特征图降维至6个14x14像素的图像。\n\n\n第二卷积层处理：数据进一步变为16个10x10像素的特征图。\n\n\n第二池化层作用：特征图尺寸减小为16个5x5像素的图像。\n\n\n全连接层处理：网络最终输出一个10维向量，每一维代表一个数字类别的预测概率。 通过这一系列层层深入的处理，LeNet-5能够有效地识别和分类手写数字图像，随着数据量的减少，特征的精确度逐渐增高。\n\n\nPyTorch实操：数据准备\n实操的第一步是准备数据，这包括数据下载、数据格式转换和数据集划分。\n1. 数据下载：MNIST数据集\n手写数字分类是流行的图像分类任务。MNIST数据集包含了6万个用于训练的手写数字样本和1万个用于测试的样本。每个样本都是一个28x28像素的灰度图像，表示0-9的单一数字。该数据集经过预处理，数字位于图像中心，便于研究人员专注于模型构建。\nPyTorch通过torchvision API提供了直接下载和加载MNIST数据集的便捷功能。\n2. 数据格式转换：PIL图像到PyTorch Tensor\n图像数据通常以PIL图像格式（像素数组）存在。为了让计算机程序更容易理解和处理，我们需要将其转换为PyTorch Tensor格式。ToTensor工具可以完成这项工作，它不仅转换格式，还会将每个像素的亮度值（0-255整数）归一化到0-1之间的浮点数。其中，0表示黑色，1表示白色，0到1之间的值表示不同程度的灰色。\n3. 数据集划分：使用Batch和DataLoader\n为了解决每次遍历整个数据集可能导致的效率低下和内存不足问题，深度学习中通常将数据划分为更小的“批次”（batch）。一个batch可以理解为总数据集中的一小部分子数据集。\n这种做法的优势在于：\n\n\n效率提升：模型可以更快地进行小幅度的调整，而不是等待长时间进行一次大的调整。\n\n\n内存优化：避免一次性加载所有数据导致的内存溢出。\n\n\nPyTorch提供了DataLoader工具，可以方便地实现数据集的批次划分和加载功能。通过枚举方式不断进行训练，实现高效的模型优化。\n可视化训练数据示例\n我们使用的数据集是一个形状为Height x Width的二维矩阵（Height和Width都是28）。这个二维矩阵的每个元素都是一个介于0到1之间的浮点数，表示像素值的归一化强度。通过Python循环，可以随机抽样并展示训练集中的25个数据可视化图案。"},"关于":{"slug":"关于","filePath":"关于.md","title":"关于","links":[],"tags":[],"content":"一个学生，现阶段最喜欢做的事是躺着。"},"对暴搜的研究/ACW2024/二分/1227":{"slug":"对暴搜的研究/ACW2024/二分/1227","filePath":"对暴搜的研究/ACW2024/二分/1227.md","title":"1227","links":[],"tags":[],"content":"void solve()\n{\n\tint n, k;\n\tcin &gt;&gt; n &gt;&gt; k;\n\tint maxnum = 0;\n\tvector&lt;int&gt; h(n), k = h;\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; h[i] &gt;&gt; k[i];\n\t\tmaxnum = max({maxnum, h[i], k[i]});\n\t}\n \n\tint l = 1, r = maxnum, m, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tm = l + (r - l) / 2;\n\t\tauto check = [&amp;]()\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\t{\n\t\t\t\tans += (h[i] / m) * (k[i] / m);\n\t\t\t}\n\t\t\treturn ans &gt;= k;\n\t\t};\n\t\tif (check()) l = (ans = mid) + 1;\n\t\telse r = m - 1;\n\t}\n\tcout &lt;&lt; ans;\n}"},"对暴搜的研究/ACW2024/二分/503":{"slug":"对暴搜的研究/ACW2024/二分/503","filePath":"对暴搜的研究/ACW2024/二分/503.md","title":"503","links":[],"tags":[],"content":"void solve()\n{\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tvector&lt;int&gt; v(n + 2);\n\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; \n\tfor (int i = n; i &gt;= 1; i--) v[i] -= v[i - 1];\n \n\tstruct datas\n\t{\n\t\tint d, s, t;\n\t};\n\tvector&lt;datas&gt; k(m + 1);\n\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; k[i].d &gt;&gt; k[i].s &gt;&gt; k[i].t;\n \n\tint l = 1, r = m, mid, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2;\n\t\tauto check = [&amp;]() -&gt; bool\n\t\t{\n\t\t\tauto b = v;\n\t\t\tfor (int i = 1; i &lt;= mid; i++)\n\t\t\t{\n\t\t\t\tb[v[i].s] -= v[i].d;\n\t\t\t\tb[v[i].t + 1] += v[i].d;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 1; i &lt;= m; i++)\n\t\t\t{\n\t\t\t\tans += b[i];\n\t\t\t\tif (b[i] &lt; 0) return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tif (check()) r = (ans = mid) - 1;\n\t\telse l = mid + 1; \n\t}\n\tcout &lt;&lt; ans;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n随着订单增加，每天可用教室的数量一定单调下降\r\n我们可以二分求出第一天出现负值的订单编号\r\n每个订单 我们会选择 [L, R] 全部减去 d\r\n可以用差分来加速处理过程\n\n\n"},"对暴搜的研究/ACW2024/二分/5407":{"slug":"对暴搜的研究/ACW2024/二分/5407","filePath":"对暴搜的研究/ACW2024/二分/5407.md","title":"5407","links":[],"tags":[],"content":"void solve()\n{\n\tauto check = [&amp;]() -&gt; bool\n\t{\n\t\t\n\t\n\t};\n}"},"对暴搜的研究/ACW2024/前缀和/562":{"slug":"对暴搜的研究/ACW2024/前缀和/562","filePath":"对暴搜的研究/ACW2024/前缀和/562.md","title":"562","links":[],"tags":[],"content":"void solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tstring s;\n\tcin &gt;&gt; s;\n\t\n \n}"},"对暴搜的研究/判断整除-数位法":{"slug":"对暴搜的研究/判断整除-数位法","filePath":"对暴搜的研究/判断整除 数位法.md","title":"判断整除 数位法","links":[],"tags":[],"content":"对于所有正整数\n1都是因子\n数位和是三的倍数 那么3就是因子\n末尾是5或者0 5就是因子\n对于7 一个n位数(n &gt;= 6) 有abbbccc → a （三个连续的b可以和三个连续的c约掉) 判断a是否可以整除7即可\n数位和是9的倍数 那么9就是因子"},"对暴搜的研究/学习笔记":{"slug":"对暴搜的研究/学习笔记","filePath":"对暴搜的研究/学习笔记.md","title":"学习笔记","links":[],"tags":[],"content":"好用的小操作\n求数位之和\nint dig(int x)\n{ \n    return (x + 8) % 9 + 1; \n    // 输入123 返回6\n} \n原理：\n任意一个数字 x 可以写成它的各位数字的加权和，形式如下：\nx = a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0\n其中 a_k, a_(k-1), ..., a_0 是 x 的各个数位的数字。\n关键性质：\n我们知道，对于任何整数 n，有以下等式成立：\n10 ≡ 1 (mod 9)\n这意味着，10 对 9 取模的余数是 1。由此可以推出：\n10^k ≡ 1^k = 1 (mod 9) 对于任意整数 k\n应用到数字表达式：\n现在来看数字 x 对 9 的余数，也就是 x % 9：\nx (mod 9) = (a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0) (mod 9)\n由于 10^k ≡ 1 (mod 9)，我们可以将每个项中的 10^k 替换为 1：\nx (mod 9) = (a_k + a_(k-1) + ... + a_1 + a_0) (mod 9)\n也就是说，x 对 9 取模的结果，实际上等于 x 各位数字之和对 9 的余数。\n向上取整\n// 我们需要计算 x / y 向上取整\n \nint new_num = (x + y - 1) / y;\n在环形区间内移动 凯撒密码\nch = (ch - base + shift) % 26 + base;\n\nshift 是凯撒密码中的“位移”量，也就是你想要将字母平移的位数。举个例子，shift = 3 就意味着每个字母会向右移动3个位置。\nbase 是字母的起始点（基准字符），用于确保加密和解密的计算只在字母范围内循环。例如：\n\n如果字母是小写字母（如 &#039;a&#039;），则 base = &#039;a&#039;。\n如果字母是大写字母（如 &#039;A&#039;），则 base = &#039;A&#039;。\n\n\n\n详细解释：\n\nch - base：\n\n这个操作将字符 ch 转换为一个相对 base 的位置。例如，如果 ch 是 &#039;c&#039;，且 base 是 &#039;a&#039;，那么 &#039;c&#039; - &#039;a&#039; 结果为 2，因为 &#039;a&#039; 的 ASCII 值是 97，&#039;c&#039; 是 99，所以 99 - 97 = 2。\n\n\n(ch - base + shift)：\n\n这个操作将字符向右移动 shift 位。比如，如果你想对字母 &#039;c&#039; 进行加密，shift = 3，那么 (2 + 3) 就是 5。\n\n\n% 26：\n\n由于字母表有 26 个字母，这个操作确保结果循环在 26 个字母内。例如，如果位移后的结果大于 &#039;z&#039;，它会回绕到字母表的开始部分。如果 ch 是 &#039;z&#039;，并且 shift = 1，&#039;z&#039; 经过加密会变成 &#039;a&#039;，而不是 &#039;{&#039;。\n\n\n+ base：\n\n最后，加上 base 就是将数字转换回字母字符。例如，5 + &#039;a&#039; 就会变成 &#039;f&#039;，即将 5 映射回字符。\n\n\n\n字符串 子串处理与替换\n1. replace：\nreplace 用于替换字符串中的部分内容，可以替换从某个位置开始的指定长度的字符。\n基本语法：\nstring&amp; replace (size_t pos, size_t len, const string&amp; str);\nstring&amp; replace (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen);\n\npos: 要替换的起始位置。\nlen: 要替换的字符数。\nstr: 替换的内容。\n\n2. substr：\nsubstr 用于获取字符串的子字符串。\n基本语法：\nstring substr (size_t pos = 0, size_t len = npos) const;\n\npos: 子字符串的起始位置。\nlen: 要提取的子字符串的长度（默认为 npos，表示从 pos 到字符串的末尾）。\n\n快速转换进制\nvector&lt;char&gt; lettermap = {&#039;0&#039;, &#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;, &#039;6&#039;, &#039;7&#039;, &#039;8&#039;, &#039;9&#039;, \n                          &#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;, &#039;h&#039;, &#039;i&#039;, &#039;j&#039;, \n                          &#039;k&#039;, &#039;l&#039;, &#039;m&#039;, &#039;n&#039;, &#039;o&#039;, &#039;p&#039;, &#039;q&#039;, &#039;r&#039;, &#039;s&#039;, &#039;t&#039;, \n                          &#039;u&#039;, &#039;v&#039;, &#039;w&#039;, &#039;x&#039;, &#039;y&#039;, &#039;z&#039;};\n \nsigned main()\n{\n    int num, base;\n    cin &gt;&gt; num &gt;&gt; base;\n    \n    string s = &quot;&quot;;\n \n    // 将数字转换为指定进制\n    while (num)\n    {\n        s = lettermap[num % base] + s;  // 从高位到低位构建， 这样不需要\n        num /= base;\n    }\n \n    cout &lt;&lt; s &lt;&lt; &#039; &#039;;\n}\n异或\n异或的性质\n\n\n实质是二进制无进位加法 例如 1011 + 1101 = 0110\n\n\n异或运算满足交换律、结合律，也就是同一批数字，不管异或顺序是什么，最终的结果都是一个\n\n\nn ^ 0 = n, n ^ n = 0  可以结合第一个加法来理解\n\n\n整体异或和如果是x,整体中某个部分的异或和如果是y,那么剩下部分的异或和是 x ^ y 可以结合2的结合律，交换律来理解\n\n\n这些结论最重要的就是1结论，所有其他结论都可以由这个结论推论得到\n其中第4相关的题目最多，利用区间上异或和的性质\n区间异或和的性质\n计算从 0 到 x 的异或和：\n\n通过观察，可以发现异或的规律每四个数重复一次：\n如果 x % 4 == 0，则 xor(0, x) = x\n如果 x % 4 == 1，则 xor(0, x) = 1\n如果 x % 4 == 2，则 xor(0, x) = x + 1\n如果 x % 4 == 3，则 xor(0, x) = 0\n\n计算区间 [l, r] 的异或和：\n假设我们可以计算出 xor(0, r) 和 xor(0, l-1) ，那么： xor(l, r) = xor(0, r) ^ xor(0, l-1)\n异或的骚操作\n\n交换两个数\n\nint a = 1, b = 2;\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n// as a result a equals 2 and b equals 1\n具体过程：\n\n第一步：a = a ^ b; 之后，a 保存的是 a 和 b 异或的结果，即 a 和 b 的混合信息。\n第二步：b = a ^ b; 在这一步中，a 已经存储了 a ^ b，所以 b = (a ^ b) ^ b。根据自反性，b 变成了原来的 a。\n第三步：a = a ^ b; 最后，a = (a ^ b) ^ a，根据自反性，a 变成了原来的 b。\n\n所以，通过这三步异或操作，我们完成了 a 和 b 的交换，而无需使用额外的临时变量。这种方法是非常高效且空间优化的，尤其是在内存受限的情况下。\n\n找到缺失的数字\n\n// 在1~10中随便挖掉一个 让快速找出\n \n// 原理： 缺失的数字 = 所有数异或和 - 剩下数字的异或和\n \nvector&lt;int&gt; v = {1, 2, 3, 4, 6, 7, 8, 9};\n \n// 计算1 ~ 10 的异或和 也就是 xor(0, 10) ^ xor(0, 0) 而xor(0, 0) = 0\n \nint xor_1_to_10 = 10 + 1 = 11;\n \n// 计算v中数字的异或和 应当从0开始\n \nint xor_v = 0;\nfor (int i = 0; i &lt; v.size(); i++) xor_v ^= v[i];\n \n// 计算剩下的数字\n \nint result = xor_1_to_10 ^ xor_v;\n \n例：\nleetcode268\n可以说是异或很好的板子题\nac codes are as follows:\nclass Solution\n{\npublic:\n    int xor_(int x)\n    {\n        if (x % 4 == 0)\n        {\n            return x;\n        }\n        if (x % 4 == 1)\n        {\n            return 1;\n        }\n        if (x % 4 == 2)\n        {\n            return x + 1;\n        }\n        return 0;\n    }\n \n    int missingNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n \n        // calculate xor from 0 to n\n \n        int xor_1_to_n = xor_(n);\n \n        // calculate xor from array\n        int temp = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            temp ^= i;\n        }\n \n        return xor_1_to_n ^ temp;\n    }\n};\n\n\n数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数\n用到的是性质2 可以往上看一眼\nvector&lt;int&gt; v = {1, 1, 1, 1, 2, 2, 3};\nint res = 0;\nfor (auto &amp;&amp; i : v) res ^= i;\nreturn res; \n// as a result res equals 3\n\n\n例：\nleetcode136\nac codes are as follows:\nclass Solution\n{\npublic:\n    int singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int ans = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            ans ^= i;\n        }\n        return ans;\n    }\n};\n\nBrian Kernighan算法-提取出二进制状态中最右侧的1\n\n其实就是lowbit 将在树状数组中反复使用\n对一个正数x取反 得到x ^ 0\n对其结果 + 1 得到 ~x + 1 其实就是相反数-x\n最后做与运算 则有\nint lowbit(x)\n{\n    return x &amp; (-x);\n}\n最后得到的结果在二进制下将至多只有一个1\n\n数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数\n\n原理：设结果a, b 使得 a != b 那么一定有 a 和 b 在二进制的某一位不相同\n那么原数组中一定可以分成两种数字： 第一种在那一位是0 第二种在那一位是1\n我们只需要分别对这两种数字进行异或和 就能筛选出唯一的数字\n思考：二进制下有多少位不相同 有影响吗？\n**ans：**没有影响 我们要做的只是筛选工作 选出来即可\ncode：\nvector&lt;int&gt; v = {1, 1, 2, 3, 3, 4};\n \nint temp = 0;\nfor (auto &amp;&amp;i : v) temp ^= i;\nint lowbit_num = temp &amp; (-temp);\n \n// 得到了这个唯一的&quot;1&quot; 我们如何继续操作？\n// 我们继续用到与运算：如果num 在 lowbit_num的对应位数上是1 那么结果就是num 如果是0 那么结果就是00000000 也就是0\n \nint ans1 = 0;\nfor (auto &amp;&amp;i : v) if (i &amp; lowbit_num) ans1 ^= i;\nans2 = ans1 ^ lowbit_num;\n// 用到了性质4 部分和 = 全体和 ^ 另一部分和\n例:\nleetcode260\nac codes are as follows:\nclass Solution\n{\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        unsigned xor_nums = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            xor_nums ^= i;\n        }\n \n        int lowbit = xor_nums &amp; (-xor_nums);\n \n        int res1 = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            if (lowbit &amp; i)\n            {\n                res1 ^= i;\n            }\n        }\n        return {res1, res1 ^ (int)xor_nums};\n    }\n};\n \n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\n为什么使用 unsigned 类型来避免溢出\n\n补码表示和溢出问题：\n\n在 C++ 中，整数是以补码的形式存储的。\n对于 int 类型，取负数的操作涉及到补码的反转，当 xor_nums 等于 INT_MIN（即 -2147483648）时，-INT_MIN 会导致溢出。因为 INT_MIN 是 -2147483648，其补码表示超出了 int 类型的范围，因此无法表示其取反的结果，导致未定义的行为。\n\n\n使用 unsigned 类型：\n\nunsigned 类型在存储负数时表现不同，因为它不使用补码。无符号整数的范围是 [0, 2^n - 1]，它不涉及负数，因此在进行负数取反时不会出现溢出问题。\n当你将 xor_nums 声明为 unsigned 类型时，它将不会出现负数，因此 -xor_nums 会按照无符号整数的规则进行计算，不会发生溢出。\n\n\n\n\n\n\n我们可以在以下场景尝试使用unsigned：\n位运算中出现了负数\n如果你需要执行位操作时，运算符会作用于负数，例如 a &amp; b、a ^ b 或 a | b，而某些操作可能涉及到负数的补码表示。这时，使用 unsigned 类型可以避免这些负数影响结果，因为无符号整数的操作不会引发负数的补码计算。\n进行最低位 1 查找（x &amp; (-x)）时\n在诸如 x &amp; (-x) 的操作中，目标是找到二进制表示中最低的 1。如果 x 是负数（例如 -2147483648），在 int 类型中执行 -x 可能导致溢出，因为补码表示不能正确处理 INT_MIN。而如果使用 unsigned 类型， x 会被视为无符号数，取负时不会引发溢出问题。\n\n数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数\n\nto be continued…\n\n今天的题目基本上都可以用map去重做， 这里是为了更好的熟悉异或运算\n\n\n\n                  \n                  Important\n                  \n                \n\n\n重要提示\n    void solve()\n    {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n \n        // int left = xor_(l - 1);\n        // int right = xor_(r);\n        // cout &lt;&lt; (left ^ right);\n \n        cout &lt;&lt; xor_(l - 1) ^ xor_(r);\n    }\n注释部分不会报错 而第十行会报错 是因为cout需要一个可以明确的返回值类型而异或操作给不出, 笔者也没有想明白这是为什么)\n总而言之 在异或操作的外面加一个括号可以完美避免这个问题\n\n\n\n二分\nTO START WITH\n今天的内容侧重于我自己对代码流程的理解和思考 建议初步了解二分思想 想要规范书写流程 培养思维逻辑的读者\n不建议对二分思想毫无了解的读者阅读 你会一头雾水的！（确信\n二分搜索\n\n在有序数组中确定target存在还是不存在\n\n\n\n                  \n                  Important\n                  \n                \n\n\n为什么一定要是有序的？\n二分的思想一定程度上依赖于单调性 无序的数组不存在单调性 无法应用二分\n\n\n\nbool isExist(vector&lt;int&gt; &amp;nums, int target)\n{\n    if (nums.empty()) return 0;\n    \n    int l = 0, r = nums.size() - 1, mid;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        // 为什么不直接(r + l) / 2 ? 两个很大的数字相加有可能会超出int 而line9可以保证计算的过程始终讴歌处于[l, r]\n        \n        if (nums[mid] == target) return 1;\n        else if (nums[mid] &lt; target) /* 缩短左边界 */ l = mid + 1;\n        else /* 缩短右边界 */ r = mid - 1;\n    }\n    //进行到这里还没return 就说明没找到\n    return 0;\n}\n\n在有序数组中找&gt;=target的最左位置\n\n\n\n                  \n                  Important\n                  \n                \n\n\n可以被*upper_bound 替代\n\n\n\nint findleft(vector&lt;int&gt; &amp;nums, int target)\n{\n    int l = 0, r = nums.size() - 1, mid;\n    int ans = -1;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        if (nums[mid] &gt;= target) // 满足条件 更新ans 并继续缩小范围\n        {\n            ans = mid;\n            // 如何缩小范围? 这是一个单调的 现在发现数字大了 那么应该缩小右边界\n            r = mid - 1;\n        }\n        else /* 当前数字太小了 那么应该找更大的 缩小左边界 */ l = mid + 1;\n    }\n    return ans; // 如果没有找到结果 将会返回-1\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如果是 &gt;target的最左位置 应该如何思考？\n事实上 我们只需要把line9的 &gt;= 变成 &gt; 即可\n\n\n\n\n在有序数组中找⇐target的最右位置\n\n那么 ⇐target 的最右位置 应该怎么做呢\nint findright(vector&lt;int&gt; &amp;nums, int target)\n{\n\tint l = 0, r = nums.size() - 1, mid;\n\tint ans = -1;\n\t\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2; // 见识过位运算的骚操作之后还是觉得这样写方便一点 少打一个括号\n\t\tif (nums[mid] &lt;= target) // 这是符合要求的 可以更新边界 更新ans\n\t\t{\n\t\t\tans = mid;\n\t\t\t// 如何更新边界呢？找找有没有更大的数满足条件 缩短左边界\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse r = mid - 1;\n\t}\n\treturn ans; // 没找到返回-1\n}\n\n我们的思考重心应该放在 根据 nums[mid] 和 target 的对应关系 在满足条件的时候更新ans 缩短边界\n\n\n二分搜索不一定发生在有序数组上（比如寻找峰值问题）\n\n板子题 leetcode162\nac codes are as follows:\nclass Solution\n{\npublic:\n    int findPeakElement(vector&lt;int&gt; &amp;nums)\n    {\n        auto n = nums.size();\n \n        if (n == 1) // 只有一个元素 那么这个就是极值点\n        {\n            return 0; // 特\n        }\n\t\t// 首先检查nums.front() 和 nums.back()\n        if (nums[0] &gt; nums[1])\n        {\n            return 0;\n        }\n        if (nums[n - 1] &gt; nums[n - 2])\n        {\n            return n - 1;\n        }\n \n        // 现在已经确定 [1, n - 2] 中一定有极值点 可以开始二分搜索\n \n        int l = 1, r = n - 2, mid;\n \n        while(l &lt;= r)\n        {\n            mid = l + (l - l) / 2;\n \n            // 判断是不是极值点 要看nums[mid]和相邻左右的关系\n \n            if (nums[mid] &gt; nums[mid - 1] and nums[mid] &gt; nums[mid + 1])\n            {\n                return mid;\n            }\n            else\n            {\n                if (nums[mid] &lt; nums[mid - 1])\n                {\n                    // 左边呈上升趋势 缩短右边界 在左边查找\n                    r = mid - 1;\n                }\n                else\n                {\n                    // 缩短左边界 在右边查找\n                    l = mid + 1;\n                }\n            }\n        }\n        return mid;\n    }\n};\n二分搜索 with STL\n在 stl 中 我们有 ranges::upper_bound 和 ranges::lower_bound\nvector&lt;int&gt; v = {1, 2, 3, 4, 5};\n \nauto it1 = ranges::upper_bound(v, 2);\n// 返回指向 v[2] = 3 的迭代器\nauto it2 = ranges::lower_bound(v, 2);\n// 返回指向 v[1] = 2 的迭代器\n分析实质\nranges::upper_bound 返回的it1 满足 *it1 &gt; 2*, 而 ranges::lower_bound 返回的 it2 满足 it2 &gt;= 2\n并且他们都是首个满足条件的元素\n所以我们分析可以得到：\n问 &gt;= x 的最小值 可以int it = *ranges::lower_bound(v, x)\n问 &gt; x 的最小值 可以 int it = *ranges::upper_bound(v, x)\n问 &lt; x  的 最大值 其实就是 &gt;= x 的前一个值\n例如 问 &lt; 3 的最小值 其实就是 &gt;= 3  的前一个值 也就是2\n那我们可以写 int it = *(ranges::lower_bound(v, x) - 1)\n同理：问 &lt;= x 的 最大值 其实就是 &gt; x 的 前一个值\n也就是 int it = *(ranges::upper_bound(v, x) - 1)\n总结 and 板子\n\n\n                  \n                  Important\n                  \n                \n\n\n总结一下吧：\n问更大的有现成函数\n问更小的就 计算目标范围的补集（例如问 &lt;= 那么就求&gt;) 把求出来的结果-1 即可\n最后的判断标准：\n问大就判断是否超出右侧区间；\n问小就判断是否超出左侧区间；\n若询问相等 就额外判等\n\n\n\nvoid find(vector&lt;int&gt; &amp;nums, int target)\n{\n    int n = nums.size();\n    \n\t// 求出首个使得num == target 的num的位置 (不存在返回-1)\n\tint it1 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; ((it1 == n or nums[it1] != target) ? -1 : it1) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt;= target 的num的位置 (不存在返回-1)\n\tint it2 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it2 == n ? -1 : it2) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt; target 的num的位置 (不存在返回-1)\n    int it3 = ranges::upper_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it3 == n ? -1 : it3) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt;= target 的num的位置 (不存在返回-1)\n    int it4 = ranges::upper_bound(nums, target) - nums.begin() - 1; // 其实就是it3 - 1!!!!\n    cout &lt;&lt; (it4 &lt; 0 ? -1 : it4) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt; target 的num的位置 (不存在返回-1)\n    int it5 = ranges::lower_bound(nums, target) - nums.begin() - 1; // 其实就是it2 - 1!!!!\n    cout &lt;&lt; (it5 &lt; 0 ? -1 : it5) &lt;&lt; endl;\n}\n例题\nleetcode34\n第一个位置就是 &gt;= x 的第一个元素\n最后一个位置就是 &gt; x 的前一个元素\n思路：\n// 首先 lower出 &gt;= x 的 第一个元素 判断是否与目标值相等 或者是否来到边界(来到边界意味着数组中没有不小于target的元素)\nint num1 = ranges::lower_bound(nums, target) - nums.begin();\n \nif (num1 == nums.size() or nums[num1] != target)\n{\n\treturn {-1, -1};\n}\nelse\n{\n    // 数组中起码有一个 我们就可以upper了\n    int num2 = ranges::upper_bound(nums, target) - nums.begin() - 1;\n    // remember that 直接与begin()相减 求出来的就是下标\n    return {num1, num2};\n}    \n另外：\n我们也可以利用cpp20的 equal_range 函数 来快速获得范围\n{0, 1, 1, 1, 2}\nauto [start, end] = ranges::equal_range(nums, 1); // 此处的auto应该是pair&lt;iterator, iterator&gt;类型\n// start指向nums[1], end指向nums[3]的下一个 也就是 [start, end) 这样一个半开区间\nif (start == end) return {-1, -1};\nreturn {start - nums.begin(), end - 1 - nums.begin()};\n// 如果问长度那么直接end - start即可\nleetcode35\n直接返回 &gt;= target 的第一个元素位置即可\nreturn ranges::lower_bound(nums, target) - nums.begin();\nleetcode704\n跟上面大差不差 搜索到lower之后比较是否相等即可\nauto num = ranges::lower_bound(nums, target) - nums.begin();\nreturn (num != nums.size() and nums[num] == target ? num : -1);\n\n\n                  \n                  Important\n                  \n                \n\n\n当我们需要使用迭代器的时候 要注意有可能返回 nums.emd() 导致 num = n\n这样的情况下nums[num] 是 越界的\n因此 我们应该加上 num == nums.size() 的判断\n\n\n\nleetcode744\n判断 upper是否 == letters.end() 即可\nauto it = ranges::upper_bound(letters, target) - letters.begin();\nreturn (it == letters.size() ? letters.front() : letters[it]);\nleetcode2529\n什么是数目？\n我们不妨做个测试\n{-1, 0, 1}\nlower(0) - begin() 会返回第一个非负数的下标 记为 it 显然 it - 1就是最后一个负数的下标 本例中为0 那么个数就是最后一个下标  0 + 1 也恰好就是 lower(0) - begin()\nlower(1) - begin() 返回第一个正数的下标 本例中为2 个数应为 size() - it其实就是 end() - lower(1)\nint a = ranges::lower_bound(nums, 0) - nums.begin();\nint b = nums.end() - ranges::upper_bound(nums, 0);\nreturn max(a, b);\n二分答案\n解题步骤\n\n估计最终答案可能的范围是什么 经验之谈：为什么叫做二分答案呢？因为二分的就是答案——问什么就二分什么\n分析问题的答案和给定条件之间的单调性，大部分时候只需要用到自然智慧\n建立一个f函数，当答案固定的情况下，判断给定的条件是否达标\n在最终答案可能的范围上不断二分搜索，每次用f函数判断，直到二分结束，找到最合适的答案\n\n核心点：分析单调性、建立f函数\n注意：这个技巧常用且重要，一定要引起重视\n这么说出来可能过于抽象 我们结合例题理解\n二分答案：求最小\nleetcode1283\n问什么就对什么二分， 我们对除数二分\n除数的上下界怎么找？ 下界应该是1 这样可以让sum最大 上界可以选择ranges::max(nums) 这样可以让sum最小\n那我们就确定下来：\n// 对除数二分\n// 除数的范围应该在[1, ranges::max(num)]\n \nint l = 1, r = ranges::max(nums), m, ans;\n随后二分开始\nwhile (l &lt;= r)\n{\n    m = l + (r - l) / 2;\n    // m 是 除数\n    if (f(m, nums, int threshold)) // 满足条件 记录答案 找更小的\n    {\n        ans = m;\n        r = m - 1;\n    }\n    else // 不满足条件 找更大的\n    {\n        l = m + 1;\n    }\n    return ans;\n}\nf函数如下：\nbool f(int m, vector&lt;int&gt; &amp;nums, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;i: nums)\n    {\n        ans += (i + m - 1) / m; // 上取整 注意能不用ceil就不用ceil 可能造成精度丢失\n        if (ans &gt; target) \n        {\n            return 0;\n        }\n    }\n    return 1;\n}\nleetcode2187\n问时间 我们尝试对时间进行二分\n最快时间应该是 ranges::min(time) 此时 totalTrips = 1\n最慢时间应该是 ranges::min(time) * totalTrips\n不难写出如下代码\nlong long minimumTime(vector&lt;int&gt; &amp;time, int totalTrips)\n{\n    // 二分时间\n    long long l = ranges::min(time), r = l * totalTrips, m, ans;\n    while (l &lt;= r)\n    {\n        m = l + (r - l) / 2;\n \n        if (f(m, time, totalTrips)) ans = m, r = m - 1;\n        else l = m + 1;\n    }\n    return ans;\n}\nf函数也就是常规的加一遍：\nbool f(long long m, vector&lt;int&gt;&amp; time, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;t : time)\n    {\n        ans += m / t;\n        if (ans &gt;= target)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}\n难而杂的例题\nleetcode875\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：有没有可能速度为0?\n当且仅当数组全部都是0的时候 每小时0根也肯定可以吃完\n题目中说到香蕉数量&gt;= 1 那么不可能是0\n因此 最慢速度就是1\n思考：最快速度是多少\n应当为 数组中的最大元素 （一堆最多的香蕉）\n思考：速度再快有意义吗？\n没有了 我们需要用到二分法 那么初始的范围小 对我们的二分是有益的\n\n\n\n经过分析 我们可以得出 速度的取值应当在 [1, *max_element(piles.begin(), piles.end())]\n不难发现：随着速度的增大 吃掉所有香蕉用掉的小时数 只可能不严格单调递减  速度变大反而耗时变多的情况是不存在的\n那我们就可以对速度进行二分  进而求出小时数\nac codes are as follows:\nclass Solution\n{\npublic:\n    int minEatingSpeed(vector&lt;int&gt; &amp;piles, int h)\n    {\n        int l = 1, r = *max_element(piles.begin(), piles.end());\n \n        int ans = 0;\n        int mid = 0;\n        while (l &lt;= r)\n        {\n            mid = l + (r - l) / 2;\n            /*\n            这个mid是什么？是速度\n            我们要求什么？求时间\n            因此我们应该遍历整个香蕉数组， 把用时求出来 和 h 进行比较\n            */\n            long long h1 = 0; // h1 就是 用时 实际比赛的时候我们其实可以#define int long long\n            for (auto &amp;&amp;pile : piles)\n            {\n                /*\n                是熟悉的区间分割诶！\n                我的拙劣的讲解视频 BV15QcAefE5j\n                区间是 mid\n                要划分的变量是 pile\n                用时就是 (pile - 1) / mid + 1\n                我们其实也可以写成\n                (pile + mid - 1) / mid\n                \n                by the way 他的本质其实是 pile / mid 结果向上取整\n                */\n \n                h1 += (pile - 1) / mid + 1;\n            }\n \n            if (h1 &lt;= h) // 当前用时达标！更新答案 放慢速度\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标！增加速度\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n这里有一个很实用的技巧 就是把 速度 → 时间 的变化作为函数封装起来\n具体来说我们有\nint f(vector&lt;int&gt; &amp;piles, int k)\n{\n    int ans = 0;\n    \n    for (auto&amp;&amp; p: piles) ans += (p + k - 1) / k;\n    \n    return ans;\n}\n此处被 return 的 ans 将作为 h1 与 h 进行比较\n这也就是我第3步说的 建立f函数\nleetcode410\n看到「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。\n为什么？「元素和的最大值」越小，需要划分出的段数就越多，反之越少。例如示例 1 的 nums = [7,2,5,10,8]，在最大和为 15 时，至少要划分 3 段，比如 [7,2,5],[10],[8]。而在最大和为 18 时，只需要划分 2 段，比如 [7,2,5],[10,8]。\n一般地，二分的值越小，越不能/能满足要求；二分的值越大，越能/不能满足要求。有单调性的保证，就可以二分答案了。\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如何保证二分结果一定能划分成 k 段？如果小于 k 段呢？\n题目要求划分成 k 段，但其实如果能划分成小于 k 段，也可以划分成 k 段。比如划分成 k−1 段，那么把其中的一个长度至少为 2 的段分成两段，这两段的元素和都比原来的一段小，也满足要求。所以题目相当于：把数组划分成至多 k 段，分别计算每一段的元素和，最小化元素和的最大值。\n应当注意的是， k的取值是 1 &lt;= k &lt;= min(50, nums.length) 这意味着k不会取一个天花乱坠的数字 我们能保证大部分情况下k &lt;= nums.size()  这就够了\n\n\n\n题目问我们最大值 我们就尝试二分最大值\n最大的最大值是多少？k = 1 时数组和的最大值最大 就是accumulate(nums.begin(), nums.end())\n最小的最大值是多少？k = nums.size() 时数组和的最大值最小 是 max_element(nums.begin(), nums.end())\n如何把最大值 跟 k 联系起来？\nf函数参考如下：\nint f(vector&lt;int&gt; nums, int m)\n    {\n        int ans = 1, sum = 0; // 一开始只需要分一段\n \n        for (auto &amp;&amp;i : nums)\n        {\n            if (sum + i &lt;= m) // 如果最大值没超过 那么最大值可以继续增加\n            {\n                sum += i;\n            }\n            else // 超过了就需要增加一段了 与此同时 sum 更新为新的一段\n            {\n                ans++;\n                sum = i;\n            }\n        }\n        return ans;\n    }\n有了这个函数 我们就找到了最大值和段数的关系 那么我们只需要不断二分最大值 让段数逐渐接近k就行\nac codes are as follows:\nint splitArray(vector&lt;int&gt; &amp;nums, int k)\n    {\n        long long sum = accumulate(nums.begin(), nums.end(), 0ll);\n        // 二分的是最大值 要求的答案是k\n        // k 可以尽可能小 因为小于k段却满足条件 我们大可以把其中的一些段分开 也不会影响答案\n        long long ans = 0;\n \n        long long l = *max_element(nums.begin(), nums.end()), r = sum, mid, need;\n        while (l &lt;= r)\n        {\n            // 必须让每一部分的累加和 &lt;= mid， 请问划分成几个部分才够？\n \n            mid = l + (r - l) / 2;\n \n            need = f(nums, mid); // need 是最大值为 mid 所需要的段数\n \n            if (need &lt;= k) // 达标 更新答案 缩小右区间 找更小的最大值\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标 缩小左区间 找更大的最大值\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n\n                  \n                  Important\n                  \n                \n\n\n在f函数中 我们就可以适当的暴力一点 因为f是为二分服务的 而二分本身复杂度就已经很低了\n\n\n\n看完这两题是不是有一点体会了？有的兄弟有的，这样的例题还有一堆\n现在是 20250114 00：01：32\n牛客 机器人跳跃问题\n看到问能量值 那我们尝试二分能量值\n首先要确定能量值的边界\n我们来分析题目：能量值比楼房的高度小 反而要减少 比楼房的高度高 反而要增大\n那我们只需要让他的高度比所有的楼房都要高 不就一定能通过吗\n因此 r = *max_element(v.begin(), v.end())\n那么我们最起码要让他安然无恙的通过最矮的楼房 否则就必定无法通过\n因此 l = *min_element(v.begin(), v.end())\n\n\n                  \n                  Important\n                  \n                \n\n\n最大值最小值的写法在cpp20中已经得到了进一步优化\n我们可以使用 ranges::max(v)  和 ranges::min(v) 来快速求数组的最大 最小值\n\n\n\n那我们写f函数的目的也就随之确定下来， 即：\n给定一个能量值 判断这个能量值是否可以通过所有楼房\nbool f(vector&lt;int&gt; v /* 所有楼房高度 */, int e /* 能量 */, int max_ /* 最大建筑高度 */)\n{\n    for (auto &amp;&amp;i: v)\n    {\n        if (e &gt; i) e += (e - i);\n        else e -= (i - e);\n        \n        // 判断是否达到上边界\n        if (e &gt;= max) return 1;\n        // 判断是否变成负数\n        if (e &lt; 0) return 0;\n    }\n    return 1;\n}\n有了f函数 我们就可以写出二分答案的流程\nvoid solve()\n{\n\tint n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; v(n);\n    for (auto &amp;&amp;i: v) cin &gt;&gt; i;\n    \n    auto l = ranges::min(v), r = ranges::max(v);\n    auto max_ = r;\n    \n    int mid, ans;\n    \n    while (l &lt;= r)\n    {\n        mid = l + (r - l) / 2; // 时刻牢记 mid 是初始能量\n        \n        // 给定能量 用f来验证是否满足题意\n        if (f(v, mid, max_)) // 满足条件 找更小的\n        {\n            ans = mid;\n            r = mid - 1;\n        }\n        else // 不满足条件 找更大的\n        {\n            l = mid + 1;\n        }\n    }\n    cout &lt;&lt; ans;\n}\nleetcode719\nac codes are as follows:\nclass Solution\n{\npublic:\n    int f(vector&lt;int&gt; nums, int lim)\n    {\n        int ans = 0;\n        int r = 0;\n        for (int l = 0; l &lt; nums.size(); l++)\n        {\n            while (r &lt; nums.size() and nums[r] - nums[l] &lt;= lim)\n            {\n                r++;\n            }\n            ans += r - l - 1;\n        }\n        return ans;\n    }\n \n    int smallestDistancePair(vector&lt;int&gt; &amp;nums, int k)\n    {\n        ranges::sort(nums);\n \n        long long l = 0, r = nums.back() - nums.front();\n \n        long long mid, ans, cur;\n \n        while (l &lt;= r)\n        {\n            // 我们再对数字差作二分\n            mid = l + (r - l) / 2;\n            // 要验证是否是第k小 只需要遍历看看 差值 &lt;= mid 的 是否有k个\n            if (f(nums, mid) &gt;= k) // 有可能有更小的 因为 f里面提到 差值 &lt;= mid 即可\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\nf函数的构造比较复杂 值得细品…\nleetcode2141\n并查集\n并查集解决的是怎样的问题呢？就是对集合的 合并 查询\n要想比较高效的完成合并查询工作 我们需要两个数组：father 和  sz， 一个模拟递归的栈stk\n板子：\n初始化：\nvector&lt;int&gt; father, siz;\nstack&lt;int&gt; stk;\n \nvoid init(int n) {\n    father.resize(n);\n    siz.resize(n, 1);\n    ranges::iota(father, 0ll);  // father[i] 初始时指向自己\n}\n完全体：\n// 查找父节点，路径压缩\nint ffind(int i) {\n    while (father[i] != i) {\n        // 递归查找并压缩路径, 使用栈优化递归\n        stk.push(i);\n        i = father[i];\n    }\n    while (!stk.empty())\n    {\n        father[stk.top()] = i; // 将栈中的节点都指向根节点\n        stk.pop();\n    }\n    return father[i];\n}\n \n// 合并两个集合，按秩合并\nvoid union(int i, int j) {\n    int rootI = ffind(i);\n    int rootJ = ffind(j);\n \n    if (rootI != rootJ) {\n        // 按树的大小（秩）合并\n        if (siz[rootI] &lt; siz[rootJ]) {\n            swap(rootI, rootJ);  // 确保 rootI 永远是较大的树\n        }\n        father[rootJ] = rootI;  // 将 rootJ 的根节点指向 rootI\n        siz[rootI] += siz[rootJ];  // 更新 rootI 的大小\n    }\n}\n \nbool issame(int i, int j)\n{\n\treturn ffind(i) == ffind(j);\n}\n精简化写法：\nint ffind(int n)\n{\n    if (n != father[n])\n    {\n        father[n] = ffind(father[n]);\n    }\n    return father[n];\n}\n \nvoid funion(int i, int j)\n{\n\tfather[i] = j;\n}\n \nbool issame(int i, int j)\n{\n    return ffind(i) == ffind(j);\n}\nluoguP3367\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j)\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n    init(n);\n    int a, b, c;\n    while (m--)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        b--, c--; // 0 based\n        if (a == 1)\n        {\n            funion(b, c);\n        }\n        else\n        {\n            cout &lt;&lt; (issame(b, c) ? &#039;Y&#039; : &#039;N&#039;) &lt;&lt; endl;\n        }\n    }\n}\nDFS\n板子：\nvector&lt;pair&lt;int, int&gt;&gt; d = {{1, 0}, {0, 1}{-1, 0}, {0, -1}};\n \nvoid dfs(int i, int j, vector&lt;vector&lt;int&gt;&gt; grid)\n{\n    if (i &lt; 0 or i == grid.size() or j &lt; 0 or j == grid[0].size() or grid[i][j] != 0)\n    {\n        return;\n    }\n    \n    grid[i][j] = 2; // 与原先不同的标记\n    \n    for (auto &amp;&amp;[x, y]: d)\n    {\n        dfs(i + x, j + y, grid);\n    }\n}\n图\n图的表示\n邻接表\nunordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj; // v1, v2, val\n邻接矩阵\n图的遍历\ndfs\nbfs\n图算法\n最小生成树 （MST，Minimum Spanning Tree）\n什么是最小生成树？ 最小生成树是所有节点的最小联通子图， 即：用最小的成本（边的权值）将所有的节点连接到一起\n假如存在 n 个节点 那么必定可以用 n - 1 条边将他们连接到一起， 如何选择这 n - 1 条边就是任务所在\nprim\n\n\n                  \n                  Important\n                  \n                \n\n\n\n解锁的点的放入 set、解锁的边的集合叫 heap（小根堆）。一开始 set 和 heap 都为空。\n可从任意点开始，开始点加入到 set，开始点的所有边加入到 heap\n从 heap 中弹出权值最小的边 e，查看边 e 所去往的点 x\n\n如果 x 已经在 set 中，边 e舍弃，重复步骤3\n如果 x不在 set 中，边 e 属于最小生成树，把 x 加入 set ，重复步骤3\n\n\n当 heap 为空，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m; // n为顶点数，m为边数\n    cin &gt;&gt; n &gt;&gt; m;\n    // prim\n    set&lt;int&gt; nodes; // 存储已访问的节点\n \n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq; // 小顶堆，存储边{权重,目标顶点}\n \n    int MSTweight = 0; // 最小生成树的总权重\n \n    int v1, v2, val; // v1,v2为边的两个顶点，val为边的权重\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表存储图，adj[u]存储u的所有邻边{顶点,权重}\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        // 无向图需要添加两条边\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    pq.push({0, 1}); // 从顶点1开始，初始权重为0\n \n    while (pq.size())\n    {\n        auto [curw, cur] = pq.top(); // curw为当前边的权重，cur为当前顶点\n        pq.pop();\n \n        if (nodes.count(cur)) // 如果当前顶点已访问，跳过\n        {\n            continue;\n        }\n \n        nodes.insert(cur); // 将当前顶点标记为已访问\n        MSTweight += curw; // 将当前边的权重加入最小生成树的总权重\n \n        // 遍历当前顶点的所有邻边\n        for (auto &amp;&amp;[next, nextw] : adj[cur]) // next为邻接顶点，nextw为边权重\n        {\n            if (!nodes.count(next)) // 如果邻接顶点未访问\n            {\n                pq.push({nextw, next}); // 将边加入优先队列\n            }\n        }\n    }\n    if (nodes.size() != n) // 如果访问的顶点数不等于总顶点数，说明图不连通\n    {\n        cout &lt;&lt; &quot;orz&quot;; // 输出无解\n    }\n    else\n    {\n        cout &lt;&lt; MSTweight; // 输出最小生成树的总权重\n    }\n}\nkruskal\n\n\n                  \n                  Important\n                  \n                \n\n\n\n把所有的边，根据权值从小到大排序，从权值小的边开始考虑\n如果连接当前的边不会形成环，就选择当前的边\n如果连接当前的边会形成环，就不要当前的边\n考察完所有边之后，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m, v1, v2, val;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    struct Data\n    {\n        int v1, v2, val;\n    };\n    vector&lt;Data&gt; datas;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        v1--, v2--;\n        if (v1 != v2)\n        {\n            datas.push_back({v1, v2, val});\n        }\n    }\n \n    // kruskal\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri - rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n \n    ranges::sort(datas, [](Data &amp;a, Data &amp;b)\n                 { return a.val &lt; b.val; });\n \n    init(5001);\n    int ans = 0, count = 0;\n \n    vector&lt;bool&gt; visited(n, 0);\n    for (auto &amp;&amp;[v1, v2, val] : datas)\n    {\n        if (!issame(v1, v2))\n        {\n            visited[v1] = visited[v2] = 1;\n            ans += val;\n            funion(v1, v2);\n            count++;\n        }\n    }\n \n    if (count == n - 1)\n    {\n        cout &lt;&lt; ans;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;orz&quot;;\n    }\n}\n拓扑排序\nluoguB3644\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    int num;\n \n    // 没有边权的邻接表\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj;\n    // 入度\n    vector&lt;int&gt; indegree(n + 1, 0); // 1 based\n    vector&lt;int&gt; result;\n \n    for (int i = 1; i &lt;= n; i++)\n    {\n        adj[i];\n        while (cin &gt;&gt; num)\n        {\n            if (num == 0)\n            {\n                break;\n            }\n            adj[i].push_back(num);\n            indegree[num]++; // 入度， 入度！\n        }\n    }\n \n    // 拓扑\n    queue&lt;int&gt; que;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        // 入度为0 可以作为开头 假如队列\n        if (indegree[i] == 0)\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    for (auto &amp;&amp;i : result)\n    {\n        cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n    }\n}\nKMP\nvector&lt;int&gt; getnext(string s)\n{\n\tint n = s.size();\n\tvector&lt;int&gt; v(n, 0);\n\tint j = 0; // 前缀长度\n\tfor (int i = 1; i &lt; n; i++)\n\t{\n\t\twhile (j and s[i] != s[j])\n\t\t{\n\t\t\tj = v[j - 1];\n\t\t}\n\t\tif (s[i] == s[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tv[i] = j;\n\t}\n\treturn v;\n}\n \n "},"对暴搜的研究/很杂乱的板子":{"slug":"对暴搜的研究/很杂乱的板子","filePath":"对暴搜的研究/很杂乱的板子.md","title":"很杂乱的板子","links":[],"tags":[],"content":"// 大数加法\nstring largeadd(string &amp;a, string &amp;b)\n{\n    if (a.size() &lt; b.size())\n        swap(a, b);\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        int bi = b[b.size() - i - 1] - &#039;0&#039;;\n        int sum = ai + bi + p;\n        if (sum &gt;= 10)\n        {\n            p = 1;\n            sum -= 10;\n        }\n        else\n            p = 0;\n        a[a.size() - 1 - i] = sum + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == &#039;9&#039; &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;0&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai + p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    if (p == 1)\n        a.insert(a.begin(), &#039;1&#039;);\n    return a;\n}\n// 大数减法\nstring largemin(string a, string b)\n{\n    int flag = 0;\n    if (b.size() &gt;= a.size() &amp;&amp; b &gt;= a)\n    {\n        swap(a, b);\n        flag = 1;\n    }\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - 1 - i] - &#039;0&#039;;\n        int bi = b[b.size() - 1 - i] - &#039;0&#039;;\n        int diff = ai - bi - p;\n        if (diff &lt; 0)\n        {\n            p = 1;\n            diff += 10;\n        }\n        else\n            p = 0;\n        a[a.size() - i - 1] = diff + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == 0 &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;9&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai - p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    while (*a.begin() == &#039;0&#039; &amp;&amp; a.size() &gt; 1)\n        a.erase(a.begin());\n    if (flag)\n        a.insert(a.begin(), &#039;-&#039;);\n    return a;\n}\n \n// DSU并查集\nclass DSU\n{\nprivate:\n    vector&lt;int&gt; parent, rank, size;\n    int count;\n \npublic:\n    DSU(int n) : parent(n + 1), rank(n + 1, 0), size(n + 1, 1), count(n)\n    {\n        iota(all(parent), 0ll);\n    }\n \n    int find(int x)\n    {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    }\n \n    void merge(int i, int j)\n    {\n        int ri = find(i), rj = find(j);\n        if (ri == rj)\n        {\n            return;\n        }\n \n        if (rank[ri] &lt; rank[rj])\n        {\n            swap(ri, rj);\n        }\n        parent[rj] = ri;\n        size[ri] += size[rj];\n        if (rank[ri] == rank[rj])\n        {\n            rank[ri]++;\n        }\n        count--;\n    }\n \n    bool issame(int i, int j)\n    {\n        return find(i) == find(j);\n    }\n \n    int getsize(int x)\n    {\n        return size[find(x)];\n    }\n \n    int getgroups()\n    {\n        return count;\n    }\n};\n// DSU end\n \n// COMB 组合数 快速幂，乘法逆元 都在里面\nconst int N = 1e6;\nvector&lt;int&gt; f(N), invf(N);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n    int ans = 1;\n    while (exp)\n    {\n        if (exp &amp; 1)\n        {\n            ans = ans * base % MOD;\n        }\n        base = base * base % MOD;\n        exp &gt;&gt;= 1;\n    }\n    return ans;\n}\n \nint inv(int x)\n{\n    return ksm(x, MOD - 2) % MOD;\n}\n \nvoid pre()\n{\n    if (inited)\n    {\n        return;\n    }\n    inited = 1;\n    f[0] = 1;\n    for (int i = 1; i &lt; N; i++)\n    {\n        f[i] = f[i - 1] * i % MOD;\n    }\n \n    invf[N - 1] = inv(f[N - 1]);\n    for (int i = N - 2; i &gt;= 0; i--)\n    {\n        invf[i] = invf[i + 1] * (i + 1) % MOD;\n    }\n}\n \nint comb(int n, int k)\n{\n    if (!inited)\n    {\n        pre();\n    }\n    if (k &lt; 0 or k &gt; n)\n    {\n        return 0;\n    }\n \n    return f[n] * invf[k] % MOD * invf[n - k] % MOD;\n}\n// comb end ----\n \n// 马拉车\n \n// 预处理\nstring preprocess(const string &amp;s)\n{\n    string t = &quot;^&quot;;\n    for (char c : s)\n    {\n        t += &quot;#&quot; + string(1, c);\n    }\n    t += &quot;#$&quot;;\n    return t;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    string T = preprocess(s);\n    int n = T.size();\n    vector&lt;int&gt; P(n, 0); // P[i] 记录以 t[i] 为中心的回文半径\n    int C = 0, R = 0;    // C 是回文中心，R 是回文串的最右边界\n    for (size_t i = 1; i &lt; n - 1; i++)\n    {\n        // 确定对称位置\n        int Mirror = 2 * C - i;\n        if (i &lt; R)\n        {\n            P[i] = min(P[Mirror], R - i);\n        }\n        // 尝试扩展边界\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n        {\n            P[i]++;\n        }\n        // 如果当前回文串扩展超过了 R，更新中心和右边界\n        if (i + P[i] &gt; R)\n        {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    // 找到最长的回文子串\n    int maxLen = 0;\n    int Centerindex = 0;\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        if (P[i] &gt; maxLen)\n        {\n            maxLen = P[i];\n            Centerindex = i;\n        }\n    }\n    // 构造回文串\n    int start = (Centerindex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n \nsigned main()\n{\n    // ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n// end ---\n \n// BIT 树状数组\n \nclass BIT\n{\nprivate:\n    vector&lt;int&gt; c;\n    int n;\n \n    int lowbit(int x)\n    {\n        return x &amp; -x;\n    }\n \npublic:\n    BIT(int size) : n(size)\n    {\n        c.resize(n + 1, 0);\n    }\n \n    BIT(vector&lt;int&gt; &amp;arr) : n(arr.size())\n    {\n        c.resize(n + 1, 0);\n        for (int i = 1; i &lt;= n; i++)\n        {\n            add(i, arr[i - 1]);\n        }\n    }\n \n    void add(int i, int val)\n    {\n        while (i &lt;= n)\n        {\n            c[i] += val;\n            i += lowbit(i);\n        }\n    }\n \n    int sum(int i)\n    {\n        int ans = 0;\n        while (i)\n        {\n            ans += c[i];\n            i -= lowbit(i);\n        }\n        return ans;\n    }\n \n    int query(int l, int r)\n    {\n        return sum(r) - sum(l - 1);\n    }\n \n    int get(int i)\n    {\n        return query(i, i);\n    }\n \n    int update(int i, int val)\n    {\n        auto delta = val = get(i);\n        add(i, delta);\n    }\n \n    void clear()\n    {\n        fill(all(c), 0);\n    }\n \n    // 获取树状数组的大小\n    int size()\n    {\n        return n;\n    }\n};\n \n// BIT end\n \n// 大数模下幂运算\n \n// 快速幂函数，计算 base^exponent mod mod\nlong long modPow(long long base, long long exponent, long long mod)\n{\n    long long result = 1;\n    base %= mod;\n    while (exponent &gt; 0)\n    {\n        if (exponent &amp; 1)\n            result = (result * base) % mod;\n        base = (base * base) % mod;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n \nvoid solve()\n{\n    long long x, p;\n    string y;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;\n    // 对 x 取模（防止数字过大）\n    x %= p;\n    // 特判：若 y 为 &quot;0&quot;，根据数学通常规定 x^0 = 1（注意：0^0一般认为1也可以根据题意而定）\n    if (y == &quot;0&quot;)\n    {\n        cout &lt;&lt; 1 % p &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    // 答案初始为 1\n    long long ans = 1;\n    // 对指数 y 的每一位进行处理\n    for (char c : y)\n    {\n        int d = c - &#039;0&#039;;\n        // 将当前答案提升 10 次方后再乘上 x^d mod p\n        ans = modPow(ans, 10, p);\n        ans = (ans * modPow(x, d, p)) % p;\n    }\n    cout &lt;&lt; ans % p &lt;&lt; &quot;\\n&quot;;\n}\n \n// 大树模下 end ---\n \n// 很多DP\n \n// --------------------- 基础DP问题 ---------------------\n \n// 01背包问题 - 每个物品最多选一次\nint knapsack01(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = capacity; j &gt;= weights[i]; j--)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 完全背包问题 - 每个物品可以选无限次\nint knapsackComplete(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = weights[i]; j &lt;= capacity; j++)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 多重背包问题 - 每个物品有特定数量限制\nint knapsackMultiple(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values,\n                     const vector&lt;int&gt; &amp;counts, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        // 二进制优化 - 将k个物品拆成二进制表示\n        int w = weights[i], v = values[i], c = counts[i];\n        for (int k = 1; k &lt;= c; k *= 2)\n        {\n            for (int j = capacity; j &gt;= k * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - k * w] + k * v);\n            }\n            c -= k;\n        }\n \n        if (c &gt; 0)\n        {\n            for (int j = capacity; j &gt;= c * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - c * w] + c * v);\n            }\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 最长递增子序列 (LIS)\nint longestIncreasingSubsequence(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; dp(n, 1);\n \n    for (int i = 1; i &lt; n; i++)\n    {\n        for (int j = 0; j &lt; i; j++)\n        {\n            if (nums[i] &gt; nums[j])\n            {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n \n    return *max_element(dp.begin(), dp.end());\n}\n \n// 最长递增子序列优化版 (O(nlogn))\nint longestIncreasingSubsequenceOptimized(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; tails;\n \n    for (int num : nums)\n    {\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n        if (it == tails.end())\n        {\n            tails.push_back(num);\n        }\n        else\n        {\n            *it = num;\n        }\n    }\n \n    return tails.size();\n}\n \n// 最长公共子序列 (LCS)\nint longestCommonSubsequence(const string &amp;text1, const string &amp;text2)\n{\n    int m = text1.size(), n = text2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (text1[i - 1] == text2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }\n            else\n            {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// 编辑距离\nint editDistance(const string &amp;word1, const string &amp;word2)\n{\n    int m = word1.size(), n = word2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 0; i &lt;= m; i++)\n        dp[i][0] = i;\n    for (int j = 0; j &lt;= n; j++)\n        dp[0][j] = j;\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (word1[i - 1] == word2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else\n            {\n                dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// --------------------- 区间DP ---------------------\n \n// 石子合并问题 - 求合并代价最小值\nint mergeStones(const vector&lt;int&gt; &amp;stones)\n{\n    int n = stones.size();\n    if (n &lt;= 1)\n        return 0;\n \n    // 前缀和加速区间求和\n    vector&lt;int&gt; prefixSum(n + 1, 0);\n    for (int i = 0; i &lt; n; i++)\n    {\n        prefixSum[i + 1] = prefixSum[i] + stones[i];\n    }\n \n    // dp[i][j] 表示合并区间[i,j]的最小代价\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INF));\n \n    // 初始化：单个石子无需合并\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = 0;\n    }\n \n    // 按区间长度递推\n    for (int len = 2; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n \n            // 尝试在不同位置分割\n            for (int k = i; k &lt; j; k++)\n            {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefixSum[j + 1] - prefixSum[i]);\n            }\n        }\n    }\n \n    return dp[0][n - 1];\n}\n \n// --------------------- 树形DP ---------------------\n \n// 树的最大独立集 (在树上选择不相邻的节点使得权值和最大)\nvoid dfsIndependentSet(int node, int parent, const vector&lt;vector&lt;int&gt;&gt; &amp;tree,\n                       const vector&lt;int&gt; &amp;values, vector&lt;vector&lt;int&gt;&gt; &amp;dp)\n{\n    for (int child : tree[node])\n    {\n        if (child != parent)\n        {\n            dfsIndependentSet(child, node, tree, values, dp);\n            // dp[node][0] - 不选当前节点\n            dp[node][0] += max(dp[child][0], dp[child][1]);\n            // dp[node][1] - 选当前节点\n            dp[node][1] += dp[child][0];\n        }\n    }\n    dp[node][1] += values[node]; // 加上当前节点的权值\n}\n \nint maxIndependentSet(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, const vector&lt;int&gt; &amp;values)\n{\n    int n = values.size();\n    // dp[i][0] - 不选节点i的最大值, dp[i][1] - 选节点i的最大值\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));\n \n    dfsIndependentSet(0, -1, tree, values, dp);\n    return max(dp[0][0], dp[0][1]);\n}\n \n// --------------------- 状态压缩DP ---------------------\n \n// 旅行商问题 (TSP)\nint tsp(const vector&lt;vector&lt;int&gt;&gt; &amp;dist)\n{\n    int n = dist.size();\n    // dp[mask][i] 表示已经访问的城市集合为mask，当前在城市i的最短路径\n    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; n, vector&lt;int&gt;(n, INF));\n \n    // 起点为城市0\n    dp[1][0] = 0; // 只访问城市0的状态\n \n    for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++)\n    {\n        for (int i = 0; i &lt; n; i++)\n        {\n            if ((mask &gt;&gt; i) &amp; 1)\n            { // 城市i已访问\n                for (int j = 0; j &lt; n; j++)\n                {\n                    if ((mask &gt;&gt; j) &amp; 1 &amp;&amp; i != j)\n                    { // 城市j也已访问\n                        dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 &lt;&lt; i)][j] + dist[j][i]);\n                    }\n                }\n            }\n        }\n    }\n \n    // 所有城市都访问并回到起点\n    int result = INF;\n    for (int i = 1; i &lt; n; i++)\n    {\n        if (dist[i][0] != INF)\n        {\n            result = min(result, dp[(1 &lt;&lt; n) - 1][i] + dist[i][0]);\n        }\n    }\n \n    return result;\n}\n \n// --------------------- 数位DP ---------------------\n \n// 计算区间[l,r]中满足条件的数字个数\nint digitDP(int l, int r)\n{\n    vector&lt;int&gt; digits;\n \n    // 数位分解函数\n    auto getDigits = [&amp;](int num)\n    {\n        vector&lt;int&gt; result;\n        while (num)\n        {\n            result.push_back(num % 10);\n            num /= 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    };\n \n    // DP函数，自行定义状态和转移方程\n    function&lt;int(int, bool, bool, int)&gt; dp = [&amp;](int pos, bool isLimit, bool isNum, int state)\n    {\n        // 实现特定问题的状态转移逻辑\n        // pos: 当前处理到的位置\n        // isLimit: 是否有上界限制\n        // isNum: 前面是否已经有数字了\n        // state: 问题相关的状态\n \n        if (pos == digits.size())\n        {\n            return isNum ? 1 : 0; // 根据具体问题调整返回值\n        }\n \n        // 这里补充具体问题的状态转移逻辑\n \n        return 0; // 占位返回\n    };\n \n    // 计算[0,r]的结果\n    digits = getDigits(r);\n    int right_result = dp(0, true, false, 0);\n \n    // 计算[0,l-1]的结果\n    digits = getDigits(l - 1);\n    int left_result = dp(0, true, false, 0);\n \n    // 返回区间结果\n    return right_result - left_result;\n}\n \n// --------------------- 概率DP ---------------------\n \n// 骰子问题 - 投掷n个骰子，点数和为target的概率\ndouble diceProb(int n, int target)\n{\n    if (target &lt; n || target &gt; 6 * n)\n        return 0.0;\n \n    vector&lt;vector&lt;double&gt;&gt; dp(n + 1, vector&lt;double&gt;(6 * n + 1, 0.0));\n    // 初始化：一个骰子\n    for (int i = 1; i &lt;= 6; i++)\n    {\n        dp[1][i] = 1.0 / 6.0;\n    }\n \n    for (int i = 2; i &lt;= n; i++)\n    {\n        for (int j = i; j &lt;= 6 * i; j++)\n        {\n            for (int k = 1; k &lt;= 6 &amp;&amp; k &lt; j; k++)\n            {\n                dp[i][j] += dp[i - 1][j - k] * (1.0 / 6.0);\n            }\n        }\n    }\n \n    return dp[n][target];\n}\n \n// --------------------- 实用DP子问题 ---------------------\n \n// 最大子序和 (Kadane算法)\nint maxSubArray(const vector&lt;int&gt; &amp;nums)\n{\n    int currMax = nums[0], globalMax = nums[0];\n \n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        currMax = max(nums[i], currMax + nums[i]);\n        globalMax = max(globalMax, currMax);\n    }\n \n    return globalMax;\n}\n \n// 最大子矩阵和\nint maxSubMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    if (matrix.empty() || matrix[0].empty())\n        return 0;\n \n    int rows = matrix.size(), cols = matrix[0].size();\n    int result = INT_MIN;\n \n    for (int left = 0; left &lt; cols; left++)\n    {\n        vector&lt;int&gt; tempSum(rows, 0);\n \n        for (int right = left; right &lt; cols; right++)\n        {\n            // 将二维问题转化为一维\n            for (int i = 0; i &lt; rows; i++)\n            {\n                tempSum[i] += matrix[i][right];\n            }\n \n            // 应用Kadane算法找一维最大子序和\n            int kadaneMax = tempSum[0];\n            int currMax = tempSum[0];\n \n            for (int i = 1; i &lt; rows; i++)\n            {\n                currMax = max(tempSum[i], currMax + tempSum[i]);\n                kadaneMax = max(kadaneMax, currMax);\n            }\n \n            result = max(result, kadaneMax);\n        }\n    }\n \n    return result;\n}\n \n// 最长回文子串\nstring longestPalindrome(const string &amp;s)\n{\n    int n = s.size();\n    if (n == 0)\n        return &quot;&quot;;\n \n    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));\n    int start = 0, maxLen = 1;\n \n    // 所有长度为1的子串都是回文\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = true;\n    }\n \n    // 检查长度为2的子串\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (s[i] == s[i + 1])\n        {\n            dp[i][i + 1] = true;\n            start = i;\n            maxLen = 2;\n        }\n    }\n \n    // 检查长度大于2的子串\n    for (int len = 3; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n            if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1])\n            {\n                dp[i][j] = true;\n                start = i;\n                maxLen = len;\n            }\n        }\n    }\n \n    return s.substr(start, maxLen);\n}\n// 很多DP end\n \n// 拓扑\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj; // 邻接表\n    vector&lt;int&gt; indegree(n, 0);          // 统计入度\n    vector&lt;int&gt; result;                  // 结果集合\n    int s, t;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t;\n        indegree[t]++;\n        adj[s].push_back(t);\n    }\n \n    queue&lt;int&gt; que;\n    for (int i = 0; i &lt; n; i++)\n    {\n        // 入度为0 可以作为开头 加入队列\n        if (!indegree[i])\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    if (result.size() - n)\n    {\n        cout &lt;&lt; -1;\n    }\n    else\n    {\n        cout &lt;&lt; result;\n    }\n}\n// 拓扑end\n \n// 生成树 kru\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    struct Edge\n    {\n        int v1, v2, val;\n        Edge(int v1, int v2, int val) : v1(v1), v2(v2), val(val) {};\n    };\n    vector&lt;Edge&gt; edges;\n \n    int v1, v2, val;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        auto [a, b] = minmax(v1, v2);\n        edges.emplace_back(a, b, val);\n    }\n    ranges::sort(edges, [](Edge &amp;a, Edge &amp;b)\n                 { return a.val &lt; b.val; });\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n + 1);\n        iota(father.begin(), father.end(), 0ll);\n    };\n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : ffind(father[i]);\n    };\n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n    // FU end\n    init(n);\n \n    int MSTweight = 0, MSTnode = 0;\n \n    for (auto &amp;&amp;[v1, v2, val] : edges)\n    {\n        if (!issame(v1, v2))\n        {\n            funion(v1, v2);\n            MSTweight += val;\n            MSTnode++;\n        }\n        if (MSTnode == n - 1)\n        {\n            cout &lt;&lt; MSTnode;\n            return;\n        }\n    }\n    cout &lt;&lt; -1;\n    return;\n}\n// 生成树 kru end\n \n// 生成树 prim\nvoid solve()\n{\n    int v, e;\n    cin &gt;&gt; v &gt;&gt; e;\n    int vsz = v + 1;\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(vsz + 1);\n    int v1, v2, val;\n    while (e--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    // prim begin\n    vector&lt;int&gt; visited(vsz, 0), minDist(vsz, INFLL);\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;\n \n    minDist[1] = 0;\n    pq.push({0, 1});\n \n    int totalweight = 0, nodeInMST = 0;\n \n    while (pq.size())\n    {\n        auto [w, cur] = pq.top();\n        pq.pop();\n \n        if (visited[cur])\n        {\n            continue;\n        }\n \n        visited[cur] = 1;\n        totalweight += w;\n        nodeInMST++;\n \n        for (auto &amp;&amp;[next, nextw] : adj[cur])\n        {\n            if (visited[next])\n            {\n                continue;\n            }\n \n            if (nextw &lt; minDist[next])\n            {\n                minDist[next] = nextw;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n    if (nodeInMST != v)\n    {\n        cout &lt;&lt; -1;\n        return;\n    }\n    cout &lt;&lt; totalweight;\n}\n// prim end\n \n// ford 可以处理负环\nvoid solve()\n{\n    int n, m, s, t, v;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;\n        adj[s][t] = v;\n    }\n \n    vector&lt;int&gt; minDist(n + 1, INF);\n    minDist[1] = 0;\n \n    int _ = n - 1;\n    while (_--) //\n    {\n        for (auto &amp;&amp;[v1, v] : adj)\n        {\n            for (auto &amp;&amp;[v2, val] : v)\n            {\n                if (minDist[v1] != INF)\n                {\n                    minDist[v2] = min(minDist[v2], minDist[v1] + val);\n                }\n            }\n        }\n    }\n \n    if (minDist[n] == INF)\n    {\n        cout &lt;&lt; &quot;unconnected&quot;;\n    }\n    else\n    {\n        cout &lt;&lt; minDist[n];\n    }\n}\n// ford end\n \n// dijk\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表，pair&lt;节点, 距离&gt;\n    int s, e, v;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;\n        adj[s].push_back({e, v});\n    }\n \n    /*\n    堆优化版Dijkstra算法:\n    1. 使用优先队列维护当前所有可达但未访问的节点，按距离排序\n    2. 每次取出队列中距离最小的节点，标记为已访问\n    3. 更新该节点邻居的距离，并将新的可能路径加入队列\n    */\n \n    vector&lt;int&gt; minDist(n + 1, INT_MAX); // 每一个节点到源点的最小距离\n    vector&lt;bool&gt; visited(n + 1, false);  // 记录节点是否已被访问\n \n    int start = 1, en = n;\n    minDist[start] = 0;\n \n    // 优先队列，存储&lt;距离, 节点编号&gt;，按距离从小到大排序\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n    pq.push({0, start});\n \n    while (!pq.empty())\n    {\n        int dist = pq.top().first;\n        int cur = pq.top().second;\n        pq.pop();\n \n        if (visited[cur])\n            continue;        // 如果已经访问过，跳过\n        visited[cur] = true; // 标记为已访问\n \n        // 更新当前节点的所有邻居\n        for (const auto &amp;edge : adj[cur])\n        {\n            int next = edge.first;\n            int weight = edge.second;\n \n            if (!visited[next] &amp;&amp; minDist[cur] + weight &lt; minDist[next])\n            {\n                minDist[next] = minDist[cur] + weight;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n \n    cout &lt;&lt; (minDist[en] == INT_MAX ? -1 : minDist[en]);\n}\n// dijk end\n \n// 多源最短路 floyd\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector v(n + 1, vector&lt;int&gt;(n + 1, INT_MAX));\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            cin &gt;&gt; v[i][j];\n        }\n    }\n \n    // floyd\n    for (int k = 1; k &lt;= n; k++)\n    {\n        for (int i = 1; i &lt;= n; i++)\n        {\n            for (int j = 1; j &lt;= n; j++)\n            {\n                v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n            }\n        }\n    }\n}\n// flyd end\n"},"对暴搜的研究/数论/EXGCD":{"slug":"对暴搜的研究/数论/EXGCD","filePath":"对暴搜的研究/数论/EXGCD.md","title":"EXGCD","links":[],"tags":[],"content":"扩展欧几里得算法（ExGCD）\n常见考查场景：\n\n求解线性不定方程（Diophantine Equation）。\n解决线性同余方程。\n在中国剩余定理（CRT）中合并方程时计算逆元。\n需要找出贝祖系数来表示 gcd 的线性组合。\n\n典型题目与分析\n\n\n线性不定方程求解\n\n题目描述：给定 a、b 和 c，判断方程ax + by = c是否有整数解，并输出其中一组解。\n考查点：先用 exgcd 求 \\gcd(a,b) ，再判断 c 是否为其倍数。\n分析：如果 ccc 能被 \\gcd(a,b) 整除，则将 exgcd 得到的基本解乘以c/\\gcd(a,b) 即为解。重点在于参数的调整。\n\n\n\n求解模线性方程\n\n题目描述：求解同余方程ax \\equiv c \\ (\\bmod\\ m) 的所有解。\n考查点：判断 \\gcd(a,m) 是否整除 c ；若可解，利用 exgcd 求出基本解，再写出通解形式。\n分析：考查对同余方程解的参数描述和解集刻画。\n\n\n\n求最小非负解\n\n题目描述：在方程 x + by = c 或同余 ax \\equiv b \\ (\\bmod\\ m) 中，要求输出满足某个变量最小非负的解。\n考查点：得到基本解后，通过加减模的周期（或平移参数）调整到非负区域。\n分析：需要灵活应用 exgcd 得到的通解形式，并利用模运算找到最优解。\n\n\n\n鸡兔同笼（或硬币问题）\n\n题目描述：经典问题：鸡和兔子总数和总脚数已知，求鸡和兔子的数量。\n考查点：将问题转化为 2x + 4y = n 的线性方程，并用 exgcd 求解。\n分析：先判断方程可解性，然后找到基本解，再根据问题约束（非负整数）筛选合适的解。\n\n\n\n中国剩余定理（CRT）的实现\n\n题目描述：给定一组同余方程，求一个最小正整数满足所有方程。\n考查点：在每一步合并两个同余方程时，用 exgcd 计算模逆元来构造合并公式。\n分析：考查对 exgcd 在 CRT 算法中作用的理解，重点在于正确处理模数不互质情况（通常题目保证互质）。\n\n\n"},"对暴搜的研究/数论/GCD":{"slug":"对暴搜的研究/数论/GCD","filePath":"对暴搜的研究/数论/GCD.md","title":"GCD","links":[],"tags":[],"content":"int gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n典型题目与分析\n\n\n基础 GCD 题目\n\n题目描述：给定两个整数 a 和 b，求它们的最大公约数。\n考查点：直接使用欧几里得算法。\n分析：这是最简单的数论题，考查递归或迭代实现欧几里得算法，时间复杂度 O(\\log \\min(a,b))。\n\n\n\nGCD 与 LCM 的关系\n\n题目描述：给定两个数，要求同时输出它们的最大公约数和最小公倍数。\n考查点：利用公式  \\text{lcm}(a,b) = \\frac{a \\times b}{\\gcd(a,b)}；同时检验对大数运算和溢出问题的处理。\n分析：先求 gcd，再计算 lcm。注意要用长整型防止乘法溢出。\n\n\n\n数组全局 GCD\n\n题目描述：给定一个数组，求数组中所有元素的 gcd。\n考查点：迭代计算多个数的 gcd。\n分析：从数组左边第一个元素开始，依次计算 \\text{gcd}(res, a[i])，时间复杂度  O(n \\log M)（M 为元素上界）。\n\n\n\n区间 GCD 查询\n\n题目描述：给定一个数组和多个区间查询，每个查询询问区间内所有数的 gcd。\n考查点：数据结构与数论结合，如用线段树或稀疏表实现区间 gcd 查询。\n分析：预处理时间 O(n\\log n)，每个查询O(\\log n)（或 O(1) 的稀疏表版本），适合在线查询问题。\n\n\n\nGCD 累加问题（GCD Sum）\n\n题目描述：求数组中所有满足 i &lt; j 的数对(a_i, a_j) 的 gcd 之和。\n考查点：数论求和技巧和分解思路，有时需要反过来统计每个数作为 gcd 的贡献。\n分析：直接枚举会超时，通常需要利用筛法或反向思考“对每个可能的公因子统计贡献”，考查对数论性质的深入理解。\n\n\n\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\t// 统计每个因子的频率\n\tmap&lt;int, int&gt; mp;\n\tvector&lt;int&gt; v(n);\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; v[i];\n\t\tmp[v[i]]++;\t\n\t}\n \n\t// 对每个d 查看数组中有多少个数字 使得d是其因数\n\tmap&lt;int, int&gt; d;\n\tfor (int i = 1; i &lt;= ranges::max(v); i++)\n\t{\n\t\tfor (int j = i; j &lt;= ranges::max(v); j += i)\n\t\t{\n\t\t\td[i] += mp[j];\n\t\t}\n\t}\n\tint ans = 0;\n\t// 从大到小计算答案 用容斥原理扣除更大因子的贡献\n\tmap&lt;int, int&gt; f;\n\tfor (int i = ranges::max(v); i &gt;= 1; i--)\n\t{\n\t\tauto pr = d[i] * (d[i] - 1) / 2;\n\t\tfor (int k = 2; k * i &lt;= ranges::max(v); k++)\n\t\t{\n\t\t\tpr -= f[k * i];\n\t\t}\n\t\tans += i * pr;\n\t\tf[i] = pr;\n\t}\n\tcout &lt;&lt; ans;\n}"},"对暴搜的研究/组合数板子":{"slug":"对暴搜的研究/组合数板子","filePath":"对暴搜的研究/组合数板子.md","title":"组合数板子","links":[],"tags":[],"content":"const int MAXN = 1e7;\nconst int MOD = 1e9 + 7;\n \nvector&lt;int&gt; fact(MAXN), invfact(MAXN);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n\tint ans = 1;\n\twhile (exp)\n\t{\n\t\tif (exp &amp; 1)\n\t\t{\n\t\t\tans = ans * base % MOD;\n\t\t}\n\t\tbase = base * base % MOD;\n\t\texp &gt;&gt;= 1;\n\t}\n\treturn ans;\n}\n \nint inv(int x)\n{\n\treturn ksm(x, MOD - 2);\n}\n \nvoid pre()\n{\n\tif (inited) return;\n\tinited = 1;\n\tfact[0] = 1;\n\tfor (int i = 1; i &lt; MAXN; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t}\n \n\tinvfact[MAXN - 1] = inv(fact[MAXN - 1]);\n\tfor (int i = MAXN - 2; i &gt;= 0; i--)\n\t{\n\t\tinvfact[i] = invfact[i + 1] * (i + 1) % MOD;\n\t}\n}\n \nint comb(int n, int k)\n{\n\tif (!inited) pre();\n\tif (k &lt; 0 or k &gt; n) return 0;\n\treturn fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}"},"对暴搜的研究/贪心套路/P1":{"slug":"对暴搜的研究/贪心套路/P1","filePath":"对暴搜的研究/贪心套路/P1.md","title":"P1","links":["对暴搜的研究/贪心套路/P2"],"tags":[],"content":"题目1\n题目1\n题目1\n题目1\n题目1\n题目1\nP2"},"对暴搜的研究/贪心套路/P2":{"slug":"对暴搜的研究/贪心套路/P2","filePath":"对暴搜的研究/贪心套路/P2.md","title":"P2","links":["模下快速幂","对暴搜的研究/贪心套路/P3"],"tags":[],"content":"题目1\n现需要将一根长为正整数n的竹子砍为若干段\n每段长度均为正整数\n请返回每段竹子长度的最大乘积是多少\n答案需要对1000000007取模\n前置知识：模下快速幂\n观察得到：\nn = 4 -&gt; 2 * 2 -&gt; 4 % 3 = 1\nn = 5 -&gt; 3 * 2 -&gt; 5 % 3 = 2\nn = 6 -&gt; 2 * 2 -&gt; 6 % 3 = 0\nn = 7 -&gt; 3 * 2 * 2 -&gt; 7 % 3 = 1\nn = 8 -&gt; 3 * 3 * 2 -&gt; 8 % 3 = 2\nn = 9 -&gt; 3 * 3 * 3 -&gt; 9 % 3 = 0\n \n进而\nn &lt;= 3 特判\nn &gt; 3 时\nif (n % 3 == 0)\n{\n\treturn quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 1)\n{\n\tn -= 4;\n\treturn 4 * quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 2)\n{\n\tn -= 2;\n\treturn 2 * quickmod(3, n / 3, mod) % mod;\n}\n \n也可以这么写：\nauto tail = n % 3 == 0 ? 1 : (n % 3 == 1 ? 4 : 2);\nauto power = tail == 1 ? n : (n - tail) / 3;\nreturn quickmod(3, power, mod) * tail % mod;\n题目2\n一个数字n一定要分成k份 得到的乘积最大是多少\n数字n 和 k 有可能到达{10}^{12}\n结果需要对 1e9 + 7 取模\n先计算平均值 再算多多少\nint n, k, mod = 1e9 + 7;\ncin &gt;&gt; n &gt;&gt; k;\nauto a = n / k;\nauto b = n % k;\nauto ans1 = quickmod(a + 1, b, mod);\nauto ans2 = quickmod(a, k - b, mod);\nreturn ans1 * ans2 % mod;\n题目3\n给若干会议的开始，结束时间\n参加某个会议的期间 不能参加其他会议\n返回能参加的最大会议数量\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[v1, v2] : v)\n{\n\tcin &gt;&gt; v1 &gt;&gt; v2;\n}\n \n// 贪心策略 结束时间早的早排\nranges::sort(v, [](auto &amp;v1, auto &amp;v2) { return v1.second &lt; v1.second; });\nint ans = 1;\nauto [beg, en] = v[0];\nfor (int i = 1; i &lt; n; i++)\n{\n\tauto [curbe, curen] = v[i];\n\tif (curbe &gt;= en)\n\t{\n\t\ten = curen;\n\t\tans++;\n\t}\n}\nreturn ans;\n题目4\n给定若干会议的开始，结束时间\n任何会议的召开期间 你只需要抽出一天来参加\n但是 同一天只能参加一个会议\n返回你能参加的最大会议数量\n\n思路：\n等价于牛客寒假H\n两种做法 一种是维护一个小根堆 一种是集合 + 二分\n\n二分做法\nint n, ans = 0, last = -1;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[a, b] : v) cin &gt;&gt; a &gt;&gt; b; last = max(last, b);\nranges::sort(v, [](auto &amp;&amp;v1, auto &amp;&amp;v2)\n{\n\tauto [a, b] = v1, [c, d] = v2;\n\treturn a == c ? b &lt; d : a &lt; c;\t\n});\nset&lt;int&gt; st;\nfor (int i = 1; i &lt;= last; i++) st.insert(i);\n \nfor (auto &amp;&amp;[a, b] : v)\n{\n\tauto it = st.lower_bound(a);\n\tif (it != st.end() and *it &lt;= r)\n\t{\n\t\tans++;\n\t\tst.erase(*it);\n\t}\n}\n \ncout &lt;&lt; ans;\n小根堆做法：\nint n, ans = 0;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nmap&lt;int, vector&lt;int&gt;&gt; mp;\nfor (auto &amp;&amp;[a, b] : v) \n{\n\tcin &gt;&gt; a &gt;&gt; b;\n\tmp[a].emplace_back(b);\n}\n \npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nint index = 1;\nfor (auto &amp;&amp;i : mp[index]) pq.push(i);\nwhile (pq.size())\n{\n\twhile (pq.size() and pq.top() &lt; index) pq.pop();\n\tif (!pq.empty()) \n\t{\n\t\tpq.pop();\n\t\tans++;\n\t\tindex++;\n\t\tfor (auto &amp;&amp;i : mp[index]) pq.push(i);\n\t}\n}\ncout &lt;&lt; ans;\n题目5\n给你n个项目，对于每一个项目i\n有一个纯利润prefits[i] 和启动该项目需要的最小资本 capital[i]\n最初你的资本是w 完成一个项目的时候你将获得纯利润 添加到你的总资本中\n从给定项目中选择最多k个不同项目的列表 最大化你的最终资本ans\nint n, w, k; \ncin &gt;&gt; n &gt;&gt; w &gt;&gt; k; \nvector&lt;pair&lt;int, int&gt;&gt; projects(n); // pair&lt;capital, profit&gt; \nfor (int i = 0; i &lt; n; i++) \n{ \n\tcin &gt;&gt; projects[i].second; // profit \n} \nfor (int i = 0; i &lt; n; i++) \n{\n\tcin &gt;&gt; projects[i].first; // capital \n} \n// 按启动资本排序\nranges::sort(projects);\n// 优先队列保存利润，默认是大顶堆 \npriority_queue&lt;int&gt; pq; \nint index = 0; \nfor (int i = 0; i &lt; k; i++) \n{ \n\t// 将所有启动资本小于等于当前资金的项目加入优先队列 \n\twhile (index &lt; n &amp;&amp; projects[index].first &lt;= w) \n\t{ \n\t\tpq.push(projects[index].second); \n\t\tindex++; \n\t} \n\t// 如果没有可做的项目，则退出 \n\tif (pq.empty()) break; \n\t// 选择当前利润最大的项目 \n\tw += pq.top(); \n\tpq.pop(); \n} \ncout &lt;&lt; w;\n题目6\n给定一个非负数组v 计算任何两个数差值的绝对值\n如果v中没有 将绝对值加入到v里 但是只加入一次\n直到arr大小固定 返回最终长度\n结论：求出这个数组中所有数字的gcd 记为num\n这个数组中所有数字的最大值 记为max\n那么\nfor (int i = num; i &lt;= max; i += num) // 所有的i都会在这个数组中\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n;i ++) \n{\n\tcin &gt;&gt; v[i];\n\tmp[v[i]]++;\n}\nint ans = n, num = gcd(v[0], v[1]);\nfor (int i = 2; i &lt; n; i++) num = gcd(num, v[i]);\n// 现在num是所有数字的最大公约数\nint maxnum = ranges::max(v);\nfor (int i = num; i &lt;= max; i += num) ans += (mp.count(i) == 0);\ncout &lt;&lt; ans;\nP3"},"对暴搜的研究/贪心套路/P3":{"slug":"对暴搜的研究/贪心套路/P3","filePath":"对暴搜的研究/贪心套路/P3.md","title":"P3","links":["对暴搜的研究/贪心套路/P4"],"tags":[],"content":"题目1\n给一个整数数组nums 需要找出一个连续子数组\r\n如果对这个子数组进行升序排序 那么整个数组都会变成升序排序\r\n请你找出这个最小的连续子数组\n// 这个空着不写 看下次能不能想起来\n题目2\n给很多个有序数组 返回一个长度最小的区间 [a, b] 使得每一个数组中都有一个数字在这个区间中\n用一个最小堆维护最小值 最大堆维护最大值\n题目3\n组团买票\r\n景区里一共有m个项目，景区的第i个项目有如下两个参数：\r\ngame[i] = { Ki, Bi }，Ki、Bi一定是正数\r\nKi代表折扣系数，Bi代表票价，举个例子 : Ki = 2, Bi = 10\r\n如果只有1个人买票，单张门票的价格为 : Bi - Ki * 1 = 8\r\n所以这1个人游玩该项目要花8元\r\n如果有2个人买票，单张门票的价格为 : Bi - Ki * 2 = 6\r\n所以这2个人游玩该项目要花6 * 2 = 12元\r\n如果有5个人买票，单张门票的价格为 : Bi - Ki * 5 = 0\r\n所以这5个人游玩该项目要花5 * 0 = 0元\r\n如果有更多人买票，都认为花0元(因为让项目倒贴钱实在是太操蛋了)\r\n于是可以认为，如果有x个人买票，单张门票的价格为 : Bi - Ki * x\r\nx个人游玩这个项目的总花费是 : max { x * (Bi - Ki * x), 0 }\r\n单位一共有n个人，每个人最多可以选1个项目来游玩，也可以不选任何项目，由你去按照上面的规则，统一花钱购票\r\n你想知道自己需要准备多少钱，就可以应付所有可能的情况，返回这个最保险的钱数\r\n1 &lt;= M、N、Ki、Bi &lt;= 10^5\n\n其实就是要找出景区公园赚最多钱的情况\n\n如何让公园最赚钱？\r\n我们只需要把人 挨个送到最赚钱的项目去\r\n如何统计这个指标？\r\n假设现在来了a人 每个人要付的钱就是b - k * a\r\n现在又来了一个 每个人要付的钱就变成了 b - k * (a + 1) - k * a\n题目4\n平均值最小累加和\r\n给定数组v 长度为n 需要从中划分出 k 组\r\n返回每组的平均值累加起来的 最小值\n\n思路：\r\n其实就是把前k - 1 个数单独放一组， 剩下的n - k + 1 个大数字求平均值 然后累加\n\n题目5\n执行所有任务的最少初始电量\r\n每一个任务有两个参数，需要耗费的电量 a 、至少多少电量才能开始这个任务 b\r\n返回手机至少需要多少的初始电量，才能执行完所有的任务\r\n现在是m m 需要 &gt;= b 执行完任务之后变成m - a\n\n结论：耗费 - 至少的差值越小 越先进行; 耗费 - 至少的差值越大 越先倒推\n\n题目6\n两个0和1数量相等区间的最大长度\r\n给出一个长度为n的01串，现在请你找到两个区间\r\n使得这两个区间中，1的个数相等，0的个数也相等\r\n这两个区间可以相交，但是不可以完全重叠，即两个区间的左右端点不可以完全一样\r\n现在请你找到两个最长的区间，满足以上要求\r\n返回区间最大长度\n011010 的两个区间 分别是 01101 11010\n\n可能性1 找到区间最左侧 最右侧 的0\n可能性2 找到区间最左侧 最右侧 的1\n两者求最大值即可\n\nP4"},"对暴搜的研究/贪心套路/P4":{"slug":"对暴搜的研究/贪心套路/P4","filePath":"对暴搜的研究/贪心套路/P4.md","title":"P4","links":["对暴搜的研究/贪心套路/P5"],"tags":[],"content":"题目1\n给你一个数组 对于其中的奇数 你可以让他*＝ 2 对于其中的偶数 你可以让他 /= 2 记这个数组最大值与最小值之差为 偏移量 返回偏移量的最小值\n\n思路：\n对于所有的奇数 我们可以先 *＝ 2 让它获得被除的机会 接下来 我们只需要用multiset 维护这个数组 然后不断对最大值除以二 并记录偏移量即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nmultiset&lt;int&gt; mst;\nfor (int i = 0; i &lt; n; i++)\n{\n\tif (v[i] &amp; 1) v[i] *= 2;\n\tmst.insert(v[i]);\n}\n \nint ans = *mst.rbebin() - *mst.begin();\nwhile (*mst.rbegin() % 2 == 0)\n{\n\tauto num = *mst.rbegin();\n\tmst.erase(num);\n\tnum /= 2;\n\tmst.insert(num);\n\tans = min(ans, *mst.rbebin() - *mst.begin());\n}\ncout &lt;&lt; ans;\n题目2\n森林中有很多只兔子 你问了一些兔子”有几只兔子跟你颜色相同？” 兔子们的回答绝对真实 但是你可能只问了一部分兔子 现在你得到了兔子们的回答answer 求森林中至少有多少只兔子\n\n思路：\n对于所有回答一样的兔子，对他们分组 每n + 1 只兔子分为一组，最后乘n + 1 就得到了答案\n\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nwhile (n--)\n{\n\tint num;\n\tcin &gt;&gt; num;\n\tmp[num]++;\n}\n \nint ans = 0;\n \nfor (auto &amp;&amp;[k, v] : mp)\n{\n\t// 每n + 1只分为一组 也就是总数 / n + 1 向上取整\n\tauto a = (v + (k + 1) - 1) / (k + 1);\n\tans += a * (k + 1);\n}\n \ncout &lt;&lt; ans;\n\n总结：\n向上取整的操作通常应用于对某个目标分组，比如\n现在有七十个学生，每辆车最多可以垃50个 请问一共需要用几辆车\n这种时候分组策略就是总数 / 分组依据 然后向上取整\n也就是ans = (a + b - 1) / b\n\n题目3\n给定两个数组nums和target 你可以对nums的任意两个元素作变换（其中一个+= 2 另外一个-= 2 返回你要操作多少次才能使得这两个数组相等 （可以证明一定存在相等策略\n\n思路：这道题的简化背景其实是 给两个数组 可以对其中一个的任意元素增减 返回使得这两个数组元素相等的最小操作次数\n对两个数组都排序，就显而易见的得出答案了\n\n那么对于这一题 我们需要注意到，每次增加减少2 不会改变他们的奇偶性——所以我们应该对奇偶性分组\n分组之后 我们直接记录变换次数然后除以二即可\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n), t(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; t[i];\n \nauto change = [&amp;](vector&lt;int&gt; &amp;v) -&gt; void\n{\n\tvector&lt;int&gt; odd, even;\n\tfor (int i = 0; i &lt; n; i++)\n\t{\n\t\tif (v[i] &amp; 1)\n\t\t{\n\t\t\todd.emplace_back(v[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\teven.emplace_back(v[i]);\n\t\t}\n\t}\n\tranges::sort(odd);\n\tranges::sort(even);\n\todd.insert(odd.end(), all(even));\n\tv = odd;\n};\n \nchange(v);\nchange(t);\n \nint ans = 0;\nfor (int i = 0; i &lt; n; i++) ans += abs(v[i] - t[i]) / 2;\ncout &lt;&lt; ans / 2;\n\n总结：\n下次遇到增减2的时候 要注意这不会改变奇偶性\n\n题目4\n部门要挑选两个员工去参加竞赛，每一个员工有a b 两个指标 部门会把两个员工的两个指标分别取平均值得到A B 求min(A,B)的最大值\n\n思路：\nn^2 的思路是容易想到的，但是我们不允许这样的复杂度 在此基础上 我们应当保证尽可能取消内层循环\n我们应当使用abs(a_1 - b_1) &lt; abs(a_2 - b_2) 来sort 这样一来 我们有：\n对于任意 v[i] (abs(a - b) == k) 它前面的所有a和b一定满足abs(a - b) ⇐ k 也就是说 相加之后不会改变min所在的位置\n因此 我们直接设置两个变量记录最大值最小值即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].first &gt;&gt; v[i].second;\nranges::sort(v, [](auto a, auto b) { \nreturn abs(a.first - a.second &lt; b.first - b.second;) });\n \nint max1 = a.first, max2 = a.second, ans = 0;\nfor (int i = 1; i &lt; n; i++)\n{\n\tans = min(v[i].first + max1, v[i].second + max2);\n\tmax1 = max(max1, v[i].first);\n\tmax2 = max(max2, v[i].second);\n}\ncout &lt;&lt; ans * 0.1 / 2;\n题目5\n题目6\nP5"},"对暴搜的研究/贪心套路/P5":{"slug":"对暴搜的研究/贪心套路/P5","filePath":"对暴搜的研究/贪心套路/P5.md","title":"P5","links":[],"tags":[],"content":"题目1\n跳跃游戏ii\r\n给你一个数组v v[i] 表示从i开始最多能跳几格，求到达n - 1下标的最少次数\n\n思路：\r\n我们设置一个变量right 来维护当前跳跃的范围，endd来维护当前可以到达的最大格子，ans 来记录答案\n\n操作过程如下：\n\n每走到一个新的格子 判断当前格子在不在跳跃可达的范围内，如果不行的话 说明需要一次额外的跳跃，此时ans++, right = endd\n每走到一个新的格子 更新end = max(end, i + v[i])\r\n代码：\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\n \nint ans = 0, right = 0, endd = 0;\nfor (int i = 0 ; i &lt; n; i++)\n{\n\tendd = max(endd, i + v[i]);\n\tif (i == right)\n\t{\n\t\tif (i == endd)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tright = endd;\n\t}\n}\n题目2\n浇水问题：\r\n给你一个数组v 其中 v[i] 表示第i个地方有一个水管 浇水可以覆盖[i - v[i], i + v[i]] 求使得整个花园都能浇到水的最少水管数目 如果无法完全覆盖，返回－1\n\n思路：\r\n我们先创建一个新的数组right 其中right[i] 表示第i个位置开始 能到达的范围\r\n例如：v[3] = 2 那么v[3] 可以覆盖[1, 5] 的范围 那么 right[1] = max(right[1], 5)\n\n\n随后，这个问题就跟题目一一模一样了\n\n代码：\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt;v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nvector&lt;int&gt; right(n);\nfor (int i = 0; i &lt; n; i++) right[i - v[i]] = max(right[i - v[i]], i + v[i]);\n \nint ans = 0, curright = 0, nextright = 0;\nfor (int i = 0; i &lt; n; i++)\n{\n\tnextright = max(nextright, right[i]);\n\tif (i == curright)\n\t{\n\t\tif (i == nextright)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tcurright = nextright;\n\t}\n}\ncout &lt;&lt; ans;\n题目3\n题目4\n题目5\n题目6"},"对暴搜的研究/贪心套路/贪心":{"slug":"对暴搜的研究/贪心套路/贪心","filePath":"对暴搜的研究/贪心套路/贪心.md","title":"贪心","links":[],"tags":[],"content":"贪心算法通常具有以下几个重要性质：\n1. 贪心选择性质\n\n局部最优：每一步都做出当前看起来最优的选择\n不可撤销：一旦做出选择，不会回溯修改\n子问题独立：当前决策不依赖于后续决策 1\n\n示例：\n// 常见的贪心模式\nwhile(有选择) {\n    choice = 选择当前最优解;\n    result = 将选择添加到结果中;\n    problem = 在剩余问题上继续;\n}\n2. 最优子结构性质\n\n问题的最优解包含子问题的最优解\n子问题之间相互独立，不存在交叉影响\n\n3. 特征识别\n贪心问题通常具有以下特征：\n\n排序帮助：\n\n// 很多贪心问题第一步是排序\nsort(arr.begin(), arr.end()); // 按某种规则排序\n\n局部决策：\n\nfor(int i = 0; i &lt; n; i++) {\n    // 每一步只考虑当前最优\n    if(isGood(current)) {\n        ans = max(ans, current);\n    }\n}\n\n不需要回溯：\n\n// 贪心通常是单向遍历\n// 不需要考虑之前的决策\nvisited[current] = true; // 标记已访问\n// 不会再修改visited[current]\n4. 正确性证明方法\n贪心算法的正确性证明通常包含：\n\n归纳证明：\n\n\n证明局部最优能导致全局最优\n证明不存在更优解\n\n\n反证法：\n\n\n假设存在更优解\n证明可以通过贪心策略得到相同或更优结果\n\n\n交换论证：\n\n\n证明任何非贪心策略都可以通过交换变成贪心策略\n且交换不会使结果变差\n\n5. 常见贪心策略\n\n选择排序：\n\n// 按照某种规则排序后遍历\nsort(intervals.begin(), intervals.end());\nfor(auto interval : intervals) {\n    // 处理每个区间\n}\n\n优先队列：\n\npriority_queue&lt;int&gt; pq;\n// 维护当前最优选择\nwhile(!pq.empty()) {\n    int top = pq.top();\n    pq.pop();\n    // 处理最优选择\n}\n\n双指针：\n\nint left = 0, right = n-1;\nwhile(left &lt; right) {\n    // 从两端向中间处理\n    // 每次选择最优的移动方向\n}\n6. 反例识别\n不适合用贪心的情况：\n\n需要考虑全局最优\n当前决策依赖于后续决策\n存在多个相互影响的约束条件\n\n记住：贪心算法的关键是证明局部最优能导致全局最优！"},"对暴搜的研究/题解/cf/2116/11":{"slug":"对暴搜的研究/题解/cf/2116/11","filePath":"对暴搜的研究/题解/cf/2116/11.md","title":"11","links":[],"tags":[],"content":"(0404)_{10} = (110010100)_{2} = 0100"},"对暴搜的研究/题解/cf/2116/A":{"slug":"对暴搜的研究/题解/cf/2116/A","filePath":"对暴搜的研究/题解/cf/2116/A.md","title":"A","links":[],"tags":[],"content":"把其中一个打死就行\nauto r1 = max(a, c), r2 = max(b + d);\ncout &lt;&lt; (r1 &gt;= r2 ? &quot;Gellyfish&quot; : &quot;Flower&quot;);"},"对暴搜的研究/题解/cf/2116/B":{"slug":"对暴搜的研究/题解/cf/2116/B","filePath":"对暴搜的研究/题解/cf/2116/B.md","title":"B","links":[],"tags":[],"content":"注意到 2^n = 2^{n - 1} + 2^{n - 1} 所以对于任意一个 i 我们统计出 [0, i]上最大的a_j和b_k 那么肯定有a_j &gt; a_{i - j} 和 b_k &gt; b_{i - k} 所以可以认为所求值是由max(a_j, b_k) 决定的\r\n即：\nint j = 0, k = 0;\nfor (int i = 0; i &lt; n; i++)\n{\n\tif (a[i] &gt; a[j]) j = i;\n\tif (b[i] &gt; b[k]) k = i;\n \n\tif (a[j] &gt; b[k]) cout &lt;&lt; ksm(2, a[j] + b[i - j]);\n\telse if (a[j] == b[k]) cout &lt;&lt; ksm(2, a[j] + max(b[i - j], a[i - k]));\n\telse cout &lt;&lt; ksm(2, b[k] + a[i - k]);\n\tcout &lt;&lt; &#039; &#039;;\n}"},"对绩点的妥协/大学物理":{"slug":"对绩点的妥协/大学物理","filePath":"对绩点的妥协/大学物理.md","title":"大学物理","links":[],"tags":[],"content":"质点运动学\n位移 速度 加速度\n\n位置矢量(位矢)\n\n建立直角坐标系后，物体位置用坐标A(x, y, z) 表示\n向量\\vec{r} = \\vec{OA} 就称为 位置矢量 也记作 \\vec{r} = x\\vec{i} +y \\vec{j} + z \\vec{k}\n\n\n运动方程\n\n质点坐标x, y, z 随 t 的变化关系，将 t 消掉即可\n\n\n\n例：已知质点运动学方程是 \\vec{r} = 4t^{2} \\vec{i} + (2t +3)\\vec{j} 求质点的运动方程\nx = 4t^{2}, y = 2t +3 \\to t = \\frac{y - 3}{2} \\to x = 4(\\frac{y - 3}{2}) ^{2}\n\n位移与路程\n\n物体的位置变化记为位移\\triangle\\vec{r}  用起点到终点的有向线段表示\n物体实际运动的路径长为路程\\triangle s\n注意\n\n\\triangle \\vec{r} 是位移，|\\triangle \\vec{r} | 是 位移的大小，\\triangle r 是物体到原点距离的变化\n只有 ds = |d\\vec{r}| 是对的\n\n\n\n\n\n圆周运动的参数\n相对运动\n机械振动\n\\begin{align}\n\\text{位移:} \\quad &amp; x = A \\cos(\\omega t + \\phi) \\\\\n\\text{速度:} \\quad &amp; v = \\frac{dx}{dt} = -A \\omega \\sin(\\omega t + \\phi) \\\\\n\\text{加速度:} \\quad &amp; a = \\frac{dv}{dt} = -A \\omega^2 \\cos(\\omega t + \\phi) \\\\\n\\text{角频率:} \\quad &amp; \\omega = \\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi f \\\\\n\\text{动能:} \\quad &amp; E_k = \\frac{1}{2}mv^2 = \\frac{1}{2}m\\omega^2 A^2 \\sin^2(\\omega t + \\phi) \\\\\n\\text{势能:} \\quad &amp; E_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2 \\cos^2(\\omega t + \\phi) \\\\\n\\text{总能量:} \\quad &amp; E = E_k + E_p = \\frac{1}{2}kA^2 \\\\\n\\text{最大速度:} \\quad &amp; v_{\\text{max}} = A\\omega \\\\\n\\text{最大加速度:} \\quad &amp; a_{\\text{max}} = A\\omega^2 \\\\\n\\text{微分方程:} \\quad &amp; \\frac{d^2x}{dt^2} + \\omega^2 x = 0\n\\end{align}\n以下是一些简谐振动的经典二级结论及其详细推导过程，适合用于快速解题和理解物理本质。所有公式均提供 LaTeX 源码。\n\n结论1：弹性力在半个周期内所做的功为 0\n推导过程：\n弹性力是保守力，其做功仅取决于初末位置的势能差。\n简谐振动中，半个周期（T/2）内振子从位置 x_0 移动到对称位置 -x_0，势能变化为：\n\\Delta E_p = \\frac{1}{2}k(-x_0)^2 - \\frac{1}{2}k x_0^2 = 0\n因此弹性力做功 W = -\\Delta E_p = 0。\n\n结论2：动能与势能相等时的位移 x = \\pm \\frac{A}{\\sqrt{2}}\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，当动能等于势能时：\nE_k = E_p = \\frac{1}{2}E \\Rightarrow \\frac{1}{2}kx^2 = \\frac{1}{2} \\cdot \\frac{1}{2}kA^2\n解得：\nx^2 = \\frac{A^2}{2} \\Rightarrow x = \\pm \\frac{A}{\\sqrt{2}}\n\n结论3：最大速度 v_{\\text{max}} = A\\omega（平衡位置）\n推导过程：\n动能最大值对应速度最大值：\nE_k^{\\text{max}} = \\frac{1}{2}mv_{\\text{max}}^2 = \\frac{1}{2}kA^2\n\\Rightarrow v_{\\text{max}} = A \\sqrt{\\frac{k}{m}} = A\\omega\n\n结论4：最大加速度 a_{\\text{max}} = A\\omega^2（端点）\n推导过程：\n加速度由胡克定律 F = -kx 和牛顿第二定律 F = ma 得：\na = -\\frac{k}{m}x \\Rightarrow |a|_{\\text{max}} = \\frac{k}{m}A = A\\omega^2\n\n结论5：速度与位移的相位差 \\frac{\\pi}{2}\n推导过程：\n位移 x = A\\cos(\\omega t + \\phi)，速度 v = -A\\omega\\sin(\\omega t + \\phi)。\n利用三角恒等式：\n\\sin\\theta = \\cos\\left(\\theta - \\frac{\\pi}{2}\\right)\n\\Rightarrow v = A\\omega\\cos\\left(\\omega t + \\phi + \\frac{\\pi}{2}\\right)\n因此速度超前位移 \\frac{\\pi}{2}。\n\n结论6：周期与振幅无关（等时性）\n推导过程：\n简谐振动周期 T = 2\\pi\\sqrt{\\frac{m}{k}}，仅依赖于系统参数（质量 m 和劲度系数 k），与振幅 A 无关。\n这是简谐振动的核心特性。\n\n结论7：能量与振幅平方成正比\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，直接表明能量与振幅的平方成正比。\n\n结论8：单摆周期公式（小角度近似）\n推导过程：\n单摆受力矩 \\tau = -mgl\\sin\\theta，小角度下 \\sin\\theta \\approx \\theta，\n微分方程为：\n\\frac{d^2\\theta}{dt^2} + \\frac{g}{l}\\theta = 0 \\Rightarrow T = 2\\pi\\sqrt{\\frac{l}{g}}\n\n结论9：垂直弹簧振子的平衡位置偏移\n推导过程：\n竖直悬挂时，平衡位置满足 mg = kx_0 \\Rightarrow x_0 = \\frac{mg}{k}。\n振动仍为简谐运动，振幅以该平衡位置为中心。\nx_0 = \\frac{mg}{k} \\quad \\text{(竖直悬挂时的平衡位置)}\n\\end{equation}$$\n\n---\n\n### **结论10：串联/并联弹簧的等效劲度系数**\n\n- **串联**：$\\frac{1}{k_{\\text{eq}}} = \\frac{1}{k_1} + \\frac{1}{k_2}$  \n- **并联**：$k_{\\text{eq}} = k_1 + k_2$\n\n\n### 例题\n\\begin{align}\n&amp;m = 10^{-3} kg \\\n&amp;x = 0.1 \\cos (8 \\pi t +\\frac{2\\pi}{3})\n\\end{align}\n求弹簧周期，振幅，初相位，速度和加速度的最大值\n\\begin{align}\n&amp;\\omega = 8\\pi \\\n&amp;T = \\frac{2\\pi}{\\omega} = \\frac{2\\pi}{8\\pi} = \\frac{1}{4} \\\n&amp;A= 0.1 \\\n&amp;\\phi = \\frac{2\\pi}{3} \\\n&amp;v_{max} =  A\\omega = 0.8\\pi \\\n&amp;a_{max} =  A\\omega ^ 2 = 6.4 \\pi ^ 2\n\\end{align}\n求最大回复力，最大动能，平均动能和平均势能，在哪些位置上动能势能相等？\n\\begin{align}\n&amp;F_{max} = -kA \\\n&amp;E_k , {max} = \\frac{1}{2}mv{max} \\\n&amp;\\overline{E_k} = \\overline{E_p} = \\frac{1}{2}E_{总} = \\frac{1}{4}\\omega A ^ 2 \\\n&amp;x = \\pm \\frac{A}{\\sqrt{2}} \\quad \\text{时，动能势能相等}\n\\end{align}\n求 $t_2 = 5s$ 和 $t_1 = 1s$ 两个时刻的相位差\n\\begin{align}\n&amp;\\phi(t) = 8\\pi t + \\frac{2\\pi}{3} \\\n&amp;\\triangle \\phi = 32 \\pi\n\\end{align}\n## 机械波\n## 静电场\n\\begin{align*}\n\\text{库仑定律:} \\quad &amp; F = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q_1 q_2}{r^2} \\\n\\text{电场强度:} \\quad &amp; \\vec{E} = \\frac{\\vec{F}}{q_0} \\\n\\text{高斯定律:} \\quad &amp; \\oint \\vec{E} \\cdot d\\vec{A} = \\frac{Q_{\\text{enc}}}{\\varepsilon_0} \\\n\\text{电势:} \\quad &amp; V = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q}{r} \\\n\\text{电容:} \\quad &amp; C = \\frac{Q}{V}, \\quad C_{\\text{平行板}} = \\varepsilon_0 \\frac{A}{d} \\\n\\text{电容器储能:} \\quad &amp; U = \\frac{1}{2} C V^2\n\\end{align*}\n对电荷连续分布的带电体：\n\\begin{align*}\nd\\vec{F} &amp;= \\frac{q_{0} dq}{4\\pi \\epsilon_{0}r} \\vec{r^{0}} \\\n即:\\\nd\\vec{F} &amp;= \\frac{q_{0} \\vec{r^{0}}}{4\\pi \\epsilon r} , dq\\\n则有\\\n\\vec{F} &amp;= \\int_{Q} \\frac{q_{0} \\vec{r^{0}}}{(4\\pi \\epsilon r) }, dq\\\n\\\n其中，dq &amp;=\n\\begin{cases}\n\\lambda , dl \\quad \\text{(线密度)}\\\n\\sigma , dS \\quad \\text{(面密度)}\\\n\\rho , dV \\quad \\text{(体分布)}\n\\end{cases}\\\n\\end{align*}\n矢量积分的一般步骤：\n1. 设坐标，取积分微元，这里是 $dq$ (按照电荷的分布情况取)\n2. 写出点电荷 $dq$ 的电场强度 $d\\vec{E}$ 的大小，方向（标在图上）\n3. 坐标分解 $d\\vec{E}$ (在图上也要画出）\n4. 对 $d\\vec{E}$ 的各个坐标分量 积分\n\n##### 长为 $L$ 的均匀带电直杆，电荷线密度为 $\\lambda$ 求：\n它在空间一点 $P$ 产生的电场强度 （$P$ 点到杆的垂直距离为 $a$)\n\n\\begin{align*}\n\\text{电场强度} ; d\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{dq}{r} \\\nr &amp;= \\sqrt{a^{2} + x^{2}}\\\n设所成角度为 , \\theta ,则有\\\n\\frac{a}{x} &amp;= \\tan \\theta\\\n\\text{这道题是杆子 有}\\\ndq &amp;= \\lambda , dx\\\n\\end{align*}\n##### 一个半径为 $R$ 的导体球表面的面电荷密度为 $\\sigma$ 那么，在距球面 $R$ 处的电场强度为\n\\begin{align*}\n电场强度 \\quad d\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{dq}{r} \\vec{r^{0}}\\\n由高斯定理\\\n\\oint \\vec{E} , dS &amp;= \\frac{Q}{\\epsilon} \\\n则有 \\\n\\vec{E} ,4\\pi (2R) ^{2} &amp;= \\frac{\\sigma \\int dS}{\\epsilon}\\\n解得\\\n\\vec{E} &amp;= \\frac{\\sigma 4 \\pi R^{2}}{4 \\pi 4R ^ {2} \\epsilon} \\\n&amp;= \\frac{\\sigma}{4\\epsilon}\n\\end{align*}\n##### 已知球体半径为 $R$ 带电量为 $q$ （电荷体密度为 $\\rho$ ）求均匀带电体的电场强度分布\n\\begin{align*}\n对于球外 (r &gt;= R)\\\n\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{q}{r^{2}}\\vec{r}^{0}\\\n\\\n由高斯定理，有\\\n\\oint \\vec{E} ,dS &amp;= \\frac{Q}{\\epsilon}\\\n即\\\n\\vec{E} , 4 \\pi r^{2} &amp;= \\frac{q}{\\epsilon}  \\\n\\\n对于球内 （r &lt; R) \\\n\\oint \\vec{E} , dS &amp;= \\vec{E} , 4 \\pi r ^{2} \\\n&amp;= \\frac{\\sigma \\int_{0}^{r} \\rho , dV}{\\epsilon}\\\n&amp;= \\frac{\\sigma \\rho 4 \\pi r^{3} }{3\\epsilon}\n\\end{align*}\n\n\\begin{align*}\\\n\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{q}{r^{2}} \\vec{r^{0}} \\\n\\\n\\\nF &amp;= k \\frac{q_{1}q_{2}}{r^{2}}\n\\end{align*}\n"},"对绩点的妥协/离散数学-充分复习":{"slug":"对绩点的妥协/离散数学-充分复习","filePath":"对绩点的妥协/离散数学 充分复习.md","title":"离散数学 充分复习","links":[],"tags":[],"content":"集合论\n给定两集合 A、B 全集S 求各种东西\n交并补很显然 需要特别注意 补集也有叫余集的 A在C中的补集等于A在C中的余集\n差集 A - B 就是A有B没有的\n对称差 A \\triangle B 就是并集减去交集\n笛卡尔积 A \\times B 就是A中拿一个元素 B中拿一个元素 得到的集合应该形如 \\{(a_{1},b_{1}),(a_{2},b_{2})...(a_{n},b_{m})\\}\n幂集 2^{A} 就是空集开始 A本身结尾的那个超大集合\n证明两个集合相等\n就是证明AB两个集合互为对方的子集\n要证明两个集合 A 和 B 互为对方的子集（即 A⊆B 且 B⊆A ），从而证明 A=B ，可以按照以下步骤进行：\n1. 证明 A⊆B\n目标 ：证明集合 A 中的所有元素都属于集合 B 。\n方法 ：\n\n任取元素 ：设 x∈A 。\n逻辑推导 ：根据集合 A 的定义和已知条件，推导出 x∈B 。\n结论 ：由 x 的任意性，得出 A⊆B 。\n示例 ： 假设 A={x∈Z∣x 是偶数} ，B={x∈Z∣xmod2=0} 。\n证明 A⊆B ：\n设 x∈A ，则 x 是偶数，即存在整数 k 使得 x=2k 。\n因此 xmod2=0 ，故 x∈B 。\n结论：A⊆B 。\n\n2. 证明 B⊆A\n目标 ：证明集合 B 中的所有元素都属于集合 A 。\n方法 ：\n\n任取元素 ：设 x∈B 。\n逻辑推导 ：根据集合 B 的定义和已知条件，推导出 x∈A 。\n结论 ：由 x 的任意性，得出 B⊆A 。\n\n示例 （接上例）：\n证明 B⊆A ：\n\n设 x∈B ，则 xmod2=0 ，即 x 是偶数。\n因此 x∈A 。\n结论：B⊆A 。\n\n最后得到：\n\n若 A⊆B 且 B⊆A ，则 A=B 。\n\n用运算定律证明对称差满足结合律\n兄弟 这他妈是啥？搜了我都没看懂\n映射\n判断给定映射是否是单射 满射 双射 给出证明\n\\begin{align*}\n&amp;双射\\begin{cases}\n单射 \\ \\ \n\\forall x_{1}, x_{2} \\in 定义域,\\  x_{1} \\neq x_{2} \\implies f(x_{1}) \\neq f(x_{2})\n\\\\\n满射 \\ \\ \n\\forall y \\in 值域,\\  \\exists x \\in 定义域 \\ 使得 \\ f(x) = y\n\\end{cases}\\\\\n\\end{align*}\n我们通常可以把单射和单调性结合起来理解 单调性不变 那么就是单射\n至于满射 我们需要结合定义域和至于判断\n双射需要同时满足单射和满射的条件\n求f, g, h 的合成结果，求逆\n例如f \\circ g 我们可以理解成 f(g(x)) 这样一来先后关系就一目了然了\n映射 f 可求逆的前提条件是 f 是双射\n因此我们需要留一个心眼 求逆的时候重新看一遍所求映射是不是双射\n比如：f(x) = x + 15\\ \\  g(x) = 15x + 1 x,\\ y \\in R  让我们求逆\n逆通常表示成 f^{-1}(y)\\ \\  g^{-1}(y)\n对于 f 显然满足双射的条件 可以得到 f^{-1}(y) = y - 15\n对于 g 发现 y = 2 时, 不存在x \\in R 使得 f(x) = y 因此 g根本不存在逆\n二元关系\n给定集合A 关系R 判断对于A来说 R是否是等价关系 偏序关系\n我们有：\n\\begin{align*}\n&amp;等价关系\\begin{cases}\n自反性\\\\\\\\\n对称性\\\\\\\\\n传递性\n\\end{cases}\n\\end{align*}\n我们把x, y满足R关系 写作 xRy 因此有如下定义：\n自反性：\\forall x \\in A,\\ xRx\n对称性：若 \\, xRy,\\ 则有yRx\n传递性：若 \\ xRy,\\ yRz\\ ,\\ 则有 \\,xRz\n我们有：\n\\begin{align*}\n偏序关系（偏序集）\\begin{cases}\n自反性\\\\\\\\\n反对称性\\\\\n\\\\\n传递性\n\\end{cases}\n\\end{align*}\n反对称性：若 \\, xRy\\ 的同时有\\ yRx,\\ 则x=y\n自行证明即可\n如何求关系的复合运算 逆运算 闭包运算 用关系矩阵求 用关系矩阵的乘法运算求传递闭包\n不会捏\n图论\n无向图，邻接矩阵\n无向图就是没有方向的图\n邻接矩阵就是把图用矩阵表示出来 比如a b 中间有一条无向边 那么 v[a][b] = 1, v[b][a] = 1\n判断图是不是 欧拉图 哈密顿图\n欧拉回路：经过每条边恰好一次的闭合路径（起点 终点 相同）\n欧拉图：存在欧拉回路的图\n欧拉路径：经过每条边恰好一次 而且起点终点不相同的图\n哈密顿回路 ：一条经过图中每个顶点恰好一次 的闭合路径（起点 终点 相同）。\n哈密顿图 ：存在哈密顿回路的图。\n哈密顿路径 ：经过每个顶点一次 起点和终点不同的路径。\n如何判断？\n判断前提：如果图不是连通的 就什么图都不是了  连通性：任意两个顶点可以到达\n欧拉图：所有顶点的度数 deg(v) 都是偶数\n哈密顿图是一个NP完全问题，判断起来比欧拉图复杂得多，但我们仍有一些充分条件和必要条件可以辅助判断\n若顶点数 n &gt;= 3 ：\n\nDirac 定理：若每个顶点的度数 deg(v) &gt;= \\frac{n}{2} 则是哈密顿图\nOre 定理：若对任意两个不相邻的顶点 u, v 有 deg(u) + deg(v) &gt;= n 则是哈密顿图\n\n需要特别注意的是 即使一个图不满足这两个定理 它仍然有可能是哈密顿图 在这种情况下 我们不仿自己动笔画一画 看能不能在图中 构造出一个 经过所有点恰好一次 的 闭合回路\n欧拉图 哈密顿图 的应用\n一笔画问题，邮递员问题 属于欧拉图的应用\n旅行商问题，任务调度问题 属于哈密顿图的应用\n建议自己ai问一下题干 然后看能不能观察出这是xxx图的应用\n能观察出来 基本上就差不多了\n树\n树的六个基本性质\n无圈性（无环性）：树中不存在环\n连通性：任意两个顶点可以到达\n唯一路径性：任意两个顶点的路径唯一\n边数公式：（边数 = 顶点数 - 1）\n极小连通性：删除任意边导致不连通\n极大无圈性：增加任意边导致有环\n判断图是不是平面图\n没找到例题\n有向树\n用二元有序树表示算术表达式（前中后序）\n算术表达式的写法：\n符号在上 字母在下\n加减在上 乘除在下\n前中后序 说的是 根 的顺序 可以具体查询ai来理解\n近世代数\n判断给定代数系统是不是群\n一个代数系统包含一个集合A和一个关系* 通常写作（A,* )\n\\begin{align*}\n群\\begin{cases}\n半群\\begin{cases}\n封闭性\\\\\n\\\\\n结合律\n\\end{cases}\\\\\\\\\n\n幺半群 \\to 单位元\\\\\\\\\n\n\\to 逆元\n\\end{cases}\n\\end{align*}\n封闭性和结合律都是比较显然的 现在重点讲单位元和逆元。\n单位元：\\forall a \\in A, \\ e \\in A,\\ 使得\\ a* e=a成立 解出e e被称作单位元\n对于不同的a e应当是唯一的\n逆元：\\forall a \\in A, \\ \\exists a^{-1} \\in A,\\ 使得 a*a^{-1}=e\\ 成立 解出a^{-1} 对于不同的a a^{-1} 可以是不唯一的 但是如果有一个a不存在a^{-1} 那么这个代数系统就没有逆元 也就不是群\n格 / 布尔代数\n判断给定代数系统是否是偏序集，格，有界格，有补格，分配格，布尔代数\n偏序集：也就是偏序关系 满足自反 反对称 传递\n格：特殊的偏序集，对代数系统中任意两个元素都存在 最小上界（记作 a∨b ) 和 最大下界(记作 a∧b )\n有界格：特殊的格，存在 最大元素 (记作 1) 和 最小元素 (记作 0) ！！\n有补格：特殊的有界格，对代数系统中任意元素都存在补元 使得同时满足 1 和 0\n分配格：特殊的格，满足分配律 \\begin{align*}\na∧(b∨c)=(a∧b)∨(a∧c) \\\\\na∨(b∧c)=(a∨b)∧(a∨c)\n\\end{align*}\n布尔代数：有补的分配格\n概念很多 需要多看几遍\n数理逻辑\n对于给定问题，求结论 / 求结论的有效性\n相对板子的题，自行推导即可。步骤是：\n\n符号化\n推理\n\n求一个命题公式的主析取范式 / 主合取范式\n主析取范式：极小项的或 对应结果是 1 的行\n主合取范式：极大项的与 对应结果是 0 的行\n析取 指的是逻辑或\n合取 指的是逻辑与\n数电怎么做 这个就怎么做\n\n列真值表 000 001 010 写出来\n找到结果 是 1 / 0 的行\n按照要求 先与再或 / 先或再与\n\n谓词逻辑\n求一个谓词公式的命题表示的真值\n涉及部分 德摩根定律 类似的技巧 需要结合具体题目来理解\n通常就是把那个命题写清晰一点 判断是 1 还是 0 即可\n使用谓词公式表示任意命题（符号化）\n符号化有些地方比较恶心 需要结合往年真题逐题分析\n近世代数 考 群 布尔代数\n图论 基本概念 最小生成树 有向图 / 有向树\n数理逻辑 命题 谓词\n集合论 老三样 都是简单题"},"有感":{"slug":"有感","filePath":"有感.md","title":"有感","links":[],"tags":[],"content":"一千天啦～祝贺祝贺，按照markdown格式这里可以插入一张图片，点开能看到我们亲嘴子\n感觉朋友圈子里谈到一千天的人也不多吧，亮亮那个闷骚没有发什么长篇大论，王健涵我也不知道一千天没有，打完这段话我就去问问\n上大学半年 我们对很多事情都有了新的体会，聊天的内容也越来越沉重，越来越现实。大概对于我而言，能跟有些人说上话真的得得益于同学这层纽带，好比在社会上见了宇轩我得叫周总，但是有同学情谊在我居然可以叫他儿子。\n之前看到过一个视频，说建议男生在大学谈一段恋爱，因为这是”翻盘的最好机会，大学里的白富美会因为你唱歌好听跟你约会，然而出了社会没人会搭理你”，我们还一起讨论过这个视频，得出的结论是这种行为虽不仁义却十分真实，现在的大学已经慢慢的退出了分配财富的舞台，有时候不免感觉“这么努力还不如找富婆包养来的实在”。也正是因为这样，我居然会在一些时候突然觉得黄景怡是一个虚无缥缈的存在，好像她这段时间只是用来陪我过家家，时间一到就去跟什么大国的王室联姻，从此只能在新闻上看到她和她的宫殿\n我自认为不是一个非常成功的人，很有个性但是没什么能耐，感觉高三飘了一年被高考打回现实了，一年前的今天我可能还跟刘佳南两个半夜不睡觉搬凳子出去阳台吹牛逼然后被陈超穿着树懒睡衣出来说“哥们你们吵死我了”，现在的爱好变成了跟他约着出去打台球的时候喝点小酒然后互相诉苦，发泄对这个很操蛋的世界的不满\n家境不提也罢，偏偏她又那么有才华，我在大学更加努力。我不止一次跟黄景怡说“我真的很怕给不起彩礼 让你过得不舒服”云云，黄景怡也反复跟我说“没关系， 跟你在一起的话没什么钱也是可以的” 。每每想到能让她说出这样有点主观有点扯淡的话，我就觉得我又有活着的动力了\n黄景怡是一个很聪明，很心细的人，在解人意这方面有先天性的优势。但她不是一个外向的人，导致很多时候她都是自我内耗 然后自己解了自己的人意 如果说我在这段恋爱关系中帮到了她什么，大概也就只有“让她变得自信起来”  她现在会跟我分享自己好看的和摆了鬼脸的照片，有精致的也有披头散发的，她不再害怕跟我打视频通话，也允许我在朋友圈发她的 被抓拍照片 看到她的思维，她的伤心难过事一点一点暴露在我面前，我有点接受不了，因此说过“不想听你的负面情绪”这种很极端的言论，但是她没有放弃 在恋爱中一点点把解人意的技巧传授给我，导致我的脾气随着恋爱变好了（有吗？一些人说有）也感觉不再是木头脑袋，也发现女孩子没有那么莫名其妙那么难哄。\n跨省异地恋 是非常 非常 非常痛苦的 我本身情况特殊，父母都是来深打工的，导致我虽然在深圳长大但是逢年过节还是得回老家，哈尔滨的大雪把寒假时间（从我的认知中）延长到了六十天，但我们见面的次数竟寥寥无几 挽着手逛街之后总要分别，每到这时候她就说不想分开，其实我也不想分开，也许我们受不了的其实不是分开，而是长时间未能见面短暂满足心愿又被迫很快分离的愿望破碎感。\n所以我不会后悔1月2号下午做的那个 一个人做十六个半小时硬座去北京的 疯狂决定，也很期待五月一号那个五天假期我们去哪玩\n越写越感觉我其实对她没那么好，黄景怡你是怎么看上我这人的呢？我们两个能情投意合的谈一千天之多 究竟是射箭的还是牵红线的立了功？\n开了学我们都一堆课要忙 更没什么机会聊天，感觉我礼物也不会送，话也说不好听，但是她说要跟我过一辈子诶，那我是应该努努力 ^^\n她已经完完全全的改变了我，让我有了吃饭的时候拍照给她分享食物的习惯（并因此被大学舍友喷是恋爱脑），让我有了更加辩证，更加全面的思考态度 而不是一个非黑即白的人，跟我说了很多为人处世的道理 让我三天可见的朋友圈挂了一堆恋爱日常的置顶，让我在冰城每天都很想她\n所以我打了这些字，放在朋友圈请大家见证：==我不想做一个只会画饼的人，我会尽我的努力让我们俩过得更好 =="}}