{"ACM-research/ACW2024/二分/1227":{"slug":"ACM-research/ACW2024/二分/1227","filePath":"ACM research/ACW2024/二分/1227.md","title":"1227","links":[],"tags":[],"content":"void solve()\n{\n\tint n, k;\n\tcin &gt;&gt; n &gt;&gt; k;\n\tint maxnum = 0;\n\tvector&lt;int&gt; h(n), k = h;\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; h[i] &gt;&gt; k[i];\n\t\tmaxnum = max({maxnum, h[i], k[i]});\n\t}\n \n\tint l = 1, r = maxnum, m, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tm = l + (r - l) / 2;\n\t\tauto check = [&amp;]()\n\t\t{\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\t{\n\t\t\t\tans += (h[i] / m) * (k[i] / m);\n\t\t\t}\n\t\t\treturn ans &gt;= k;\n\t\t};\n\t\tif (check()) l = (ans = mid) + 1;\n\t\telse r = m - 1;\n\t}\n\tcout &lt;&lt; ans;\n}"},"ACM-research/ACW2024/二分/503":{"slug":"ACM-research/ACW2024/二分/503","filePath":"ACM research/ACW2024/二分/503.md","title":"503","links":[],"tags":[],"content":"void solve()\n{\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tvector&lt;int&gt; v(n + 2);\n\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; \n\tfor (int i = n; i &gt;= 1; i--) v[i] -= v[i - 1];\n \n\tstruct datas\n\t{\n\t\tint d, s, t;\n\t};\n\tvector&lt;datas&gt; k(m + 1);\n\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; k[i].d &gt;&gt; k[i].s &gt;&gt; k[i].t;\n \n\tint l = 1, r = m, mid, ans;\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2;\n\t\tauto check = [&amp;]() -&gt; bool\n\t\t{\n\t\t\tauto b = v;\n\t\t\tfor (int i = 1; i &lt;= mid; i++)\n\t\t\t{\n\t\t\t\tb[v[i].s] -= v[i].d;\n\t\t\t\tb[v[i].t + 1] += v[i].d;\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 1; i &lt;= m; i++)\n\t\t\t{\n\t\t\t\tans += b[i];\n\t\t\t\tif (b[i] &lt; 0) return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tif (check()) r = (ans = mid) - 1;\n\t\telse l = mid + 1; \n\t}\n\tcout &lt;&lt; ans;\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n随着订单增加，每天可用教室的数量一定单调下降\r\n我们可以二分求出第一天出现负值的订单编号\r\n每个订单 我们会选择 [L, R] 全部减去 d\r\n可以用差分来加速处理过程\n\n\n"},"ACM-research/ACW2024/二分/5407":{"slug":"ACM-research/ACW2024/二分/5407","filePath":"ACM research/ACW2024/二分/5407.md","title":"5407","links":[],"tags":[],"content":"void solve()\n{\n\tauto check = [&amp;]() -&gt; bool\n\t{\n\t\t\n\t\n\t};\n}"},"ACM-research/ACW2024/前缀和/562":{"slug":"ACM-research/ACW2024/前缀和/562","filePath":"ACM research/ACW2024/前缀和/562.md","title":"562","links":[],"tags":[],"content":"void solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tstring s;\n\tcin &gt;&gt; s;\n\t\n \n}"},"ACM-research/判断整除-数位法":{"slug":"ACM-research/判断整除-数位法","filePath":"ACM research/判断整除 数位法.md","title":"判断整除 数位法","links":[],"tags":[],"content":"对于所有正整数\n1都是因子\n数位和是三的倍数 那么3就是因子\n末尾是5或者0 5就是因子\n对于7 一个n位数(n &gt;= 6) 有abbbccc → a （三个连续的b可以和三个连续的c约掉) 判断a是否可以整除7即可\n数位和是9的倍数 那么9就是因子"},"ACM-research/学习笔记":{"slug":"ACM-research/学习笔记","filePath":"ACM research/学习笔记.md","title":"学习笔记","links":[],"tags":[],"content":"好用的小操作\n求数位之和\nint dig(int x)\n{ \n    return (x + 8) % 9 + 1; \n    // 输入123 返回6\n} \n原理：\n任意一个数字 x 可以写成它的各位数字的加权和，形式如下：\nx = a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0\n其中 a_k, a_(k-1), ..., a_0 是 x 的各个数位的数字。\n关键性质：\n我们知道，对于任何整数 n，有以下等式成立：\n10 ≡ 1 (mod 9)\n这意味着，10 对 9 取模的余数是 1。由此可以推出：\n10^k ≡ 1^k = 1 (mod 9) 对于任意整数 k\n应用到数字表达式：\n现在来看数字 x 对 9 的余数，也就是 x % 9：\nx (mod 9) = (a_k * 10^k + a_(k-1) * 10^(k-1) + ... + a_1 * 10 + a_0) (mod 9)\n由于 10^k ≡ 1 (mod 9)，我们可以将每个项中的 10^k 替换为 1：\nx (mod 9) = (a_k + a_(k-1) + ... + a_1 + a_0) (mod 9)\n也就是说，x 对 9 取模的结果，实际上等于 x 各位数字之和对 9 的余数。\n向上取整\n// 我们需要计算 x / y 向上取整\n \nint new_num = (x + y - 1) / y;\n在环形区间内移动 凯撒密码\nch = (ch - base + shift) % 26 + base;\n\nshift 是凯撒密码中的“位移”量，也就是你想要将字母平移的位数。举个例子，shift = 3 就意味着每个字母会向右移动3个位置。\nbase 是字母的起始点（基准字符），用于确保加密和解密的计算只在字母范围内循环。例如：\n\n如果字母是小写字母（如 &#039;a&#039;），则 base = &#039;a&#039;。\n如果字母是大写字母（如 &#039;A&#039;），则 base = &#039;A&#039;。\n\n\n\n详细解释：\n\nch - base：\n\n这个操作将字符 ch 转换为一个相对 base 的位置。例如，如果 ch 是 &#039;c&#039;，且 base 是 &#039;a&#039;，那么 &#039;c&#039; - &#039;a&#039; 结果为 2，因为 &#039;a&#039; 的 ASCII 值是 97，&#039;c&#039; 是 99，所以 99 - 97 = 2。\n\n\n(ch - base + shift)：\n\n这个操作将字符向右移动 shift 位。比如，如果你想对字母 &#039;c&#039; 进行加密，shift = 3，那么 (2 + 3) 就是 5。\n\n\n% 26：\n\n由于字母表有 26 个字母，这个操作确保结果循环在 26 个字母内。例如，如果位移后的结果大于 &#039;z&#039;，它会回绕到字母表的开始部分。如果 ch 是 &#039;z&#039;，并且 shift = 1，&#039;z&#039; 经过加密会变成 &#039;a&#039;，而不是 &#039;{&#039;。\n\n\n+ base：\n\n最后，加上 base 就是将数字转换回字母字符。例如，5 + &#039;a&#039; 就会变成 &#039;f&#039;，即将 5 映射回字符。\n\n\n\n字符串 子串处理与替换\n1. replace：\nreplace 用于替换字符串中的部分内容，可以替换从某个位置开始的指定长度的字符。\n基本语法：\nstring&amp; replace (size_t pos, size_t len, const string&amp; str);\nstring&amp; replace (size_t pos, size_t len, const string&amp; str, size_t subpos, size_t sublen);\n\npos: 要替换的起始位置。\nlen: 要替换的字符数。\nstr: 替换的内容。\n\n2. substr：\nsubstr 用于获取字符串的子字符串。\n基本语法：\nstring substr (size_t pos = 0, size_t len = npos) const;\n\npos: 子字符串的起始位置。\nlen: 要提取的子字符串的长度（默认为 npos，表示从 pos 到字符串的末尾）。\n\n快速转换进制\nvector&lt;char&gt; lettermap = {&#039;0&#039;, &#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;, &#039;6&#039;, &#039;7&#039;, &#039;8&#039;, &#039;9&#039;, \n                          &#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;, &#039;h&#039;, &#039;i&#039;, &#039;j&#039;, \n                          &#039;k&#039;, &#039;l&#039;, &#039;m&#039;, &#039;n&#039;, &#039;o&#039;, &#039;p&#039;, &#039;q&#039;, &#039;r&#039;, &#039;s&#039;, &#039;t&#039;, \n                          &#039;u&#039;, &#039;v&#039;, &#039;w&#039;, &#039;x&#039;, &#039;y&#039;, &#039;z&#039;};\n \nsigned main()\n{\n    int num, base;\n    cin &gt;&gt; num &gt;&gt; base;\n    \n    string s = &quot;&quot;;\n \n    // 将数字转换为指定进制\n    while (num)\n    {\n        s = lettermap[num % base] + s;  // 从高位到低位构建， 这样不需要\n        num /= base;\n    }\n \n    cout &lt;&lt; s &lt;&lt; &#039; &#039;;\n}\n异或\n异或的性质\n\n\n实质是二进制无进位加法 例如 1011 + 1101 = 0110\n\n\n异或运算满足交换律、结合律，也就是同一批数字，不管异或顺序是什么，最终的结果都是一个\n\n\nn ^ 0 = n, n ^ n = 0  可以结合第一个加法来理解\n\n\n整体异或和如果是x,整体中某个部分的异或和如果是y,那么剩下部分的异或和是 x ^ y 可以结合2的结合律，交换律来理解\n\n\n这些结论最重要的就是1结论，所有其他结论都可以由这个结论推论得到\n其中第4相关的题目最多，利用区间上异或和的性质\n区间异或和的性质\n计算从 0 到 x 的异或和：\n\n通过观察，可以发现异或的规律每四个数重复一次：\n如果 x % 4 == 0，则 xor(0, x) = x\n如果 x % 4 == 1，则 xor(0, x) = 1\n如果 x % 4 == 2，则 xor(0, x) = x + 1\n如果 x % 4 == 3，则 xor(0, x) = 0\n\n计算区间 [l, r] 的异或和：\n假设我们可以计算出 xor(0, r) 和 xor(0, l-1) ，那么： xor(l, r) = xor(0, r) ^ xor(0, l-1)\n异或的骚操作\n\n交换两个数\n\nint a = 1, b = 2;\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n// as a result a equals 2 and b equals 1\n具体过程：\n\n第一步：a = a ^ b; 之后，a 保存的是 a 和 b 异或的结果，即 a 和 b 的混合信息。\n第二步：b = a ^ b; 在这一步中，a 已经存储了 a ^ b，所以 b = (a ^ b) ^ b。根据自反性，b 变成了原来的 a。\n第三步：a = a ^ b; 最后，a = (a ^ b) ^ a，根据自反性，a 变成了原来的 b。\n\n所以，通过这三步异或操作，我们完成了 a 和 b 的交换，而无需使用额外的临时变量。这种方法是非常高效且空间优化的，尤其是在内存受限的情况下。\n\n找到缺失的数字\n\n// 在1~10中随便挖掉一个 让快速找出\n \n// 原理： 缺失的数字 = 所有数异或和 - 剩下数字的异或和\n \nvector&lt;int&gt; v = {1, 2, 3, 4, 6, 7, 8, 9};\n \n// 计算1 ~ 10 的异或和 也就是 xor(0, 10) ^ xor(0, 0) 而xor(0, 0) = 0\n \nint xor_1_to_10 = 10 + 1 = 11;\n \n// 计算v中数字的异或和 应当从0开始\n \nint xor_v = 0;\nfor (int i = 0; i &lt; v.size(); i++) xor_v ^= v[i];\n \n// 计算剩下的数字\n \nint result = xor_1_to_10 ^ xor_v;\n \n例：\nleetcode268\n可以说是异或很好的板子题\nac codes are as follows:\nclass Solution\n{\npublic:\n    int xor_(int x)\n    {\n        if (x % 4 == 0)\n        {\n            return x;\n        }\n        if (x % 4 == 1)\n        {\n            return 1;\n        }\n        if (x % 4 == 2)\n        {\n            return x + 1;\n        }\n        return 0;\n    }\n \n    int missingNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n \n        // calculate xor from 0 to n\n \n        int xor_1_to_n = xor_(n);\n \n        // calculate xor from array\n        int temp = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            temp ^= i;\n        }\n \n        return xor_1_to_n ^ temp;\n    }\n};\n\n\n数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数\n用到的是性质2 可以往上看一眼\nvector&lt;int&gt; v = {1, 1, 1, 1, 2, 2, 3};\nint res = 0;\nfor (auto &amp;&amp; i : v) res ^= i;\nreturn res; \n// as a result res equals 3\n\n\n例：\nleetcode136\nac codes are as follows:\nclass Solution\n{\npublic:\n    int singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        int ans = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            ans ^= i;\n        }\n        return ans;\n    }\n};\n\nBrian Kernighan算法-提取出二进制状态中最右侧的1\n\n其实就是lowbit 将在树状数组中反复使用\n对一个正数x取反 得到x ^ 0\n对其结果 + 1 得到 ~x + 1 其实就是相反数-x\n最后做与运算 则有\nint lowbit(x)\n{\n    return x &amp; (-x);\n}\n最后得到的结果在二进制下将至多只有一个1\n\n数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数\n\n原理：设结果a, b 使得 a != b 那么一定有 a 和 b 在二进制的某一位不相同\n那么原数组中一定可以分成两种数字： 第一种在那一位是0 第二种在那一位是1\n我们只需要分别对这两种数字进行异或和 就能筛选出唯一的数字\n思考：二进制下有多少位不相同 有影响吗？\n**ans：**没有影响 我们要做的只是筛选工作 选出来即可\ncode：\nvector&lt;int&gt; v = {1, 1, 2, 3, 3, 4};\n \nint temp = 0;\nfor (auto &amp;&amp;i : v) temp ^= i;\nint lowbit_num = temp &amp; (-temp);\n \n// 得到了这个唯一的&quot;1&quot; 我们如何继续操作？\n// 我们继续用到与运算：如果num 在 lowbit_num的对应位数上是1 那么结果就是num 如果是0 那么结果就是00000000 也就是0\n \nint ans1 = 0;\nfor (auto &amp;&amp;i : v) if (i &amp; lowbit_num) ans1 ^= i;\nans2 = ans1 ^ lowbit_num;\n// 用到了性质4 部分和 = 全体和 ^ 另一部分和\n例:\nleetcode260\nac codes are as follows:\nclass Solution\n{\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt; &amp;nums)\n    {\n        unsigned xor_nums = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            xor_nums ^= i;\n        }\n \n        int lowbit = xor_nums &amp; (-xor_nums);\n \n        int res1 = 0;\n        for (auto &amp;&amp;i : nums)\n        {\n            if (lowbit &amp; i)\n            {\n                res1 ^= i;\n            }\n        }\n        return {res1, res1 ^ (int)xor_nums};\n    }\n};\n \n\n\n                  \n                  IMPORTANT\n                  \n                \n\n\n为什么使用 unsigned 类型来避免溢出\n\n补码表示和溢出问题：\n\n在 C++ 中，整数是以补码的形式存储的。\n对于 int 类型，取负数的操作涉及到补码的反转，当 xor_nums 等于 INT_MIN（即 -2147483648）时，-INT_MIN 会导致溢出。因为 INT_MIN 是 -2147483648，其补码表示超出了 int 类型的范围，因此无法表示其取反的结果，导致未定义的行为。\n\n\n使用 unsigned 类型：\n\nunsigned 类型在存储负数时表现不同，因为它不使用补码。无符号整数的范围是 [0, 2^n - 1]，它不涉及负数，因此在进行负数取反时不会出现溢出问题。\n当你将 xor_nums 声明为 unsigned 类型时，它将不会出现负数，因此 -xor_nums 会按照无符号整数的规则进行计算，不会发生溢出。\n\n\n\n\n\n\n我们可以在以下场景尝试使用unsigned：\n位运算中出现了负数\n如果你需要执行位操作时，运算符会作用于负数，例如 a &amp; b、a ^ b 或 a | b，而某些操作可能涉及到负数的补码表示。这时，使用 unsigned 类型可以避免这些负数影响结果，因为无符号整数的操作不会引发负数的补码计算。\n进行最低位 1 查找（x &amp; (-x)）时\n在诸如 x &amp; (-x) 的操作中，目标是找到二进制表示中最低的 1。如果 x 是负数（例如 -2147483648），在 int 类型中执行 -x 可能导致溢出，因为补码表示不能正确处理 INT_MIN。而如果使用 unsigned 类型， x 会被视为无符号数，取负时不会引发溢出问题。\n\n数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数\n\nto be continued…\n\n今天的题目基本上都可以用map去重做， 这里是为了更好的熟悉异或运算\n\n\n\n                  \n                  Important\n                  \n                \n\n\n重要提示\n    void solve()\n    {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n \n        // int left = xor_(l - 1);\n        // int right = xor_(r);\n        // cout &lt;&lt; (left ^ right);\n \n        cout &lt;&lt; xor_(l - 1) ^ xor_(r);\n    }\n注释部分不会报错 而第十行会报错 是因为cout需要一个可以明确的返回值类型而异或操作给不出, 笔者也没有想明白这是为什么)\n总而言之 在异或操作的外面加一个括号可以完美避免这个问题\n\n\n\n二分\nTO START WITH\n今天的内容侧重于我自己对代码流程的理解和思考 建议初步了解二分思想 想要规范书写流程 培养思维逻辑的读者\n不建议对二分思想毫无了解的读者阅读 你会一头雾水的！（确信\n二分搜索\n\n在有序数组中确定target存在还是不存在\n\n\n\n                  \n                  Important\n                  \n                \n\n\n为什么一定要是有序的？\n二分的思想一定程度上依赖于单调性 无序的数组不存在单调性 无法应用二分\n\n\n\nbool isExist(vector&lt;int&gt; &amp;nums, int target)\n{\n    if (nums.empty()) return 0;\n    \n    int l = 0, r = nums.size() - 1, mid;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        // 为什么不直接(r + l) / 2 ? 两个很大的数字相加有可能会超出int 而line9可以保证计算的过程始终讴歌处于[l, r]\n        \n        if (nums[mid] == target) return 1;\n        else if (nums[mid] &lt; target) /* 缩短左边界 */ l = mid + 1;\n        else /* 缩短右边界 */ r = mid - 1;\n    }\n    //进行到这里还没return 就说明没找到\n    return 0;\n}\n\n在有序数组中找&gt;=target的最左位置\n\n\n\n                  \n                  Important\n                  \n                \n\n\n可以被*upper_bound 替代\n\n\n\nint findleft(vector&lt;int&gt; &amp;nums, int target)\n{\n    int l = 0, r = nums.size() - 1, mid;\n    int ans = -1;\n    \n    while (l &lt;= r)\n    {\n        mid = l + ((r - l) &gt;&gt; 1);\n        if (nums[mid] &gt;= target) // 满足条件 更新ans 并继续缩小范围\n        {\n            ans = mid;\n            // 如何缩小范围? 这是一个单调的 现在发现数字大了 那么应该缩小右边界\n            r = mid - 1;\n        }\n        else /* 当前数字太小了 那么应该找更大的 缩小左边界 */ l = mid + 1;\n    }\n    return ans; // 如果没有找到结果 将会返回-1\n}\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如果是 &gt;target的最左位置 应该如何思考？\n事实上 我们只需要把line9的 &gt;= 变成 &gt; 即可\n\n\n\n\n在有序数组中找⇐target的最右位置\n\n那么 ⇐target 的最右位置 应该怎么做呢\nint findright(vector&lt;int&gt; &amp;nums, int target)\n{\n\tint l = 0, r = nums.size() - 1, mid;\n\tint ans = -1;\n\t\n\twhile (l &lt;= r)\n\t{\n\t\tmid = l + (r - l) / 2; // 见识过位运算的骚操作之后还是觉得这样写方便一点 少打一个括号\n\t\tif (nums[mid] &lt;= target) // 这是符合要求的 可以更新边界 更新ans\n\t\t{\n\t\t\tans = mid;\n\t\t\t// 如何更新边界呢？找找有没有更大的数满足条件 缩短左边界\n\t\t\tl = mid + 1;\n\t\t}\n\t\telse r = mid - 1;\n\t}\n\treturn ans; // 没找到返回-1\n}\n\n我们的思考重心应该放在 根据 nums[mid] 和 target 的对应关系 在满足条件的时候更新ans 缩短边界\n\n\n二分搜索不一定发生在有序数组上（比如寻找峰值问题）\n\n板子题 leetcode162\nac codes are as follows:\nclass Solution\n{\npublic:\n    int findPeakElement(vector&lt;int&gt; &amp;nums)\n    {\n        auto n = nums.size();\n \n        if (n == 1) // 只有一个元素 那么这个就是极值点\n        {\n            return 0; // 特\n        }\n\t\t// 首先检查nums.front() 和 nums.back()\n        if (nums[0] &gt; nums[1])\n        {\n            return 0;\n        }\n        if (nums[n - 1] &gt; nums[n - 2])\n        {\n            return n - 1;\n        }\n \n        // 现在已经确定 [1, n - 2] 中一定有极值点 可以开始二分搜索\n \n        int l = 1, r = n - 2, mid;\n \n        while(l &lt;= r)\n        {\n            mid = l + (l - l) / 2;\n \n            // 判断是不是极值点 要看nums[mid]和相邻左右的关系\n \n            if (nums[mid] &gt; nums[mid - 1] and nums[mid] &gt; nums[mid + 1])\n            {\n                return mid;\n            }\n            else\n            {\n                if (nums[mid] &lt; nums[mid - 1])\n                {\n                    // 左边呈上升趋势 缩短右边界 在左边查找\n                    r = mid - 1;\n                }\n                else\n                {\n                    // 缩短左边界 在右边查找\n                    l = mid + 1;\n                }\n            }\n        }\n        return mid;\n    }\n};\n二分搜索 with STL\n在 stl 中 我们有 ranges::upper_bound 和 ranges::lower_bound\nvector&lt;int&gt; v = {1, 2, 3, 4, 5};\n \nauto it1 = ranges::upper_bound(v, 2);\n// 返回指向 v[2] = 3 的迭代器\nauto it2 = ranges::lower_bound(v, 2);\n// 返回指向 v[1] = 2 的迭代器\n分析实质\nranges::upper_bound 返回的it1 满足 *it1 &gt; 2*, 而 ranges::lower_bound 返回的 it2 满足 it2 &gt;= 2\n并且他们都是首个满足条件的元素\n所以我们分析可以得到：\n问 &gt;= x 的最小值 可以int it = *ranges::lower_bound(v, x)\n问 &gt; x 的最小值 可以 int it = *ranges::upper_bound(v, x)\n问 &lt; x  的 最大值 其实就是 &gt;= x 的前一个值\n例如 问 &lt; 3 的最小值 其实就是 &gt;= 3  的前一个值 也就是2\n那我们可以写 int it = *(ranges::lower_bound(v, x) - 1)\n同理：问 &lt;= x 的 最大值 其实就是 &gt; x 的 前一个值\n也就是 int it = *(ranges::upper_bound(v, x) - 1)\n总结 and 板子\n\n\n                  \n                  Important\n                  \n                \n\n\n总结一下吧：\n问更大的有现成函数\n问更小的就 计算目标范围的补集（例如问 &lt;= 那么就求&gt;) 把求出来的结果-1 即可\n最后的判断标准：\n问大就判断是否超出右侧区间；\n问小就判断是否超出左侧区间；\n若询问相等 就额外判等\n\n\n\nvoid find(vector&lt;int&gt; &amp;nums, int target)\n{\n    int n = nums.size();\n    \n\t// 求出首个使得num == target 的num的位置 (不存在返回-1)\n\tint it1 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; ((it1 == n or nums[it1] != target) ? -1 : it1) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt;= target 的num的位置 (不存在返回-1)\n\tint it2 = ranges::lower_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it2 == n ? -1 : it2) &lt;&lt; endl;\n    \n    // 求出首个使得num &gt; target 的num的位置 (不存在返回-1)\n    int it3 = ranges::upper_bound(nums, target) - nums.begin();\n    cout &lt;&lt; (it3 == n ? -1 : it3) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt;= target 的num的位置 (不存在返回-1)\n    int it4 = ranges::upper_bound(nums, target) - nums.begin() - 1; // 其实就是it3 - 1!!!!\n    cout &lt;&lt; (it4 &lt; 0 ? -1 : it4) &lt;&lt; endl;\n    \n    // 求出首个使得num &lt; target 的num的位置 (不存在返回-1)\n    int it5 = ranges::lower_bound(nums, target) - nums.begin() - 1; // 其实就是it2 - 1!!!!\n    cout &lt;&lt; (it5 &lt; 0 ? -1 : it5) &lt;&lt; endl;\n}\n例题\nleetcode34\n第一个位置就是 &gt;= x 的第一个元素\n最后一个位置就是 &gt; x 的前一个元素\n思路：\n// 首先 lower出 &gt;= x 的 第一个元素 判断是否与目标值相等 或者是否来到边界(来到边界意味着数组中没有不小于target的元素)\nint num1 = ranges::lower_bound(nums, target) - nums.begin();\n \nif (num1 == nums.size() or nums[num1] != target)\n{\n\treturn {-1, -1};\n}\nelse\n{\n    // 数组中起码有一个 我们就可以upper了\n    int num2 = ranges::upper_bound(nums, target) - nums.begin() - 1;\n    // remember that 直接与begin()相减 求出来的就是下标\n    return {num1, num2};\n}    \n另外：\n我们也可以利用cpp20的 equal_range 函数 来快速获得范围\n{0, 1, 1, 1, 2}\nauto [start, end] = ranges::equal_range(nums, 1); // 此处的auto应该是pair&lt;iterator, iterator&gt;类型\n// start指向nums[1], end指向nums[3]的下一个 也就是 [start, end) 这样一个半开区间\nif (start == end) return {-1, -1};\nreturn {start - nums.begin(), end - 1 - nums.begin()};\n// 如果问长度那么直接end - start即可\nleetcode35\n直接返回 &gt;= target 的第一个元素位置即可\nreturn ranges::lower_bound(nums, target) - nums.begin();\nleetcode704\n跟上面大差不差 搜索到lower之后比较是否相等即可\nauto num = ranges::lower_bound(nums, target) - nums.begin();\nreturn (num != nums.size() and nums[num] == target ? num : -1);\n\n\n                  \n                  Important\n                  \n                \n\n\n当我们需要使用迭代器的时候 要注意有可能返回 nums.emd() 导致 num = n\n这样的情况下nums[num] 是 越界的\n因此 我们应该加上 num == nums.size() 的判断\n\n\n\nleetcode744\n判断 upper是否 == letters.end() 即可\nauto it = ranges::upper_bound(letters, target) - letters.begin();\nreturn (it == letters.size() ? letters.front() : letters[it]);\nleetcode2529\n什么是数目？\n我们不妨做个测试\n{-1, 0, 1}\nlower(0) - begin() 会返回第一个非负数的下标 记为 it 显然 it - 1就是最后一个负数的下标 本例中为0 那么个数就是最后一个下标  0 + 1 也恰好就是 lower(0) - begin()\nlower(1) - begin() 返回第一个正数的下标 本例中为2 个数应为 size() - it其实就是 end() - lower(1)\nint a = ranges::lower_bound(nums, 0) - nums.begin();\nint b = nums.end() - ranges::upper_bound(nums, 0);\nreturn max(a, b);\n二分答案\n解题步骤\n\n估计最终答案可能的范围是什么 经验之谈：为什么叫做二分答案呢？因为二分的就是答案——问什么就二分什么\n分析问题的答案和给定条件之间的单调性，大部分时候只需要用到自然智慧\n建立一个f函数，当答案固定的情况下，判断给定的条件是否达标\n在最终答案可能的范围上不断二分搜索，每次用f函数判断，直到二分结束，找到最合适的答案\n\n核心点：分析单调性、建立f函数\n注意：这个技巧常用且重要，一定要引起重视\n这么说出来可能过于抽象 我们结合例题理解\n二分答案：求最小\nleetcode1283\n问什么就对什么二分， 我们对除数二分\n除数的上下界怎么找？ 下界应该是1 这样可以让sum最大 上界可以选择ranges::max(nums) 这样可以让sum最小\n那我们就确定下来：\n// 对除数二分\n// 除数的范围应该在[1, ranges::max(num)]\n \nint l = 1, r = ranges::max(nums), m, ans;\n随后二分开始\nwhile (l &lt;= r)\n{\n    m = l + (r - l) / 2;\n    // m 是 除数\n    if (f(m, nums, int threshold)) // 满足条件 记录答案 找更小的\n    {\n        ans = m;\n        r = m - 1;\n    }\n    else // 不满足条件 找更大的\n    {\n        l = m + 1;\n    }\n    return ans;\n}\nf函数如下：\nbool f(int m, vector&lt;int&gt; &amp;nums, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;i: nums)\n    {\n        ans += (i + m - 1) / m; // 上取整 注意能不用ceil就不用ceil 可能造成精度丢失\n        if (ans &gt; target) \n        {\n            return 0;\n        }\n    }\n    return 1;\n}\nleetcode2187\n问时间 我们尝试对时间进行二分\n最快时间应该是 ranges::min(time) 此时 totalTrips = 1\n最慢时间应该是 ranges::min(time) * totalTrips\n不难写出如下代码\nlong long minimumTime(vector&lt;int&gt; &amp;time, int totalTrips)\n{\n    // 二分时间\n    long long l = ranges::min(time), r = l * totalTrips, m, ans;\n    while (l &lt;= r)\n    {\n        m = l + (r - l) / 2;\n \n        if (f(m, time, totalTrips)) ans = m, r = m - 1;\n        else l = m + 1;\n    }\n    return ans;\n}\nf函数也就是常规的加一遍：\nbool f(long long m, vector&lt;int&gt;&amp; time, int target)\n{\n    int ans = 0;\n    for (auto &amp;&amp;t : time)\n    {\n        ans += m / t;\n        if (ans &gt;= target)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}\n难而杂的例题\nleetcode875\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：有没有可能速度为0?\n当且仅当数组全部都是0的时候 每小时0根也肯定可以吃完\n题目中说到香蕉数量&gt;= 1 那么不可能是0\n因此 最慢速度就是1\n思考：最快速度是多少\n应当为 数组中的最大元素 （一堆最多的香蕉）\n思考：速度再快有意义吗？\n没有了 我们需要用到二分法 那么初始的范围小 对我们的二分是有益的\n\n\n\n经过分析 我们可以得出 速度的取值应当在 [1, *max_element(piles.begin(), piles.end())]\n不难发现：随着速度的增大 吃掉所有香蕉用掉的小时数 只可能不严格单调递减  速度变大反而耗时变多的情况是不存在的\n那我们就可以对速度进行二分  进而求出小时数\nac codes are as follows:\nclass Solution\n{\npublic:\n    int minEatingSpeed(vector&lt;int&gt; &amp;piles, int h)\n    {\n        int l = 1, r = *max_element(piles.begin(), piles.end());\n \n        int ans = 0;\n        int mid = 0;\n        while (l &lt;= r)\n        {\n            mid = l + (r - l) / 2;\n            /*\n            这个mid是什么？是速度\n            我们要求什么？求时间\n            因此我们应该遍历整个香蕉数组， 把用时求出来 和 h 进行比较\n            */\n            long long h1 = 0; // h1 就是 用时 实际比赛的时候我们其实可以#define int long long\n            for (auto &amp;&amp;pile : piles)\n            {\n                /*\n                是熟悉的区间分割诶！\n                我的拙劣的讲解视频 BV15QcAefE5j\n                区间是 mid\n                要划分的变量是 pile\n                用时就是 (pile - 1) / mid + 1\n                我们其实也可以写成\n                (pile + mid - 1) / mid\n                \n                by the way 他的本质其实是 pile / mid 结果向上取整\n                */\n \n                h1 += (pile - 1) / mid + 1;\n            }\n \n            if (h1 &lt;= h) // 当前用时达标！更新答案 放慢速度\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标！增加速度\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n这里有一个很实用的技巧 就是把 速度 → 时间 的变化作为函数封装起来\n具体来说我们有\nint f(vector&lt;int&gt; &amp;piles, int k)\n{\n    int ans = 0;\n    \n    for (auto&amp;&amp; p: piles) ans += (p + k - 1) / k;\n    \n    return ans;\n}\n此处被 return 的 ans 将作为 h1 与 h 进行比较\n这也就是我第3步说的 建立f函数\nleetcode410\n看到「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。\n为什么？「元素和的最大值」越小，需要划分出的段数就越多，反之越少。例如示例 1 的 nums = [7,2,5,10,8]，在最大和为 15 时，至少要划分 3 段，比如 [7,2,5],[10],[8]。而在最大和为 18 时，只需要划分 2 段，比如 [7,2,5],[10,8]。\n一般地，二分的值越小，越不能/能满足要求；二分的值越大，越能/不能满足要求。有单调性的保证，就可以二分答案了。\n\n\n                  \n                  Important\n                  \n                \n\n\n思考：如何保证二分结果一定能划分成 k 段？如果小于 k 段呢？\n题目要求划分成 k 段，但其实如果能划分成小于 k 段，也可以划分成 k 段。比如划分成 k−1 段，那么把其中的一个长度至少为 2 的段分成两段，这两段的元素和都比原来的一段小，也满足要求。所以题目相当于：把数组划分成至多 k 段，分别计算每一段的元素和，最小化元素和的最大值。\n应当注意的是， k的取值是 1 &lt;= k &lt;= min(50, nums.length) 这意味着k不会取一个天花乱坠的数字 我们能保证大部分情况下k &lt;= nums.size()  这就够了\n\n\n\n题目问我们最大值 我们就尝试二分最大值\n最大的最大值是多少？k = 1 时数组和的最大值最大 就是accumulate(nums.begin(), nums.end())\n最小的最大值是多少？k = nums.size() 时数组和的最大值最小 是 max_element(nums.begin(), nums.end())\n如何把最大值 跟 k 联系起来？\nf函数参考如下：\nint f(vector&lt;int&gt; nums, int m)\n    {\n        int ans = 1, sum = 0; // 一开始只需要分一段\n \n        for (auto &amp;&amp;i : nums)\n        {\n            if (sum + i &lt;= m) // 如果最大值没超过 那么最大值可以继续增加\n            {\n                sum += i;\n            }\n            else // 超过了就需要增加一段了 与此同时 sum 更新为新的一段\n            {\n                ans++;\n                sum = i;\n            }\n        }\n        return ans;\n    }\n有了这个函数 我们就找到了最大值和段数的关系 那么我们只需要不断二分最大值 让段数逐渐接近k就行\nac codes are as follows:\nint splitArray(vector&lt;int&gt; &amp;nums, int k)\n    {\n        long long sum = accumulate(nums.begin(), nums.end(), 0ll);\n        // 二分的是最大值 要求的答案是k\n        // k 可以尽可能小 因为小于k段却满足条件 我们大可以把其中的一些段分开 也不会影响答案\n        long long ans = 0;\n \n        long long l = *max_element(nums.begin(), nums.end()), r = sum, mid, need;\n        while (l &lt;= r)\n        {\n            // 必须让每一部分的累加和 &lt;= mid， 请问划分成几个部分才够？\n \n            mid = l + (r - l) / 2;\n \n            need = f(nums, mid); // need 是最大值为 mid 所需要的段数\n \n            if (need &lt;= k) // 达标 更新答案 缩小右区间 找更小的最大值\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else // 未达标 缩小左区间 找更大的最大值\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n\n                  \n                  Important\n                  \n                \n\n\n在f函数中 我们就可以适当的暴力一点 因为f是为二分服务的 而二分本身复杂度就已经很低了\n\n\n\n看完这两题是不是有一点体会了？有的兄弟有的，这样的例题还有一堆\n现在是 20250114 00：01：32\n牛客 机器人跳跃问题\n看到问能量值 那我们尝试二分能量值\n首先要确定能量值的边界\n我们来分析题目：能量值比楼房的高度小 反而要减少 比楼房的高度高 反而要增大\n那我们只需要让他的高度比所有的楼房都要高 不就一定能通过吗\n因此 r = *max_element(v.begin(), v.end())\n那么我们最起码要让他安然无恙的通过最矮的楼房 否则就必定无法通过\n因此 l = *min_element(v.begin(), v.end())\n\n\n                  \n                  Important\n                  \n                \n\n\n最大值最小值的写法在cpp20中已经得到了进一步优化\n我们可以使用 ranges::max(v)  和 ranges::min(v) 来快速求数组的最大 最小值\n\n\n\n那我们写f函数的目的也就随之确定下来， 即：\n给定一个能量值 判断这个能量值是否可以通过所有楼房\nbool f(vector&lt;int&gt; v /* 所有楼房高度 */, int e /* 能量 */, int max_ /* 最大建筑高度 */)\n{\n    for (auto &amp;&amp;i: v)\n    {\n        if (e &gt; i) e += (e - i);\n        else e -= (i - e);\n        \n        // 判断是否达到上边界\n        if (e &gt;= max) return 1;\n        // 判断是否变成负数\n        if (e &lt; 0) return 0;\n    }\n    return 1;\n}\n有了f函数 我们就可以写出二分答案的流程\nvoid solve()\n{\n\tint n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; v(n);\n    for (auto &amp;&amp;i: v) cin &gt;&gt; i;\n    \n    auto l = ranges::min(v), r = ranges::max(v);\n    auto max_ = r;\n    \n    int mid, ans;\n    \n    while (l &lt;= r)\n    {\n        mid = l + (r - l) / 2; // 时刻牢记 mid 是初始能量\n        \n        // 给定能量 用f来验证是否满足题意\n        if (f(v, mid, max_)) // 满足条件 找更小的\n        {\n            ans = mid;\n            r = mid - 1;\n        }\n        else // 不满足条件 找更大的\n        {\n            l = mid + 1;\n        }\n    }\n    cout &lt;&lt; ans;\n}\nleetcode719\nac codes are as follows:\nclass Solution\n{\npublic:\n    int f(vector&lt;int&gt; nums, int lim)\n    {\n        int ans = 0;\n        int r = 0;\n        for (int l = 0; l &lt; nums.size(); l++)\n        {\n            while (r &lt; nums.size() and nums[r] - nums[l] &lt;= lim)\n            {\n                r++;\n            }\n            ans += r - l - 1;\n        }\n        return ans;\n    }\n \n    int smallestDistancePair(vector&lt;int&gt; &amp;nums, int k)\n    {\n        ranges::sort(nums);\n \n        long long l = 0, r = nums.back() - nums.front();\n \n        long long mid, ans, cur;\n \n        while (l &lt;= r)\n        {\n            // 我们再对数字差作二分\n            mid = l + (r - l) / 2;\n            // 要验证是否是第k小 只需要遍历看看 差值 &lt;= mid 的 是否有k个\n            if (f(nums, mid) &gt;= k) // 有可能有更小的 因为 f里面提到 差值 &lt;= mid 即可\n            {\n                ans = mid;\n                r = mid - 1;\n            }\n            else\n            {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\nf函数的构造比较复杂 值得细品…\nleetcode2141\n并查集\n并查集解决的是怎样的问题呢？就是对集合的 合并 查询\n要想比较高效的完成合并查询工作 我们需要两个数组：father 和  sz， 一个模拟递归的栈stk\n板子：\n初始化：\nvector&lt;int&gt; father, siz;\nstack&lt;int&gt; stk;\n \nvoid init(int n) {\n    father.resize(n);\n    siz.resize(n, 1);\n    ranges::iota(father, 0ll);  // father[i] 初始时指向自己\n}\n完全体：\n// 查找父节点，路径压缩\nint ffind(int i) {\n    while (father[i] != i) {\n        // 递归查找并压缩路径, 使用栈优化递归\n        stk.push(i);\n        i = father[i];\n    }\n    while (!stk.empty())\n    {\n        father[stk.top()] = i; // 将栈中的节点都指向根节点\n        stk.pop();\n    }\n    return father[i];\n}\n \n// 合并两个集合，按秩合并\nvoid union(int i, int j) {\n    int rootI = ffind(i);\n    int rootJ = ffind(j);\n \n    if (rootI != rootJ) {\n        // 按树的大小（秩）合并\n        if (siz[rootI] &lt; siz[rootJ]) {\n            swap(rootI, rootJ);  // 确保 rootI 永远是较大的树\n        }\n        father[rootJ] = rootI;  // 将 rootJ 的根节点指向 rootI\n        siz[rootI] += siz[rootJ];  // 更新 rootI 的大小\n    }\n}\n \nbool issame(int i, int j)\n{\n\treturn ffind(i) == ffind(j);\n}\n精简化写法：\nint ffind(int n)\n{\n    if (n != father[n])\n    {\n        father[n] = ffind(father[n]);\n    }\n    return father[n];\n}\n \nvoid funion(int i, int j)\n{\n\tfather[i] = j;\n}\n \nbool issame(int i, int j)\n{\n    return ffind(i) == ffind(j);\n}\nluoguP3367\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j)\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n    init(n);\n    int a, b, c;\n    while (m--)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        b--, c--; // 0 based\n        if (a == 1)\n        {\n            funion(b, c);\n        }\n        else\n        {\n            cout &lt;&lt; (issame(b, c) ? &#039;Y&#039; : &#039;N&#039;) &lt;&lt; endl;\n        }\n    }\n}\nDFS\n板子：\nvector&lt;pair&lt;int, int&gt;&gt; d = {{1, 0}, {0, 1}{-1, 0}, {0, -1}};\n \nvoid dfs(int i, int j, vector&lt;vector&lt;int&gt;&gt; grid)\n{\n    if (i &lt; 0 or i == grid.size() or j &lt; 0 or j == grid[0].size() or grid[i][j] != 0)\n    {\n        return;\n    }\n    \n    grid[i][j] = 2; // 与原先不同的标记\n    \n    for (auto &amp;&amp;[x, y]: d)\n    {\n        dfs(i + x, j + y, grid);\n    }\n}\n图\n图的表示\n邻接表\nunordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj; // v1, v2, val\n邻接矩阵\n图的遍历\ndfs\nbfs\n图算法\n最小生成树 （MST，Minimum Spanning Tree）\n什么是最小生成树？ 最小生成树是所有节点的最小联通子图， 即：用最小的成本（边的权值）将所有的节点连接到一起\n假如存在 n 个节点 那么必定可以用 n - 1 条边将他们连接到一起， 如何选择这 n - 1 条边就是任务所在\nprim\n\n\n                  \n                  Important\n                  \n                \n\n\n\n解锁的点的放入 set、解锁的边的集合叫 heap（小根堆）。一开始 set 和 heap 都为空。\n可从任意点开始，开始点加入到 set，开始点的所有边加入到 heap\n从 heap 中弹出权值最小的边 e，查看边 e 所去往的点 x\n\n如果 x 已经在 set 中，边 e舍弃，重复步骤3\n如果 x不在 set 中，边 e 属于最小生成树，把 x 加入 set ，重复步骤3\n\n\n当 heap 为空，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m; // n为顶点数，m为边数\n    cin &gt;&gt; n &gt;&gt; m;\n    // prim\n    set&lt;int&gt; nodes; // 存储已访问的节点\n \n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq; // 小顶堆，存储边{权重,目标顶点}\n \n    int MSTweight = 0; // 最小生成树的总权重\n \n    int v1, v2, val; // v1,v2为边的两个顶点，val为边的权重\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表存储图，adj[u]存储u的所有邻边{顶点,权重}\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        // 无向图需要添加两条边\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    pq.push({0, 1}); // 从顶点1开始，初始权重为0\n \n    while (pq.size())\n    {\n        auto [curw, cur] = pq.top(); // curw为当前边的权重，cur为当前顶点\n        pq.pop();\n \n        if (nodes.count(cur)) // 如果当前顶点已访问，跳过\n        {\n            continue;\n        }\n \n        nodes.insert(cur); // 将当前顶点标记为已访问\n        MSTweight += curw; // 将当前边的权重加入最小生成树的总权重\n \n        // 遍历当前顶点的所有邻边\n        for (auto &amp;&amp;[next, nextw] : adj[cur]) // next为邻接顶点，nextw为边权重\n        {\n            if (!nodes.count(next)) // 如果邻接顶点未访问\n            {\n                pq.push({nextw, next}); // 将边加入优先队列\n            }\n        }\n    }\n    if (nodes.size() != n) // 如果访问的顶点数不等于总顶点数，说明图不连通\n    {\n        cout &lt;&lt; &quot;orz&quot;; // 输出无解\n    }\n    else\n    {\n        cout &lt;&lt; MSTweight; // 输出最小生成树的总权重\n    }\n}\nkruskal\n\n\n                  \n                  Important\n                  \n                \n\n\n\n把所有的边，根据权值从小到大排序，从权值小的边开始考虑\n如果连接当前的边不会形成环，就选择当前的边\n如果连接当前的边会形成环，就不要当前的边\n考察完所有边之后，最小生成树也就得到了\n\n\n\n\nluoguP3366\nvoid solve()\n{\n    int n, m, v1, v2, val;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    struct Data\n    {\n        int v1, v2, val;\n    };\n    vector&lt;Data&gt; datas;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        v1--, v2--;\n        if (v1 != v2)\n        {\n            datas.push_back({v1, v2, val});\n        }\n    }\n \n    // kruskal\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n);\n        iota(all(father), 0);\n    };\n \n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : father[i] = ffind(father[i]);\n    };\n \n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri - rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n \n    // FU end\n \n    ranges::sort(datas, [](Data &amp;a, Data &amp;b)\n                 { return a.val &lt; b.val; });\n \n    init(5001);\n    int ans = 0, count = 0;\n \n    vector&lt;bool&gt; visited(n, 0);\n    for (auto &amp;&amp;[v1, v2, val] : datas)\n    {\n        if (!issame(v1, v2))\n        {\n            visited[v1] = visited[v2] = 1;\n            ans += val;\n            funion(v1, v2);\n            count++;\n        }\n    }\n \n    if (count == n - 1)\n    {\n        cout &lt;&lt; ans;\n    }\n    else\n    {\n        cout &lt;&lt; &quot;orz&quot;;\n    }\n}\n拓扑排序\nluoguB3644\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    int num;\n \n    // 没有边权的邻接表\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj;\n    // 入度\n    vector&lt;int&gt; indegree(n + 1, 0); // 1 based\n    vector&lt;int&gt; result;\n \n    for (int i = 1; i &lt;= n; i++)\n    {\n        adj[i];\n        while (cin &gt;&gt; num)\n        {\n            if (num == 0)\n            {\n                break;\n            }\n            adj[i].push_back(num);\n            indegree[num]++; // 入度， 入度！\n        }\n    }\n \n    // 拓扑\n    queue&lt;int&gt; que;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        // 入度为0 可以作为开头 假如队列\n        if (indegree[i] == 0)\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    for (auto &amp;&amp;i : result)\n    {\n        cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n    }\n}\nKMP\nvector&lt;int&gt; getnext(string s)\n{\n\tint n = s.size();\n\tvector&lt;int&gt; v(n, 0);\n\tint j = 0; // 前缀长度\n\tfor (int i = 1; i &lt; n; i++)\n\t{\n\t\twhile (j and s[i] != s[j])\n\t\t{\n\t\t\tj = v[j - 1];\n\t\t}\n\t\tif (s[i] == s[j])\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tv[i] = j;\n\t}\n\treturn v;\n}\n \n "},"ACM-research/很杂乱的板子":{"slug":"ACM-research/很杂乱的板子","filePath":"ACM research/很杂乱的板子.md","title":"很杂乱的板子","links":[],"tags":[],"content":"// 大数加法\nstring largeadd(string &amp;a, string &amp;b)\n{\n    if (a.size() &lt; b.size())\n        swap(a, b);\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        int bi = b[b.size() - i - 1] - &#039;0&#039;;\n        int sum = ai + bi + p;\n        if (sum &gt;= 10)\n        {\n            p = 1;\n            sum -= 10;\n        }\n        else\n            p = 0;\n        a[a.size() - 1 - i] = sum + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == &#039;9&#039; &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;0&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai + p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    if (p == 1)\n        a.insert(a.begin(), &#039;1&#039;);\n    return a;\n}\n// 大数减法\nstring largemin(string a, string b)\n{\n    int flag = 0;\n    if (b.size() &gt;= a.size() &amp;&amp; b &gt;= a)\n    {\n        swap(a, b);\n        flag = 1;\n    }\n    int p = 0;\n    for (size_t i = 0; i &lt; b.size(); i++)\n    {\n        int ai = a[a.size() - 1 - i] - &#039;0&#039;;\n        int bi = b[b.size() - 1 - i] - &#039;0&#039;;\n        int diff = ai - bi - p;\n        if (diff &lt; 0)\n        {\n            p = 1;\n            diff += 10;\n        }\n        else\n            p = 0;\n        a[a.size() - i - 1] = diff + &#039;0&#039;;\n    }\n    for (size_t i = b.size(); i &lt; a.size(); i++)\n    {\n        int ai = a[a.size() - i - 1] - &#039;0&#039;;\n        if (ai == 0 &amp;&amp; p == 1)\n        {\n            a[a.size() - i - 1] = &#039;9&#039;;\n        }\n        else\n        {\n            a[a.size() - i - 1] = ai - p + &#039;0&#039;;\n            p = 0;\n        }\n    }\n    while (*a.begin() == &#039;0&#039; &amp;&amp; a.size() &gt; 1)\n        a.erase(a.begin());\n    if (flag)\n        a.insert(a.begin(), &#039;-&#039;);\n    return a;\n}\n \n// DSU并查集\nclass DSU\n{\nprivate:\n    vector&lt;int&gt; parent, rank, size;\n    int count;\n \npublic:\n    DSU(int n) : parent(n + 1), rank(n + 1, 0), size(n + 1, 1), count(n)\n    {\n        iota(all(parent), 0ll);\n    }\n \n    int find(int x)\n    {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    }\n \n    void merge(int i, int j)\n    {\n        int ri = find(i), rj = find(j);\n        if (ri == rj)\n        {\n            return;\n        }\n \n        if (rank[ri] &lt; rank[rj])\n        {\n            swap(ri, rj);\n        }\n        parent[rj] = ri;\n        size[ri] += size[rj];\n        if (rank[ri] == rank[rj])\n        {\n            rank[ri]++;\n        }\n        count--;\n    }\n \n    bool issame(int i, int j)\n    {\n        return find(i) == find(j);\n    }\n \n    int getsize(int x)\n    {\n        return size[find(x)];\n    }\n \n    int getgroups()\n    {\n        return count;\n    }\n};\n// DSU end\n \n// COMB 组合数 快速幂，乘法逆元 都在里面\nconst int N = 1e6;\nvector&lt;int&gt; f(N), invf(N);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n    int ans = 1;\n    while (exp)\n    {\n        if (exp &amp; 1)\n        {\n            ans = ans * base % MOD;\n        }\n        base = base * base % MOD;\n        exp &gt;&gt;= 1;\n    }\n    return ans;\n}\n \nint inv(int x)\n{\n    return ksm(x, MOD - 2) % MOD;\n}\n \nvoid pre()\n{\n    if (inited)\n    {\n        return;\n    }\n    inited = 1;\n    f[0] = 1;\n    for (int i = 1; i &lt; N; i++)\n    {\n        f[i] = f[i - 1] * i % MOD;\n    }\n \n    invf[N - 1] = inv(f[N - 1]);\n    for (int i = N - 2; i &gt;= 0; i--)\n    {\n        invf[i] = invf[i + 1] * (i + 1) % MOD;\n    }\n}\n \nint comb(int n, int k)\n{\n    if (!inited)\n    {\n        pre();\n    }\n    if (k &lt; 0 or k &gt; n)\n    {\n        return 0;\n    }\n \n    return f[n] * invf[k] % MOD * invf[n - k] % MOD;\n}\n// comb end ----\n \n// 马拉车\n \n// 预处理\nstring preprocess(const string &amp;s)\n{\n    string t = &quot;^&quot;;\n    for (char c : s)\n    {\n        t += &quot;#&quot; + string(1, c);\n    }\n    t += &quot;#$&quot;;\n    return t;\n}\n \nstring longestPalindrome(const string &amp;s)\n{\n    string T = preprocess(s);\n    int n = T.size();\n    vector&lt;int&gt; P(n, 0); // P[i] 记录以 t[i] 为中心的回文半径\n    int C = 0, R = 0;    // C 是回文中心，R 是回文串的最右边界\n    for (size_t i = 1; i &lt; n - 1; i++)\n    {\n        // 确定对称位置\n        int Mirror = 2 * C - i;\n        if (i &lt; R)\n        {\n            P[i] = min(P[Mirror], R - i);\n        }\n        // 尝试扩展边界\n        while (T[i + 1 + P[i]] == T[i - 1 - P[i]])\n        {\n            P[i]++;\n        }\n        // 如果当前回文串扩展超过了 R，更新中心和右边界\n        if (i + P[i] &gt; R)\n        {\n            C = i;\n            R = i + P[i];\n        }\n    }\n    // 找到最长的回文子串\n    int maxLen = 0;\n    int Centerindex = 0;\n    for (size_t i = 0; i &lt; n - 1; i++)\n    {\n        if (P[i] &gt; maxLen)\n        {\n            maxLen = P[i];\n            Centerindex = i;\n        }\n    }\n    // 构造回文串\n    int start = (Centerindex - maxLen) / 2;\n    return s.substr(start, maxLen);\n}\n \nsigned main()\n{\n    // ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; longestPalindrome(s) &lt;&lt; endl;\n    return 0;\n}\n// end ---\n \n// BIT 树状数组\n \nclass BIT\n{\nprivate:\n    vector&lt;int&gt; c;\n    int n;\n \n    int lowbit(int x)\n    {\n        return x &amp; -x;\n    }\n \npublic:\n    BIT(int size) : n(size)\n    {\n        c.resize(n + 1, 0);\n    }\n \n    BIT(vector&lt;int&gt; &amp;arr) : n(arr.size())\n    {\n        c.resize(n + 1, 0);\n        for (int i = 1; i &lt;= n; i++)\n        {\n            add(i, arr[i - 1]);\n        }\n    }\n \n    void add(int i, int val)\n    {\n        while (i &lt;= n)\n        {\n            c[i] += val;\n            i += lowbit(i);\n        }\n    }\n \n    int sum(int i)\n    {\n        int ans = 0;\n        while (i)\n        {\n            ans += c[i];\n            i -= lowbit(i);\n        }\n        return ans;\n    }\n \n    int query(int l, int r)\n    {\n        return sum(r) - sum(l - 1);\n    }\n \n    int get(int i)\n    {\n        return query(i, i);\n    }\n \n    int update(int i, int val)\n    {\n        auto delta = val = get(i);\n        add(i, delta);\n    }\n \n    void clear()\n    {\n        fill(all(c), 0);\n    }\n \n    // 获取树状数组的大小\n    int size()\n    {\n        return n;\n    }\n};\n \n// BIT end\n \n// 大数模下幂运算\n \n// 快速幂函数，计算 base^exponent mod mod\nlong long modPow(long long base, long long exponent, long long mod)\n{\n    long long result = 1;\n    base %= mod;\n    while (exponent &gt; 0)\n    {\n        if (exponent &amp; 1)\n            result = (result * base) % mod;\n        base = (base * base) % mod;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n \nvoid solve()\n{\n    long long x, p;\n    string y;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;\n    // 对 x 取模（防止数字过大）\n    x %= p;\n    // 特判：若 y 为 &quot;0&quot;，根据数学通常规定 x^0 = 1（注意：0^0一般认为1也可以根据题意而定）\n    if (y == &quot;0&quot;)\n    {\n        cout &lt;&lt; 1 % p &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    // 答案初始为 1\n    long long ans = 1;\n    // 对指数 y 的每一位进行处理\n    for (char c : y)\n    {\n        int d = c - &#039;0&#039;;\n        // 将当前答案提升 10 次方后再乘上 x^d mod p\n        ans = modPow(ans, 10, p);\n        ans = (ans * modPow(x, d, p)) % p;\n    }\n    cout &lt;&lt; ans % p &lt;&lt; &quot;\\n&quot;;\n}\n \n// 大树模下 end ---\n \n// 很多DP\n \n// --------------------- 基础DP问题 ---------------------\n \n// 01背包问题 - 每个物品最多选一次\nint knapsack01(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = capacity; j &gt;= weights[i]; j--)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 完全背包问题 - 每个物品可以选无限次\nint knapsackComplete(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        for (int j = weights[i]; j &lt;= capacity; j++)\n        {\n            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 多重背包问题 - 每个物品有特定数量限制\nint knapsackMultiple(const vector&lt;int&gt; &amp;weights, const vector&lt;int&gt; &amp;values,\n                     const vector&lt;int&gt; &amp;counts, int capacity)\n{\n    int n = weights.size();\n    vector&lt;int&gt; dp(capacity + 1, 0);\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        // 二进制优化 - 将k个物品拆成二进制表示\n        int w = weights[i], v = values[i], c = counts[i];\n        for (int k = 1; k &lt;= c; k *= 2)\n        {\n            for (int j = capacity; j &gt;= k * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - k * w] + k * v);\n            }\n            c -= k;\n        }\n \n        if (c &gt; 0)\n        {\n            for (int j = capacity; j &gt;= c * w; j--)\n            {\n                dp[j] = max(dp[j], dp[j - c * w] + c * v);\n            }\n        }\n    }\n \n    return dp[capacity];\n}\n \n// 最长递增子序列 (LIS)\nint longestIncreasingSubsequence(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; dp(n, 1);\n \n    for (int i = 1; i &lt; n; i++)\n    {\n        for (int j = 0; j &lt; i; j++)\n        {\n            if (nums[i] &gt; nums[j])\n            {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n \n    return *max_element(dp.begin(), dp.end());\n}\n \n// 最长递增子序列优化版 (O(nlogn))\nint longestIncreasingSubsequenceOptimized(const vector&lt;int&gt; &amp;nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n \n    vector&lt;int&gt; tails;\n \n    for (int num : nums)\n    {\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n        if (it == tails.end())\n        {\n            tails.push_back(num);\n        }\n        else\n        {\n            *it = num;\n        }\n    }\n \n    return tails.size();\n}\n \n// 最长公共子序列 (LCS)\nint longestCommonSubsequence(const string &amp;text1, const string &amp;text2)\n{\n    int m = text1.size(), n = text2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (text1[i - 1] == text2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }\n            else\n            {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// 编辑距离\nint editDistance(const string &amp;word1, const string &amp;word2)\n{\n    int m = word1.size(), n = word2.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n \n    for (int i = 0; i &lt;= m; i++)\n        dp[i][0] = i;\n    for (int j = 0; j &lt;= n; j++)\n        dp[0][j] = j;\n \n    for (int i = 1; i &lt;= m; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (word1[i - 1] == word2[j - 1])\n            {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n            else\n            {\n                dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n            }\n        }\n    }\n \n    return dp[m][n];\n}\n \n// --------------------- 区间DP ---------------------\n \n// 石子合并问题 - 求合并代价最小值\nint mergeStones(const vector&lt;int&gt; &amp;stones)\n{\n    int n = stones.size();\n    if (n &lt;= 1)\n        return 0;\n \n    // 前缀和加速区间求和\n    vector&lt;int&gt; prefixSum(n + 1, 0);\n    for (int i = 0; i &lt; n; i++)\n    {\n        prefixSum[i + 1] = prefixSum[i] + stones[i];\n    }\n \n    // dp[i][j] 表示合并区间[i,j]的最小代价\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INF));\n \n    // 初始化：单个石子无需合并\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = 0;\n    }\n \n    // 按区间长度递推\n    for (int len = 2; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n \n            // 尝试在不同位置分割\n            for (int k = i; k &lt; j; k++)\n            {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefixSum[j + 1] - prefixSum[i]);\n            }\n        }\n    }\n \n    return dp[0][n - 1];\n}\n \n// --------------------- 树形DP ---------------------\n \n// 树的最大独立集 (在树上选择不相邻的节点使得权值和最大)\nvoid dfsIndependentSet(int node, int parent, const vector&lt;vector&lt;int&gt;&gt; &amp;tree,\n                       const vector&lt;int&gt; &amp;values, vector&lt;vector&lt;int&gt;&gt; &amp;dp)\n{\n    for (int child : tree[node])\n    {\n        if (child != parent)\n        {\n            dfsIndependentSet(child, node, tree, values, dp);\n            // dp[node][0] - 不选当前节点\n            dp[node][0] += max(dp[child][0], dp[child][1]);\n            // dp[node][1] - 选当前节点\n            dp[node][1] += dp[child][0];\n        }\n    }\n    dp[node][1] += values[node]; // 加上当前节点的权值\n}\n \nint maxIndependentSet(const vector&lt;vector&lt;int&gt;&gt; &amp;tree, const vector&lt;int&gt; &amp;values)\n{\n    int n = values.size();\n    // dp[i][0] - 不选节点i的最大值, dp[i][1] - 选节点i的最大值\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));\n \n    dfsIndependentSet(0, -1, tree, values, dp);\n    return max(dp[0][0], dp[0][1]);\n}\n \n// --------------------- 状态压缩DP ---------------------\n \n// 旅行商问题 (TSP)\nint tsp(const vector&lt;vector&lt;int&gt;&gt; &amp;dist)\n{\n    int n = dist.size();\n    // dp[mask][i] 表示已经访问的城市集合为mask，当前在城市i的最短路径\n    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; n, vector&lt;int&gt;(n, INF));\n \n    // 起点为城市0\n    dp[1][0] = 0; // 只访问城市0的状态\n \n    for (int mask = 1; mask &lt; (1 &lt;&lt; n); mask++)\n    {\n        for (int i = 0; i &lt; n; i++)\n        {\n            if ((mask &gt;&gt; i) &amp; 1)\n            { // 城市i已访问\n                for (int j = 0; j &lt; n; j++)\n                {\n                    if ((mask &gt;&gt; j) &amp; 1 &amp;&amp; i != j)\n                    { // 城市j也已访问\n                        dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 &lt;&lt; i)][j] + dist[j][i]);\n                    }\n                }\n            }\n        }\n    }\n \n    // 所有城市都访问并回到起点\n    int result = INF;\n    for (int i = 1; i &lt; n; i++)\n    {\n        if (dist[i][0] != INF)\n        {\n            result = min(result, dp[(1 &lt;&lt; n) - 1][i] + dist[i][0]);\n        }\n    }\n \n    return result;\n}\n \n// --------------------- 数位DP ---------------------\n \n// 计算区间[l,r]中满足条件的数字个数\nint digitDP(int l, int r)\n{\n    vector&lt;int&gt; digits;\n \n    // 数位分解函数\n    auto getDigits = [&amp;](int num)\n    {\n        vector&lt;int&gt; result;\n        while (num)\n        {\n            result.push_back(num % 10);\n            num /= 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    };\n \n    // DP函数，自行定义状态和转移方程\n    function&lt;int(int, bool, bool, int)&gt; dp = [&amp;](int pos, bool isLimit, bool isNum, int state)\n    {\n        // 实现特定问题的状态转移逻辑\n        // pos: 当前处理到的位置\n        // isLimit: 是否有上界限制\n        // isNum: 前面是否已经有数字了\n        // state: 问题相关的状态\n \n        if (pos == digits.size())\n        {\n            return isNum ? 1 : 0; // 根据具体问题调整返回值\n        }\n \n        // 这里补充具体问题的状态转移逻辑\n \n        return 0; // 占位返回\n    };\n \n    // 计算[0,r]的结果\n    digits = getDigits(r);\n    int right_result = dp(0, true, false, 0);\n \n    // 计算[0,l-1]的结果\n    digits = getDigits(l - 1);\n    int left_result = dp(0, true, false, 0);\n \n    // 返回区间结果\n    return right_result - left_result;\n}\n \n// --------------------- 概率DP ---------------------\n \n// 骰子问题 - 投掷n个骰子，点数和为target的概率\ndouble diceProb(int n, int target)\n{\n    if (target &lt; n || target &gt; 6 * n)\n        return 0.0;\n \n    vector&lt;vector&lt;double&gt;&gt; dp(n + 1, vector&lt;double&gt;(6 * n + 1, 0.0));\n    // 初始化：一个骰子\n    for (int i = 1; i &lt;= 6; i++)\n    {\n        dp[1][i] = 1.0 / 6.0;\n    }\n \n    for (int i = 2; i &lt;= n; i++)\n    {\n        for (int j = i; j &lt;= 6 * i; j++)\n        {\n            for (int k = 1; k &lt;= 6 &amp;&amp; k &lt; j; k++)\n            {\n                dp[i][j] += dp[i - 1][j - k] * (1.0 / 6.0);\n            }\n        }\n    }\n \n    return dp[n][target];\n}\n \n// --------------------- 实用DP子问题 ---------------------\n \n// 最大子序和 (Kadane算法)\nint maxSubArray(const vector&lt;int&gt; &amp;nums)\n{\n    int currMax = nums[0], globalMax = nums[0];\n \n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        currMax = max(nums[i], currMax + nums[i]);\n        globalMax = max(globalMax, currMax);\n    }\n \n    return globalMax;\n}\n \n// 最大子矩阵和\nint maxSubMatrix(const vector&lt;vector&lt;int&gt;&gt; &amp;matrix)\n{\n    if (matrix.empty() || matrix[0].empty())\n        return 0;\n \n    int rows = matrix.size(), cols = matrix[0].size();\n    int result = INT_MIN;\n \n    for (int left = 0; left &lt; cols; left++)\n    {\n        vector&lt;int&gt; tempSum(rows, 0);\n \n        for (int right = left; right &lt; cols; right++)\n        {\n            // 将二维问题转化为一维\n            for (int i = 0; i &lt; rows; i++)\n            {\n                tempSum[i] += matrix[i][right];\n            }\n \n            // 应用Kadane算法找一维最大子序和\n            int kadaneMax = tempSum[0];\n            int currMax = tempSum[0];\n \n            for (int i = 1; i &lt; rows; i++)\n            {\n                currMax = max(tempSum[i], currMax + tempSum[i]);\n                kadaneMax = max(kadaneMax, currMax);\n            }\n \n            result = max(result, kadaneMax);\n        }\n    }\n \n    return result;\n}\n \n// 最长回文子串\nstring longestPalindrome(const string &amp;s)\n{\n    int n = s.size();\n    if (n == 0)\n        return &quot;&quot;;\n \n    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));\n    int start = 0, maxLen = 1;\n \n    // 所有长度为1的子串都是回文\n    for (int i = 0; i &lt; n; i++)\n    {\n        dp[i][i] = true;\n    }\n \n    // 检查长度为2的子串\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (s[i] == s[i + 1])\n        {\n            dp[i][i + 1] = true;\n            start = i;\n            maxLen = 2;\n        }\n    }\n \n    // 检查长度大于2的子串\n    for (int len = 3; len &lt;= n; len++)\n    {\n        for (int i = 0; i &lt;= n - len; i++)\n        {\n            int j = i + len - 1;\n            if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1])\n            {\n                dp[i][j] = true;\n                start = i;\n                maxLen = len;\n            }\n        }\n    }\n \n    return s.substr(start, maxLen);\n}\n// 很多DP end\n \n// 拓扑\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, vector&lt;int&gt;&gt; adj; // 邻接表\n    vector&lt;int&gt; indegree(n, 0);          // 统计入度\n    vector&lt;int&gt; result;                  // 结果集合\n    int s, t;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t;\n        indegree[t]++;\n        adj[s].push_back(t);\n    }\n \n    queue&lt;int&gt; que;\n    for (int i = 0; i &lt; n; i++)\n    {\n        // 入度为0 可以作为开头 加入队列\n        if (!indegree[i])\n        {\n            que.push(i);\n        }\n    }\n \n    while (que.size())\n    {\n        auto cur = que.front();\n        que.pop();\n        result.push_back(cur);\n \n        if (adj[cur].size())\n        {\n            for (auto &amp;&amp;i : adj[cur])\n            {\n                indegree[i]--;\n                if (indegree[i] == 0)\n                {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    if (result.size() - n)\n    {\n        cout &lt;&lt; -1;\n    }\n    else\n    {\n        cout &lt;&lt; result;\n    }\n}\n// 拓扑end\n \n// 生成树 kru\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    struct Edge\n    {\n        int v1, v2, val;\n        Edge(int v1, int v2, int val) : v1(v1), v2(v2), val(val) {};\n    };\n    vector&lt;Edge&gt; edges;\n \n    int v1, v2, val;\n    while (m--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        auto [a, b] = minmax(v1, v2);\n        edges.emplace_back(a, b, val);\n    }\n    ranges::sort(edges, [](Edge &amp;a, Edge &amp;b)\n                 { return a.val &lt; b.val; });\n \n    // FU begin\n    vector&lt;int&gt; father;\n    auto init = [&amp;](int n)\n    {\n        father.resize(n + 1);\n        iota(father.begin(), father.end(), 0ll);\n    };\n    function&lt;int(int)&gt; ffind = [&amp;](int i)\n    {\n        return i == father[i] ? i : ffind(father[i]);\n    };\n    auto funion = [&amp;](int i, int j)\n    {\n        auto ri = ffind(i), rj = ffind(j);\n        if (ri != rj)\n        {\n            father[ri] = rj;\n        }\n    };\n \n    auto issame = [&amp;](int i, int j) -&gt; bool\n    {\n        return ffind(i) == ffind(j);\n    };\n    // FU end\n    init(n);\n \n    int MSTweight = 0, MSTnode = 0;\n \n    for (auto &amp;&amp;[v1, v2, val] : edges)\n    {\n        if (!issame(v1, v2))\n        {\n            funion(v1, v2);\n            MSTweight += val;\n            MSTnode++;\n        }\n        if (MSTnode == n - 1)\n        {\n            cout &lt;&lt; MSTnode;\n            return;\n        }\n    }\n    cout &lt;&lt; -1;\n    return;\n}\n// 生成树 kru end\n \n// 生成树 prim\nvoid solve()\n{\n    int v, e;\n    cin &gt;&gt; v &gt;&gt; e;\n    int vsz = v + 1;\n \n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(vsz + 1);\n    int v1, v2, val;\n    while (e--)\n    {\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;\n        adj[v1].emplace_back(v2, val);\n        adj[v2].emplace_back(v1, val);\n    }\n \n    // prim begin\n    vector&lt;int&gt; visited(vsz, 0), minDist(vsz, INFLL);\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;\n \n    minDist[1] = 0;\n    pq.push({0, 1});\n \n    int totalweight = 0, nodeInMST = 0;\n \n    while (pq.size())\n    {\n        auto [w, cur] = pq.top();\n        pq.pop();\n \n        if (visited[cur])\n        {\n            continue;\n        }\n \n        visited[cur] = 1;\n        totalweight += w;\n        nodeInMST++;\n \n        for (auto &amp;&amp;[next, nextw] : adj[cur])\n        {\n            if (visited[next])\n            {\n                continue;\n            }\n \n            if (nextw &lt; minDist[next])\n            {\n                minDist[next] = nextw;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n    if (nodeInMST != v)\n    {\n        cout &lt;&lt; -1;\n        return;\n    }\n    cout &lt;&lt; totalweight;\n}\n// prim end\n \n// ford 可以处理负环\nvoid solve()\n{\n    int n, m, s, t, v;\n    cin &gt;&gt; n &gt;&gt; m;\n    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; adj;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;\n        adj[s][t] = v;\n    }\n \n    vector&lt;int&gt; minDist(n + 1, INF);\n    minDist[1] = 0;\n \n    int _ = n - 1;\n    while (_--) //\n    {\n        for (auto &amp;&amp;[v1, v] : adj)\n        {\n            for (auto &amp;&amp;[v2, val] : v)\n            {\n                if (minDist[v1] != INF)\n                {\n                    minDist[v2] = min(minDist[v2], minDist[v1] + val);\n                }\n            }\n        }\n    }\n \n    if (minDist[n] == INF)\n    {\n        cout &lt;&lt; &quot;unconnected&quot;;\n    }\n    else\n    {\n        cout &lt;&lt; minDist[n];\n    }\n}\n// ford end\n \n// dijk\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n + 1); // 邻接表，pair&lt;节点, 距离&gt;\n    int s, e, v;\n    while (m--)\n    {\n        cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;\n        adj[s].push_back({e, v});\n    }\n \n    /*\n    堆优化版Dijkstra算法:\n    1. 使用优先队列维护当前所有可达但未访问的节点，按距离排序\n    2. 每次取出队列中距离最小的节点，标记为已访问\n    3. 更新该节点邻居的距离，并将新的可能路径加入队列\n    */\n \n    vector&lt;int&gt; minDist(n + 1, INT_MAX); // 每一个节点到源点的最小距离\n    vector&lt;bool&gt; visited(n + 1, false);  // 记录节点是否已被访问\n \n    int start = 1, en = n;\n    minDist[start] = 0;\n \n    // 优先队列，存储&lt;距离, 节点编号&gt;，按距离从小到大排序\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n    pq.push({0, start});\n \n    while (!pq.empty())\n    {\n        int dist = pq.top().first;\n        int cur = pq.top().second;\n        pq.pop();\n \n        if (visited[cur])\n            continue;        // 如果已经访问过，跳过\n        visited[cur] = true; // 标记为已访问\n \n        // 更新当前节点的所有邻居\n        for (const auto &amp;edge : adj[cur])\n        {\n            int next = edge.first;\n            int weight = edge.second;\n \n            if (!visited[next] &amp;&amp; minDist[cur] + weight &lt; minDist[next])\n            {\n                minDist[next] = minDist[cur] + weight;\n                pq.push({minDist[next], next});\n            }\n        }\n    }\n \n    cout &lt;&lt; (minDist[en] == INT_MAX ? -1 : minDist[en]);\n}\n// dijk end\n \n// 多源最短路 floyd\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector v(n + 1, vector&lt;int&gt;(n + 1, INT_MAX));\n    for (int i = 1; i &lt;= n; i++)\n    {\n        for (int j = 1; j &lt;= n; j++)\n        {\n            cin &gt;&gt; v[i][j];\n        }\n    }\n \n    // floyd\n    for (int k = 1; k &lt;= n; k++)\n    {\n        for (int i = 1; i &lt;= n; i++)\n        {\n            for (int j = 1; j &lt;= n; j++)\n            {\n                v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n            }\n        }\n    }\n}\n// flyd end\n"},"ACM-research/数据结构与算法/数据结构/PBDS":{"slug":"ACM-research/数据结构与算法/数据结构/PBDS","filePath":"ACM research/数据结构与算法/数据结构/PBDS.md","title":"PBDS","links":[],"tags":[],"content":"PBDS (Policy-Based Data Structures)\nPBDS 是 GCC 编译器提供的一套基于策略的数据结构库，包含了许多高效的数据结构，在算法竞赛中非常实用。\n引入头文件\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n核心数据结构\n1. ordered_set / ordered_map\n这是 PBDS 中最常用的数据结构，支持排序和按排名查找。\n基本定义\n// ordered_set：有序集合\ntypedef tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set;\n \n// ordered_map：有序映射\ntypedef tree&lt;int, int, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_map;\n \n// 支持重复元素的 multiset\ntypedef tree&lt;int, null_type, less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_multiset;\n基本操作\nvoid pbds_basic_demo() {\n    ordered_set s;\n \n    // 插入元素\n    s.insert(1);\n    s.insert(3);\n    s.insert(5);\n    s.insert(7);\n \n    // 查找第 k 小的元素（0-indexed）\n    cout &lt;&lt; *s.find_by_order(0) &lt;&lt; endl;  // 输出 1（第 0 小）\n    cout &lt;&lt; *s.find_by_order(2) &lt;&lt; endl;  // 输出 5（第 2 小）\n \n    // 查找小于 x 的元素个数\n    cout &lt;&lt; s.order_of_key(5) &lt;&lt; endl;    // 输出 2（小于 5 的有 1,3）\n    cout &lt;&lt; s.order_of_key(6) &lt;&lt; endl;    // 输出 3（小于 6 的有 1,3,5）\n \n    // 删除元素\n    s.erase(3);\n \n    // 普通 set 的操作也支持\n    cout &lt;&lt; s.size() &lt;&lt; endl;             // 输出 3\n    cout &lt;&lt; s.count(5) &lt;&lt; endl;           // 输出 1\n}\n处理重复元素\nvoid multiset_demo() {\n    // 方法1：使用 less_equal\n    typedef tree&lt;int, null_type, less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_multiset;\n \n    ordered_multiset ms;\n    ms.insert(1);\n    ms.insert(1);\n    ms.insert(2);\n    ms.insert(2);\n    ms.insert(2);\n \n    cout &lt;&lt; ms.order_of_key(2) &lt;&lt; endl;    // 小于 2 的元素个数\n    cout &lt;&lt; *ms.find_by_order(2) &lt;&lt; endl;  // 第 2 小的元素\n \n    // 删除一个特定值（注意：less_equal 下删除会删除所有相同元素）\n    ms.erase(ms.find_by_order(ms.order_of_key(2)));\n \n    // 方法2：使用 pair 处理重复元素\n    typedef tree&lt;pair&lt;int, int&gt;, null_type, less&lt;pair&lt;int, int&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set_with_duplicates;\n \n    ordered_set_with_duplicates s2;\n    int cnt = 0;\n    s2.insert({1, cnt++});  // {value, unique_id}\n    s2.insert({1, cnt++});\n    s2.insert({2, cnt++});\n \n    // 查找值为 x 的元素个数\n    auto lower = s2.lower_bound({1, -1});\n    auto upper = s2.lower_bound({2, -1});\n    cout &lt;&lt; &quot;值为 1 的元素个数: &quot; &lt;&lt; distance(lower, upper) &lt;&lt; endl;\n}\n2. 优先队列 (priority_queue)\nPBDS 提供了更灵活的优先队列实现：\n#include &lt;ext/pb_ds/priority_queue.hpp&gt;\n \nvoid priority_queue_demo() {\n    // 不同类型的优先队列\n    __gnu_pbds::priority_queue&lt;int&gt; pq1;  // 默认：二叉堆\n    __gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; pq2;  // 配对堆，最小堆\n    __gnu_pbds::priority_queue&lt;int, less&lt;int&gt;, thin_heap_tag&gt; pq3;  // 斐波那契堆\n \n    // 支持修改操作的优先队列\n    typedef __gnu_pbds::priority_queue&lt;int&gt;::point_iterator pq_iterator;\n    __gnu_pbds::priority_queue&lt;int&gt; pq;\n \n    // 插入并获取迭代器\n    pq_iterator it1 = pq.push(10);\n    pq_iterator it2 = pq.push(20);\n    pq_iterator it3 = pq.push(5);\n \n    cout &lt;&lt; &quot;Top: &quot; &lt;&lt; pq.top() &lt;&lt; endl;  // 输出 20\n \n    // 修改指定位置的值\n    pq.modify(it1, 25);  // 将 10 修改为 25\n    cout &lt;&lt; &quot;New top: &quot; &lt;&lt; pq.top() &lt;&lt; endl;  // 输出 25\n \n    // 删除指定位置的元素\n    pq.erase(it2);\n \n    // 合并两个优先队列\n    __gnu_pbds::priority_queue&lt;int&gt; pq_other;\n    pq_other.push(15);\n    pq_other.push(30);\n    pq.join(pq_other);  // pq_other 会被清空\n}\n3. 哈希表 (gp_hash_table / cc_hash_table)\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n \nvoid hash_table_demo() {\n    // gp_hash_table：基于探测的哈希表\n    __gnu_pbds::gp_hash_table&lt;int, int&gt; gp_ht;\n \n    // cc_hash_table：基于链式的哈希表\n    __gnu_pbds::cc_hash_table&lt;int, int&gt; cc_ht;\n \n    // 基本操作\n    gp_ht[1] = 10;\n    gp_ht[2] = 20;\n    cc_ht[1] = 100;\n    cc_ht[2] = 200;\n \n    cout &lt;&lt; gp_ht[1] &lt;&lt; &quot; &quot; &lt;&lt; cc_ht[1] &lt;&lt; endl;\n \n    // 自定义哈希函数\n    struct custom_hash {\n        size_t operator()(const pair&lt;int, int&gt;&amp; p) const {\n            return hash&lt;int&gt;()(p.first) ^ (hash&lt;int&gt;()(p.second) &lt;&lt; 1);\n        }\n    };\n \n    __gnu_pbds::gp_hash_table&lt;pair&lt;int, int&gt;, int, custom_hash&gt; custom_ht;\n    custom_ht[{1, 2}] = 42;\n}\n实战应用\n1. 求逆序对\nlong long count_inversions(vector&lt;int&gt;&amp; arr) {\n    ordered_set s;\n    long long inversions = 0;\n \n    for (int i = arr.size() - 1; i &gt;= 0; i--) {\n        // 小于 arr[i] 的元素个数就是以 arr[i] 为左端点的逆序对数\n        inversions += s.order_of_key(arr[i]);\n        s.insert(arr[i]);\n    }\n \n    return inversions;\n}\n2. 动态第 k 小\nclass KthLargest {\nprivate:\n    ordered_set s;\n    int k;\n \npublic:\n    KthLargest(int k) : k(k) {}\n \n    void add(int val) {\n        s.insert(val);\n    }\n \n    int kthLargest() {\n        if (s.size() &lt; k) return -1;\n        return *s.find_by_order(s.size() - k);  // 第 k 大 = 第 (n-k) 小\n    }\n \n    int kthSmallest() {\n        if (s.size() &lt; k) return -1;\n        return *s.find_by_order(k - 1);  // 第 k 小（0-indexed）\n    }\n};\n3. 区间不同元素个数\nstruct Query {\n    int l, r, id;\n};\n \nvector&lt;int&gt; solve_distinct_elements(vector&lt;int&gt;&amp; arr, vector&lt;Query&gt;&amp; queries) {\n    int n = arr.size();\n    int q = queries.size();\n \n    // 按右端点排序\n    sort(queries.begin(), queries.end(), [](const Query&amp; a, const Query&amp; b) {\n        return a.r &lt; b.r;\n    });\n \n    vector&lt;int&gt; ans(q);\n    ordered_set s;\n    unordered_map&lt;int, int&gt; last_pos;\n \n    int query_idx = 0;\n    for (int i = 0; i &lt; n; i++) {\n        // 如果当前元素之前出现过，先删除之前的位置\n        if (last_pos.count(arr[i])) {\n            s.erase(last_pos[arr[i]]);\n        }\n \n        // 插入当前位置\n        s.insert(i);\n        last_pos[arr[i]] = i;\n \n        // 处理右端点为 i 的查询\n        while (query_idx &lt; q &amp;&amp; queries[query_idx].r == i) {\n            int l = queries[query_idx].l;\n            // 统计 &gt;= l 的位置个数\n            ans[queries[query_idx].id] = s.size() - s.order_of_key(l);\n            query_idx++;\n        }\n    }\n \n    return ans;\n}\n4. 可持久化数组\n// 使用 PBDS 的 tree 模拟可持久化数组\nclass PersistentArray {\nprivate:\n    typedef tree&lt;int, int, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; version_tree;\n    vector&lt;version_tree&gt; versions;\n \npublic:\n    PersistentArray(vector&lt;int&gt;&amp; initial) {\n        version_tree v0;\n        for (int i = 0; i &lt; initial.size(); i++) {\n            v0.insert({i, initial[i]});\n        }\n        versions.push_back(v0);\n    }\n \n    // 基于版本 ver 修改位置 pos 的值为 val，返回新版本号\n    int update(int ver, int pos, int val) {\n        version_tree new_version = versions[ver];  // 复制\n        new_version.erase(new_version.find_by_order(new_version.order_of_key(pos)));\n        new_version.insert({pos, val});\n        versions.push_back(new_version);\n        return versions.size() - 1;\n    }\n \n    // 查询版本 ver 中位置 pos 的值\n    int query(int ver, int pos) {\n        auto it = versions[ver].find_by_order(versions[ver].order_of_key(pos));\n        return it-&gt;second;\n    }\n};\n性能比较\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作std::setordered_setstd::priority_queuepbds::priority_queue插入O(log n)O(log n)O(log n)O(log n)删除O(log n)O(log n)O(log n)O(log n)查找第 k 小O(n)O(log n)不支持不直接支持查找排名O(n)O(log n)不支持不支持修改元素删除+插入删除+插入不支持O(log n)合并O(n log n)O(n log n)不支持O(log n)\n注意事项\n\n编译器支持：PBDS 只在 GCC 编译器中可用，其他编译器不支持\n头文件：需要包含特定的头文件，不是标准 C++ 库\n命名空间：使用 __gnu_pbds 命名空间\n重复元素：默认的 ordered_set 不支持重复元素，需要特殊处理\n调试：某些在线判题系统可能不支持 PBDS\n\n常用模板\n// 万能头文件中的 PBDS 设置\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n \n// 常用类型定义\ntypedef tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set;\ntypedef tree&lt;pair&lt;int, int&gt;, null_type, less&lt;pair&lt;int, int&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set_pair;\n \n// 可修改优先队列\ntypedef __gnu_pbds::priority_queue&lt;int&gt;::point_iterator pq_iterator;\n \n// 哈希表\ntypedef __gnu_pbds::gp_hash_table&lt;int, int&gt; fast_map;\nPBDS 是算法竞赛中的强力工具，特别是 ordered_set 在处理排序、排名相关问题时非常有用！"},"ACM-research/数据结构与算法/数据结构/并查集":{"slug":"ACM-research/数据结构与算法/数据结构/并查集","filePath":"ACM research/数据结构与算法/数据结构/并查集.md","title":"并查集","links":[],"tags":[],"content":"并查集 顾名思义 就是对集合的合并和查询 可以在均摊 o1 的复杂度下解决此类问题\n初始化\n我们需要一个 father 数组 来记录各个元素所在集合 的 代表元素\n假设我们有 n 个元素 从 1 开始 那么不妨如下初始化：\nDSU(int n): father(n + 1)\n{\n\tiota(all(father), 0ll);\n}\nint find(int x)\n这个函数可以查询 x 所在的集合 其实就是查出 x 的代表元素\n因此 有如下递归代码：\nint find(int x)\n{\n\tif (father[x] == x) return x;\n\telse\n\t{\n\t\t// 继续往上查找\n\t\treturn find(father[x]);\n\t}\n}\n但是我们可以在这个步骤中增加一个记忆化的操作 也就是让 father[x]  直接等于 find(father[x])\n就得到了如下代码：\n{\n\treturn father[x] == x ? x : father[x] = find(father[x]);\n}\nbool issame(int i, int j)\n这个函数可以查询 i， j 是否处于同一个集合\n代码见下：\nbool issame(int i, int j)\n{\n\treturn find(i) == find(j);\n}\nvoid merge(int i, int j)\n这个函数可以合并 i 元素所在集合 和 j 元素所在集合\n其实就是让 father[find(i)] = father[find(j)]\n不妨用 rooti 表示 find(i) rootj 表示 find(j)\n有如下代码：\nvoid merge(int i, int j)\n{\n\tauto ri = find(i), rj = find(j);\n\tif (ri == rj) return;\n \n\tparent[ri] = rj;\n}\n至此 最基本的合并查询功能我们就写完了。\n\n拓展\n在实际使用上 我们可能还想查询当前的集合数量 cnt 各个集合的大小 size[find(i)] 以及为了 find 递归时候降低复杂度 我们会选择 按秩合并\n通俗来讲，就是比较两个集合哪个集合大 把小集合塞到大集合里 在实际实现上，会发现 father 的结构类似一棵树 我们通过把小树合并到大树上的做法 可以有效防止树退化成一条长链\n因此 我们需要在初始化和 merge 函数中补充更多细节\n代码见下：\n初始化（完整版）\nDSU(int n): parent(n + 1), size(n + 1, 1), count(n), rank(n + 1, 0)\n{\n\tiota(all(parent), 0ll);\n}\n\nparent[i] 记录元素 i 的父节点\nsize[i] 记录以 i 为根的集合大小，初始化为 1\ncount 记录当前集合的数量，初始为 n\nrank[i] 记录以 i 为根的树的高度（秩），初始化为 0\n\n合并函数（完整版）\nvoid merge(int i, int j)\n{\n\tint ri = find(i), rj = find(j);\n\tif (ri == rj) return; // 已经在同一集合，无需合并\n \n\t// 按秩合并：让秩大的作为新的根\n\tif (rank[ri] &lt; rank[rj]) swap(ri, rj);\n \n\tparent[rj] = ri; // 将 rj 的根指向 ri\n\tsize[ri] += size[rj]; // 更新集合大小\n \n\t// 只有当两个秩相等时，新树的高度才会增加\n\tif (rank[ri] == rank[rj]) rank[ri]++;\n \n\tcount--; // 集合数量减一\n}\n额外功能函数\n// 获取元素 x 所在集合的大小\nint getsize(int x)\n{\n\treturn size[find(x)];\n}\n \n// 获取当前集合的总数量\nint getgroups()\n{\n\treturn count;\n}\n为什么只有秩相等时才 rank++？\n\n当 rank[ri] &gt; rank[rj] 时，将较矮的树合并到较高的树下，新树高度不变\n当 rank[ri] == rank[rj] 时，两个等高的树合并，新树高度必然增加 1\n这种策略保证了树的高度增长最慢，从而保持 find 操作的高效性\n"},"ACM-research/数据结构与算法/数据结构/树状数组":{"slug":"ACM-research/数据结构与算法/数据结构/树状数组","filePath":"ACM research/数据结构与算法/数据结构/树状数组.md","title":"树状数组","links":[],"tags":[],"content":"树状数组 (Binary Indexed Tree / Fenwick Tree)\n树状数组是一种用于高效处理前缀和查询和单点修改的数据结构，时间复杂度为 O(log n)。\n核心思想\n树状数组利用二进制的性质，通过 lowbit 函数来管理区间。每个位置 i 管理的区间长度为 lowbit(i)。\nlowbit 函数\nint lowbit(int x) {\n    return x &amp; (-x);  // 获取 x 的二进制表示中最低位的 1\n}\n基本操作\n初始化\nclass BIT {\nprivate:\n    vector&lt;int&gt; tree;\n    int n;\n \npublic:\n    BIT(int size) : n(size), tree(size + 1, 0) {}\n \n    // 从数组构造树状数组\n    BIT(vector&lt;int&gt;&amp; arr) : n(arr.size()), tree(arr.size() + 1, 0) {\n        for (int i = 0; i &lt; arr.size(); i++) {\n            update(i + 1, arr[i]);\n        }\n    }\n};\n单点修改 (update)\n将位置 i 的值增加 delta\nvoid update(int i, int delta) {\n    for (; i &lt;= n; i += lowbit(i)) {\n        tree[i] += delta;\n    }\n}\n前缀和查询 (query)\n查询 [1, i] 的前缀和\nint query(int i) {\n    int sum = 0;\n    for (; i &gt; 0; i -= lowbit(i)) {\n        sum += tree[i];\n    }\n    return sum;\n}\n区间查询\n查询 [l, r] 的区间和\nint rangeQuery(int l, int r) {\n    return query(r) - query(l - 1);\n}\n完整代码模板\nclass BIT {\nprivate:\n    vector&lt;int&gt; tree;\n    int n;\n \n    int lowbit(int x) {\n        return x &amp; (-x);\n    }\n \npublic:\n    BIT(int size) : n(size), tree(size + 1, 0) {}\n \n    // 单点修改：将位置 i 的值增加 delta\n    void update(int i, int delta) {\n        for (; i &lt;= n; i += lowbit(i)) {\n            tree[i] += delta;\n        }\n    }\n \n    // 前缀和查询：查询 [1, i] 的和\n    int query(int i) {\n        int sum = 0;\n        for (; i &gt; 0; i -= lowbit(i)) {\n            sum += tree[i];\n        }\n        return sum;\n    }\n \n    // 区间查询：查询 [l, r] 的和\n    int rangeQuery(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n \n    // 单点查询：查询位置 i 的值\n    int pointQuery(int i) {\n        return rangeQuery(i, i);\n    }\n};\n高级应用\n差分数组 + 树状数组（区间修改，单点查询）\nclass RangeUpdateBIT {\nprivate:\n    BIT diff;  // 差分数组的树状数组\n \npublic:\n    RangeUpdateBIT(int n) : diff(n) {}\n \n    // 区间修改：将 [l, r] 的值都增加 delta\n    void rangeUpdate(int l, int r, int delta) {\n        diff.update(l, delta);\n        diff.update(r + 1, -delta);\n    }\n \n    // 单点查询：查询位置 i 的值\n    int pointQuery(int i) {\n        return diff.query(i);\n    }\n};\n二维树状数组\nclass BIT2D {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; tree;\n    int n, m;\n \n    int lowbit(int x) { return x &amp; (-x); }\n \npublic:\n    BIT2D(int rows, int cols) : n(rows), m(cols), tree(rows + 1, vector&lt;int&gt;(cols + 1, 0)) {}\n \n    void update(int x, int y, int delta) {\n        for (int i = x; i &lt;= n; i += lowbit(i)) {\n            for (int j = y; j &lt;= m; j += lowbit(j)) {\n                tree[i][j] += delta;\n            }\n        }\n    }\n \n    int query(int x, int y) {\n        int sum = 0;\n        for (int i = x; i &gt; 0; i -= lowbit(i)) {\n            for (int j = y; j &gt; 0; j -= lowbit(j)) {\n                sum += tree[i][j];\n            }\n        }\n        return sum;\n    }\n \n    int rangeQuery(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);\n    }\n};\n使用场景\n\n动态前缀和：频繁的单点修改和前缀和查询\n逆序对统计：利用树状数组统计逆序对个数\n离散化 + 树状数组：处理大范围但稀疏的数据\n差分数组优化：区间修改转化为单点修改\n\n时间复杂度\n\n单点修改：O(log n)\n前缀和查询：O(log n)\n区间查询：O(log n)\n空间复杂度：O(n)\n\n注意事项\n\n树状数组的下标从 1 开始，不是从 0 开始\nlowbit(x) 的原理：x &amp; (-x) 可以提取 x 的最低位 1\n树状数组只能处理可逆的操作（如加法、异或），不能处理最值操作\n"},"ACM-research/数据结构与算法/数据结构/线段树":{"slug":"ACM-research/数据结构与算法/数据结构/线段树","filePath":"ACM research/数据结构与算法/数据结构/线段树.md","title":"线段树","links":[],"tags":[],"content":"线段树 (Segment Tree)\n线段树是一种用于处理区间查询和区间修改的高效数据结构，支持在 O(log n) 时间内完成各种区间操作。\n核心思想\n线段树是一棵完全二叉树，每个节点代表一个区间，叶子节点代表单个元素，内部节点代表子区间的合并结果。\n基本性质\n\n父节点区间 = 左子树区间 ∪ 右子树区间\n对于节点 i：左儿子为 2*i，右儿子为 2*i+1\n树的高度为 O(log n)，节点总数约为 4n\n\n基础线段树（区间查询，单点修改）\nclass SegmentTree {\nprivate:\n    vector&lt;int&gt; tree;\n    int n;\n \n    void build(vector&lt;int&gt;&amp; arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2*node, start, mid);\n            build(arr, 2*node+1, mid+1, end);\n            tree[node] = tree[2*node] + tree[2*node+1];  // 区间和\n        }\n    }\n \n    void updateHelper(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx &lt;= mid) {\n                updateHelper(2*node, start, mid, idx, val);\n            } else {\n                updateHelper(2*node+1, mid+1, end, idx, val);\n            }\n            tree[node] = tree[2*node] + tree[2*node+1];\n        }\n    }\n \n    int queryHelper(int node, int start, int end, int l, int r) {\n        if (r &lt; start || end &lt; l) {\n            return 0;  // 区间不相交\n        }\n        if (l &lt;= start &amp;&amp; end &lt;= r) {\n            return tree[node];  // 区间完全包含\n        }\n        int mid = (start + end) / 2;\n        int p1 = queryHelper(2*node, start, mid, l, r);\n        int p2 = queryHelper(2*node+1, mid+1, end, l, r);\n        return p1 + p2;\n    }\n \npublic:\n    SegmentTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        build(arr, 1, 0, n-1);\n    }\n \n    void update(int idx, int val) {\n        updateHelper(1, 0, n-1, idx, val);\n    }\n \n    int query(int l, int r) {\n        return queryHelper(1, 0, n-1, l, r);\n    }\n};\n懒惰传播（Lazy Propagation）\n对于区间修改操作，使用懒惰传播避免不必要的递归：\nclass LazySegmentTree {\nprivate:\n    vector&lt;long long&gt; tree, lazy;\n    int n;\n \n    void push(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            tree[node] += lazy[node] * (end - start + 1);\n            if (start != end) {  // 不是叶子节点\n                lazy[2*node] += lazy[node];\n                lazy[2*node+1] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n \n    void build(vector&lt;int&gt;&amp; arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(arr, 2*node, start, mid);\n            build(arr, 2*node+1, mid+1, end);\n            tree[node] = tree[2*node] + tree[2*node+1];\n        }\n    }\n \n    void updateRange(int node, int start, int end, int l, int r, int val) {\n        push(node, start, end);\n        if (start &gt; r || end &lt; l) return;\n \n        if (start &gt;= l &amp;&amp; end &lt;= r) {\n            lazy[node] += val;\n            push(node, start, end);\n            return;\n        }\n \n        int mid = (start + end) / 2;\n        updateRange(2*node, start, mid, l, r, val);\n        updateRange(2*node+1, mid+1, end, l, r, val);\n \n        push(2*node, start, mid);\n        push(2*node+1, mid+1, end);\n        tree[node] = tree[2*node] + tree[2*node+1];\n    }\n \n    long long queryRange(int node, int start, int end, int l, int r) {\n        if (start &gt; r || end &lt; l) return 0;\n \n        push(node, start, end);\n        if (start &gt;= l &amp;&amp; end &lt;= r) {\n            return tree[node];\n        }\n \n        int mid = (start + end) / 2;\n        long long p1 = queryRange(2*node, start, mid, l, r);\n        long long p2 = queryRange(2*node+1, mid+1, end, l, r);\n        return p1 + p2;\n    }\n \npublic:\n    LazySegmentTree(vector&lt;int&gt;&amp; arr) {\n        n = arr.size();\n        tree.resize(4 * n);\n        lazy.resize(4 * n, 0);\n        build(arr, 1, 0, n-1);\n    }\n \n    void updateRange(int l, int r, int val) {\n        updateRange(1, 0, n-1, l, r, val);\n    }\n \n    long long query(int l, int r) {\n        return queryRange(1, 0, n-1, l, r);\n    }\n \n    void updatePoint(int idx, int val) {\n        updateRange(idx, idx, val);\n    }\n};\n不同类型的线段树\n1. 最值线段树（RMQ）\n// 将 tree[node] = tree[2*node] + tree[2*node+1] 改为：\ntree[node] = max(tree[2*node], tree[2*node+1]);  // 最大值\ntree[node] = min(tree[2*node], tree[2*node+1]);  // 最小值\n2. 乘法懒惰传播\nstruct LazyNode {\n    long long add, mul;\n    LazyNode() : add(0), mul(1) {}\n};\n \nvoid push(int node, int start, int end) {\n    if (lazy[node].mul != 1 || lazy[node].add != 0) {\n        tree[node] = tree[node] * lazy[node].mul + lazy[node].add * (end - start + 1);\n        if (start != end) {\n            // 传播到子节点\n            lazy[2*node].mul *= lazy[node].mul;\n            lazy[2*node].add = lazy[2*node].add * lazy[node].mul + lazy[node].add;\n            lazy[2*node+1].mul *= lazy[node].mul;\n            lazy[2*node+1].add = lazy[2*node+1].add * lazy[node].mul + lazy[node].add;\n        }\n        lazy[node] = LazyNode();  // 重置\n    }\n}\n3. 动态开点线段树\nstruct Node {\n    int left, right;\n    long long val, lazy;\n    Node() : left(-1), right(-1), val(0), lazy(0) {}\n};\n \nclass DynamicSegmentTree {\nprivate:\n    vector&lt;Node&gt; nodes;\n    int nodeCount;\n    int L, R;  // 值域范围\n \n    int newNode() {\n        nodes.emplace_back();\n        return nodeCount++;\n    }\n \npublic:\n    DynamicSegmentTree(int l, int r) : L(l), R(r), nodeCount(0) {\n        nodes.reserve(4000000);  // 预分配空间\n        newNode();  // 创建根节点\n    }\n \n    void update(int l, int r, int val) { updateRange(0, L, R, l, r, val); }\n    long long query(int l, int r) { return queryRange(0, L, R, l, r); }\n \n    // ... 其他函数实现类似，但需要动态创建节点\n};\n线段树应用场景\n1. 区间最值查询（RMQ）\n// ST表 vs 线段树\n// ST表：O(n log n) 预处理，O(1) 查询，但不支持修改\n// 线段树：O(n) 预处理，O(log n) 查询和修改\n2. 历史最值问题\n// 维护区间加法 + 历史最大值\nstruct HistoryMaxNode {\n    long long maxVal, historyMax;\n    long long addTag, historyAddTag;\n};\n3. 区间染色问题\n// 使用懒惰传播 + 特殊标记\n// lazy[node] = -1 表示无标记\n// lazy[node] = color 表示整个区间都是 color 颜色\n时间复杂度\n\n建树：O(n)\n单点修改：O(log n)\n区间修改：O(log n)（带懒惰传播）\n区间查询：O(log n)\n空间复杂度：O(n)\n\n线段树 vs 其他数据结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据结构区间查询区间修改单点修改适用场景树状数组O(log n)不直接支持O(log n)前缀和，逆序对线段树O(log n)O(log n)O(log n)通用区间操作ST 表O(1)不支持不支持静态 RMQ分块O(√n)O(√n)O(1)平衡查询修改\n常见优化技巧\n\nzkw 线段树：非递归实现，常数更小\n标记永久化：某些情况下可以不下推标记\n动态开点：节省空间，处理大值域\n可持久化线段树：支持历史版本查询\n线段树合并/分裂：处理复杂的数据结构题\n"},"ACM-research/数据结构与算法/算法/BFS--and--DFS":{"slug":"ACM-research/数据结构与算法/算法/BFS--and--DFS","filePath":"ACM research/数据结构与算法/算法/BFS & DFS.md","title":"BFS & DFS","links":[],"tags":[],"content":"\n仅用于帮自己在脑残忘记的时候补习，不是教程，特此说明。\n\nDFS vs BFS 核心差异\nDFS（深度优先）\nvoid dfs(当前状态) {\n    if (达到目标) return;\n    \n    for (每个选择) {\n        if (选择有效) {\n            做选择;\n            dfs(新状态);  // 递归深入\n            撤销选择;     // 回溯\n        }\n    }\n}\nBFS（广度优先）- 用队列模拟DFS\nvoid bfs() {\n    queue&lt;状态&gt; q;\n    q.push(初始状态);\n    \n    while (!q.empty()) {\n        当前状态 = q.front(); q.pop();\n        \n        if (达到目标) return;\n        \n        for (每个选择) {\n            if (选择有效) {\n                q.push(新状态);  // 不是递归，而是加入队列\n            }\n        }\n    }\n}\n用DFS思路理解你的代码\n你的BFS实际上就是把DFS的递归调用栈换成了队列：\nDFS版本（你熟悉的）\nbool found = false;\n \nvoid dfs(int cur, vector&lt;bool&gt;&amp; used) {\n    if (found) return;\n    if (cur == (1 &lt;&lt; n) - 1) {\n        found = true;\n        return;\n    }\n    \n    for (int i = 0; i &lt; n; i++) {\n        if (used[i]) continue;  // 已经用过这个试剂\n        \n        int next = cur | (1 &lt;&lt; i);\n        if (!danger[next]) {    // 状态安全\n            used[i] = true;\n            dfs(next, used);    // 递归调用\n            used[i] = false;    // 回溯\n        }\n    }\n}\nBFS版本（你的代码）\nvoid bfs() {\n    queue&lt;int&gt; q;\n    vector&lt;bool&gt; visited(1 &lt;&lt; n, false);\n    \n    q.push(0);\n    visited[0] = true;\n    \n    while (!q.empty()) {\n        int cur = q.front(); q.pop();\n        \n        if (cur == (1 &lt;&lt; n) - 1) {\n            cout &lt;&lt; &quot;Yes&quot;; return;\n        }\n        \n        for (int i = 0; i &lt; n; i++) {\n            if (cur &amp; (1 &lt;&lt; i)) continue;  // 相当于used[i]\n            \n            int next = cur | (1 &lt;&lt; i);\n            if (!visited[next] &amp;&amp; !danger[next]) {\n                visited[next] = true;\n                q.push(next);              // 相当于递归调用\n            }\n        }\n    }\n    cout &lt;&lt; &quot;No&quot;;\n}\n关键对应关系\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS概念BFS等价递归调用q.push(新状态)递归返回q.pop()used[]数组visited[]数组回溯撤销不需要（因为每个状态独立处理）\n为什么BFS不需要回溯？\n\nDFS：同一个路径上的状态会相互影响，需要回溯\nBFS：每个状态都是独立的快照，包含了完整的信息\n\n比如状态3（试剂1+2），在BFS中直接包含了”试剂1和2都已使用”的信息，不需要额外的used数组来记录。\n你的代码思路总结\n\n状态表示：用位掩码cur表示当前使用了哪些试剂\n状态转移：cur | (1 &lt;&lt; i) 表示在当前基础上添加试剂i\n避免重复：visited[]防止重复访问同一状态\n安全检查：!danger[next]确保新状态安全\n"},"ACM-research/数论/EXGCD":{"slug":"ACM-research/数论/EXGCD","filePath":"ACM research/数论/EXGCD.md","title":"EXGCD","links":[],"tags":[],"content":"扩展欧几里得算法（ExGCD）\n常见考查场景：\n\n求解线性不定方程（Diophantine Equation）。\n解决线性同余方程。\n在中国剩余定理（CRT）中合并方程时计算逆元。\n需要找出贝祖系数来表示 gcd 的线性组合。\n\n典型题目与分析\n\n\n线性不定方程求解\n\n题目描述：给定 a、b 和 c，判断方程ax + by = c是否有整数解，并输出其中一组解。\n考查点：先用 exgcd 求 \\gcd(a,b) ，再判断 c 是否为其倍数。\n分析：如果 ccc 能被 \\gcd(a,b) 整除，则将 exgcd 得到的基本解乘以c/\\gcd(a,b) 即为解。重点在于参数的调整。\n\n\n\n求解模线性方程\n\n题目描述：求解同余方程ax \\equiv c \\ (\\bmod\\ m) 的所有解。\n考查点：判断 \\gcd(a,m) 是否整除 c ；若可解，利用 exgcd 求出基本解，再写出通解形式。\n分析：考查对同余方程解的参数描述和解集刻画。\n\n\n\n求最小非负解\n\n题目描述：在方程 x + by = c 或同余 ax \\equiv b \\ (\\bmod\\ m) 中，要求输出满足某个变量最小非负的解。\n考查点：得到基本解后，通过加减模的周期（或平移参数）调整到非负区域。\n分析：需要灵活应用 exgcd 得到的通解形式，并利用模运算找到最优解。\n\n\n\n鸡兔同笼（或硬币问题）\n\n题目描述：经典问题：鸡和兔子总数和总脚数已知，求鸡和兔子的数量。\n考查点：将问题转化为 2x + 4y = n 的线性方程，并用 exgcd 求解。\n分析：先判断方程可解性，然后找到基本解，再根据问题约束（非负整数）筛选合适的解。\n\n\n\n中国剩余定理（CRT）的实现\n\n题目描述：给定一组同余方程，求一个最小正整数满足所有方程。\n考查点：在每一步合并两个同余方程时，用 exgcd 计算模逆元来构造合并公式。\n分析：考查对 exgcd 在 CRT 算法中作用的理解，重点在于正确处理模数不互质情况（通常题目保证互质）。\n\n\n"},"ACM-research/数论/GCD":{"slug":"ACM-research/数论/GCD","filePath":"ACM research/数论/GCD.md","title":"GCD","links":[],"tags":[],"content":"int gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n典型题目与分析\n\n\n基础 GCD 题目\n\n题目描述：给定两个整数 a 和 b，求它们的最大公约数。\n考查点：直接使用欧几里得算法。\n分析：这是最简单的数论题，考查递归或迭代实现欧几里得算法，时间复杂度 O(\\log \\min(a,b))。\n\n\n\nGCD 与 LCM 的关系\n\n题目描述：给定两个数，要求同时输出它们的最大公约数和最小公倍数。\n考查点：利用公式  \\text{lcm}(a,b) = \\frac{a \\times b}{\\gcd(a,b)}；同时检验对大数运算和溢出问题的处理。\n分析：先求 gcd，再计算 lcm。注意要用长整型防止乘法溢出。\n\n\n\n数组全局 GCD\n\n题目描述：给定一个数组，求数组中所有元素的 gcd。\n考查点：迭代计算多个数的 gcd。\n分析：从数组左边第一个元素开始，依次计算 \\text{gcd}(res, a[i])，时间复杂度  O(n \\log M)（M 为元素上界）。\n\n\n\n区间 GCD 查询\n\n题目描述：给定一个数组和多个区间查询，每个查询询问区间内所有数的 gcd。\n考查点：数据结构与数论结合，如用线段树或稀疏表实现区间 gcd 查询。\n分析：预处理时间 O(n\\log n)，每个查询O(\\log n)（或 O(1) 的稀疏表版本），适合在线查询问题。\n\n\n\nGCD 累加问题（GCD Sum）\n\n题目描述：求数组中所有满足 i &lt; j 的数对(a_i, a_j) 的 gcd 之和。\n考查点：数论求和技巧和分解思路，有时需要反过来统计每个数作为 gcd 的贡献。\n分析：直接枚举会超时，通常需要利用筛法或反向思考“对每个可能的公因子统计贡献”，考查对数论性质的深入理解。\n\n\n\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\t// 统计每个因子的频率\n\tmap&lt;int, int&gt; mp;\n\tvector&lt;int&gt; v(n);\n\tfor (int i = 0; i &lt; n; i++) \n\t{\n\t\tcin &gt;&gt; v[i];\n\t\tmp[v[i]]++;\t\n\t}\n \n\t// 对每个d 查看数组中有多少个数字 使得d是其因数\n\tmap&lt;int, int&gt; d;\n\tfor (int i = 1; i &lt;= ranges::max(v); i++)\n\t{\n\t\tfor (int j = i; j &lt;= ranges::max(v); j += i)\n\t\t{\n\t\t\td[i] += mp[j];\n\t\t}\n\t}\n\tint ans = 0;\n\t// 从大到小计算答案 用容斥原理扣除更大因子的贡献\n\tmap&lt;int, int&gt; f;\n\tfor (int i = ranges::max(v); i &gt;= 1; i--)\n\t{\n\t\tauto pr = d[i] * (d[i] - 1) / 2;\n\t\tfor (int k = 2; k * i &lt;= ranges::max(v); k++)\n\t\t{\n\t\t\tpr -= f[k * i];\n\t\t}\n\t\tans += i * pr;\n\t\tf[i] = pr;\n\t}\n\tcout &lt;&lt; ans;\n}"},"ACM-research/组合数板子":{"slug":"ACM-research/组合数板子","filePath":"ACM research/组合数板子.md","title":"组合数板子","links":[],"tags":[],"content":"const int MAXN = 1e7;\nconst int MOD = 1e9 + 7;\n \nvector&lt;int&gt; fact(MAXN), invfact(MAXN);\nbool inited = 0;\nint ksm(int base, int exp)\n{\n\tint ans = 1;\n\twhile (exp)\n\t{\n\t\tif (exp &amp; 1)\n\t\t{\n\t\t\tans = ans * base % MOD;\n\t\t}\n\t\tbase = base * base % MOD;\n\t\texp &gt;&gt;= 1;\n\t}\n\treturn ans;\n}\n \nint inv(int x)\n{\n\treturn ksm(x, MOD - 2);\n}\n \nvoid pre()\n{\n\tif (inited) return;\n\tinited = 1;\n\tfact[0] = 1;\n\tfor (int i = 1; i &lt; MAXN; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t}\n \n\tinvfact[MAXN - 1] = inv(fact[MAXN - 1]);\n\tfor (int i = MAXN - 2; i &gt;= 0; i--)\n\t{\n\t\tinvfact[i] = invfact[i + 1] * (i + 1) % MOD;\n\t}\n}\n \nint comb(int n, int k)\n{\n\tif (!inited) pre();\n\tif (k &lt; 0 or k &gt; n) return 0;\n\treturn fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}"},"ACM-research/补题-补题-补题！/ABC/415":{"slug":"ACM-research/补题-补题-补题！/ABC/415","filePath":"ACM research/补题 补题 补题！/ABC/415.md","title":"415","links":["/"],"tags":[],"content":"A\n签到。\nB\n签到。\nC\n一开始没有看懂题捏。\n混合其实是或运算，给的 binary string 其实是第i种是危险的，由于n不大 所以其实暴力搜索即可。\nbfs code\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    string s;\n    cin &gt;&gt; s;\n \n    // danger[i] 表示状态i是否危险\n    vector&lt;int&gt; danger(1 &lt;&lt; n, 0);\n    for (int i = 1; i &lt; (1 &lt;&lt; n); i++)\n    {\n        danger[i] = (s[i - 1] - &#039;0&#039;);\n    }\n \n    // BFS\n    queue&lt;int&gt; q;\n    vector&lt;bool&gt; visited(1 &lt;&lt; n, false);\n \n    q.push(0); // 从空状态开始\n    visited[0] = true;\n \n    while (!q.empty())\n    {\n        int cur = q.front();\n        q.pop();\n \n        // 检查是否到达目标状态\n        if (cur == (1 &lt;&lt; n) - 1)\n        {\n            cout &lt;&lt; &quot;Yes&quot;;\n            return;\n        }\n \n        // 尝试添加每种化学试剂\n        for (int i = 0; i &lt; n; i++)\n        {\n            if (cur &amp; (1 &lt;&lt; i))\n            {\n                continue;\n            } // 已经包含这种试剂\n \n            int next = cur | (1 &lt;&lt; i); // 添加第i种试剂\n \n            if (!visited[next] &amp;&amp; !danger[next]) // 状态安全且未访问过\n            {\n                visited[next] = true;\n                q.push(next);\n            }\n        }\n    }\n \n    cout &lt;&lt; &quot;No&quot;;\n}\n笔者写到这里，发现自己已经忘记bfs怎么写了…\n于是紧急恶补了一下 现在大概搞懂了 原来细节这么多。\n但是这样一来 就有优美的位运算版本了\nvoid solve()\n{\n    int n;\n    string s;\n    cin &gt;&gt; n &gt;&gt; s;\n \n    // dp[mask] 表示状态 mask 是否可达\n    vector&lt;int&gt; dp(1 &lt;&lt; n, 0);\n    dp[0] = 1; // 空状态可达\n \n    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++)\n    {\n        if (!dp[mask])\n        {\n            continue;\n        }\n \n        // 尝试添加每种化学试剂\n        for (int i = 0; i &lt; n; i++)\n        {\n            if (mask &amp; (1 &lt;&lt; i))\n            {\n                // 已经包含这种试剂\n                continue;\n            }\n \n            int next = mask | (1 &lt;&lt; i);\n            if (s[next - 1] == &#039;0&#039;)\n            {\n                // 新状态安全\n                dp[next] = 1;\n            }\n        }\n    }\n \n    cout &lt;&lt; (dp[(1 &lt;&lt; n) - 1] ? &quot;Yes&quot; : &quot;No&quot;);\n}\nD\n原问题等价于我们初始拥有 n 个空瓶，现在要最大化答案，而贡献答案的方式就是用多的空瓶 a 去交换比较少的空瓶 b。\n也就等价于 我们每次花费 a - b 去贡献答案。\n因此 自然可以想到关于 a - b 排序，这样一来我们只需在一次遍历中重复 贡献答案 的 操作 即可\n代码如下：\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    vector&lt;pair&lt;int, int&gt;&gt; v(m);\n    for (int i = 0; i &lt; m; i++)\n    {\n        cin &gt;&gt; v[i].first &gt;&gt; v[i].second; // a, b\n    }\n \n    // 按 a - b 排序（损失从小到大）\n    sort(all(v), [](auto x, auto y)\n         { return x.first - x.second &lt; y.first - y.second; });\n \n    int ans = 0;\n \n    for (auto [a, b] : v)\n    {\n \n        int loss = a - b; // 每一次贡献答案的代价\n\t\twhile (n &gt;= a)\n\t\t{\n\t\t\tans++;\n\t\t\tn -= (a - b);\n\t\t}\n    }\n \n    cout &lt;&lt; ans;\n}\n但是这样做存在超时风险 进而想到 其实可以通过除法优化\n假设我们现在有 n 个空瓶 最多可以贡献 k 次答案( k 待求) 那么显然有：\nn - loss * k \\,\\ge \\, a\n那么 k 就满足：\nk \\, \\le \\, \\frac{n-a}{loss}\n上面这个式子真的对吗？\n我们计算的这个 k 是满足 n &gt;= a 的最优结果，但是其实 n &gt;= a 时，我们仍然可以通过更多的一次操作 使 n &lt; a 的同时贡献答案，所以最后要多加一次贡献。\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    vector&lt;pair&lt;int, int&gt;&gt; v(m);\n    for (int i = 0; i &lt; m; i++)\n    {\n        cin &gt;&gt; v[i].first &gt;&gt; v[i].second; // a, b\n    }\n \n    // 按 a-b 排序（损失从小到大）\n    sort(all(v), [](auto x, auto y)\n         { return x.first - x.second &lt; y.first - y.second; });\n \n    int ans = 0;\n \n    for (auto [a, b] : v)\n    {\n \n        int loss = a - b;\n \n        // 直接计算最多能交换多少次\n        // 需要满足：n - k * loss &gt;= a\n        // 即：k &lt;= (n - a) / loss\n        if (n &gt;= a)\n        {\n            int k = (n - a) / loss;\n \n            if (k &gt; 0)\n            {\n                ans += k;\n                n -= k * loss;\n            }\n            if (n &gt;= a)\n            {\n                ans++;\n                n -= loss;\n            }\n        }\n    }\n \n    cout &lt;&lt; ans;\n}\nE\n到达 [i, j] 的时候应该是 第 i + j - 1 天，不妨记天数为 day ，最后拥有的费用是 dp[i][j] 这一天产生的开销是 v[day] 这个格子上获得的硬币是 a[i][j]  那么我们有：\ndp[i][j] + a[i][j] - v[i + j - 1] = dp[i + 1][j] \\ \\ 向右走 \ndp[i][j] + a[i][j] - v[i + j - 1] = dp[i][j + 1] \\ \\ 向下走 \n而每一天的钱数都要大于0 这是一个从后往前推的过程：\n比方说我今天有 x 元 一番操作之后明天变成了 -1 元 是不是说明我今天起码得有 x+1 元才能够得上这次消费？\n所以变成了一次从终点往起点的dp\nvoid solve()\n{\n    int h, w;\n    cin &gt;&gt; h &gt;&gt; w;\n \n    vector v(h, vector&lt;int&gt;(w));\n    for (int i = 0; i &lt; h; i++)\n    {\n        for (int j = 0; j &lt; w; j++)\n        {\n            cin &gt;&gt; v[i][j];\n        }\n    }\n \n    vector&lt;int&gt; p(h + w - 1);\n    for (int i = 0; i &lt; h + w - 1; i++)\n    {\n        cin &gt;&gt; p[i];\n    }\n \n    // dp[i][j] = 到达(i,j)时需要的最少硬币数\n    vector dp(h, vector&lt;int&gt;(w, LLONG_MAX));\n \n    // 从终点开始倒推\n    dp[h - 1][w - 1] = max(0ll, p[h + w - 2] - v[h - 1][w - 1]);\n \n    // 处理最后一行（只能从右边来）\n    for (int j = w - 2; j &gt;= 0; j--)\n    {\n        int day = (h - 1) + j;\n        dp[h - 1][j] = max(0ll, dp[h - 1][j + 1] + p[day] - v[h - 1][j]);\n    }\n \n    // 处理最后一列（只能从下面来）\n    for (int i = h - 2; i &gt;= 0; i--)\n    {\n        int day = i + (w - 1);\n        dp[i][w - 1] = max(0ll, dp[i + 1][w - 1] + p[day] - v[i][w - 1]);\n    }\n \n    // 处理其他位置\n    for (int i = h - 2; i &gt;= 0; i--)\n    {\n        for (int j = w - 2; j &gt;= 0; j--)\n        {\n            int day = i + j;\n            int need1 = max(0ll, dp[i + 1][j] + p[day] - v[i][j]); // 从下面来\n            int need2 = max(0ll, dp[i][j + 1] + p[day] - v[i][j]); // 从右边来\n            dp[i][j] = min(need1, need2);\n        }\n    }\n \n    cout &lt;&lt; dp[0][0];\n}\n写完后 笔者发现这道题其实完全可以二分猜一个起点 毕竟钱币是一直减少的 而我们dp的过程其实已经走完了全部可能。代码就不给了 总之就是把 dp 过程写进二分的check中 然后从开头往终点做dp 如果能到终点的话就可行\nF\n回到index"},"ACM-research/补题-补题-补题！/cf/2125-d2":{"slug":"ACM-research/补题-补题-补题！/cf/2125-d2","filePath":"ACM research/补题 补题 补题！/cf/2125 d2.md","title":"2125 d2","links":[],"tags":[],"content":"A\nB\nC\nD\n概率怎么算？\n比方说有n条线段 选择每一条线段的概率分别是 p[i]\n那么我们4条线段 选择2和4 的总概率就是 P = (1 - p[1]) * p[2] * (1 - p[3]) * p[4]\n我们钦定一个初始概率 P_{0} = \\prod (1-p[i]) 最后要求的概率是上面P 那么每一个概率就要乘上一个系数：\nP = P_{0} \\times (p[2]\\times\\frac{1}{1-p[2]}) \\times (p[4]\\times\\frac{1}{1-p[4]})\n又有 p[i] = \\frac{p_i}{q_{i}} 化简即可。\n总之 记 w_{i} = (p[i]\\times\\frac{1}{1-p[i]}) ，下一步就是如何表示从1到m的覆盖了。\n设 dp[i] 表示 在变换后的概率空间中，通过激活某些线段，使得位置1到i-1都被恰好覆盖，且在位置i”停下”的概率\n我们有 dp[0] = 1 作为初始化，接下来 对于每一段 [l, r, w] 组合，都应该有：\ndp[r] = (dp[r] + dp[l - 1] * w_{i}) % MOD\n其中 dp[l - 1] 表示 安稳到达 l - 1 的概率，w表示后面这一段存在的概率，二者相乘是因为遵循分步乘法计数原理； dp[r] 加上后面这一段 是因为遵循分类加法计数原理。\n最后我们就求得了 dp[m] 作为 从0开始 安稳到达 m 的概率 最后跟 P_{0} 相乘 取模 即可。\n// 快速幂\nint power(int base, int exp)\n{\n    int res = 1;\n    base %= MOD;\n    while (exp &gt; 0)\n    {\n        if (exp &amp; 1)\n            res = (res * base) % MOD;\n        base = (base * base) % MOD;\n        exp &gt;&gt;= 1;\n    }\n    return res;\n}\n \n// 模逆元\nint inv(int x)\n{\n    return power(x, MOD - 2);\n}\n \nstruct datas\n{\n    int l, r;\n    int w; // 存储权重\n};\n \nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    int p0 = 1;\n \n    vector&lt;datas&gt; v(n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        int l, r, p, q;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; p &gt;&gt; q;\n        auto curp = p * inv(q) % MOD;\n        // p0 *= (1 - curp); 是错的 要特别注意取模\n        p0 = (p0 % MOD * (1 + MOD - curp) % MOD) % MOD;\n        v[i] = {l, r, curp * inv((1 + MOD - curp) % MOD) % MOD};\n    }\n \n    map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; mp;\n \n    for (auto [l, r, w] : v)\n    {\n        mp[l].emplace_back(r, w);\n    }\n \n    vector&lt;int&gt; dp(m + 1, 0);\n    dp[0] = 1;\n \n    for (int l = 1; l &lt;= m; l++)\n    {\n        for (auto [r, w] : mp[l])\n        {\n            dp[r] = (dp[r] + dp[l - 1] * w) % MOD;\n        }\n    }\n \n    cout &lt;&lt; p0 * dp[m] % MOD;\n}\n上面出现了很多 %MOD 要是图省事可以找哥哥的[Z模板](jiangly算法模板收集 - hh2048 - 博客园) 那样会方便的多。"},"ACM-research/补题-补题-补题！/nowcoder/20250723-河南萌新2":{"slug":"ACM-research/补题-补题-补题！/nowcoder/20250723-河南萌新2","filePath":"ACM research/补题 补题 补题！/nowcoder/20250723 河南萌新2.md","title":"20250723 河南萌新2","links":[],"tags":[],"content":"M\n签到。\n勾股定理列出来然后观察即可，最后答案是 \\frac{\\pi x^{2}}{8}\nK\n签到，直接输出那个玩意就行。\nI\n题意等价于求二分答案的时间复杂度，如果n是2的次幂，答案就是__lg(n)；如果不是的话，就要多搜索一次。\n如何高效判断 n 是否是 2 的次幂？ 可以采用\nif ((n &amp; (n - 1)) != 0) ans++;\n由于 &amp; 的优先级较低，这里的括号应当是一个都不能少的，可以自行尝试。\nD\n建图之后dfs。\ndfs 的时候要注意如何高效识别 当前的节点 cur 是哪条路过来的，可以考虑建立一个前驱数组，也可以直接在 dfs 的参数上加上。\n最后查询二进制 1 的数量，可以用 __builtin_popcount 做到 o1 查询。\nvoid solve()\n{\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n \n    vector&lt;int&gt; a(n + 1);\n    vector&lt;vector&lt;int&gt;&gt; adj(n + 1, vector&lt;int&gt;());\n    vector&lt;int&gt; ans(n + 1);\n \n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; a[i];\n    }\n \n    for (int i = 1; i &lt; n; i++)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n \n    vector&lt;int&gt; pre(n + 1, 0); // 记录前驱节点\n \n    ans[1] = a[1];\n    function&lt;void(int)&gt; dfs = [&amp;](int cur)\n    {\n        for (auto nxt : adj[cur])\n        {\n            if (nxt == pre[cur]) \n            // 如果 nxt 是 cur 的前驱节点 说明绕回去了，不选\n            {\n                continue;\n            }\n \n            pre[nxt] = cur;\n            ans[nxt] = a[nxt] &amp; ans[cur];\n            dfs(nxt);\n        }\n    };\n    dfs(1);\n    map&lt;int, int&gt; anss;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        auto cur = __builtin_popcount(ans[i]);\n        anss[cur]++;\n    }\n \n    while (q--)\n    {\n        int op;\n        cin &gt;&gt; op;\n        cout &lt;&lt; anss[op] &lt;&lt; endl;\n    }\n}\nA\n我们要计算 1~n 的 所有 约数和。\n什么是约数呢，比方说 n = 6 那么它的约数就有 1, 2, 3, 6 。\n可以看出来，约数指的是能整除n的数字。\n那么 对于数字2，从1到6到底有多少数字能被2整除呢？\n能被2整除的数字 一定可以写成2k的形式，那也就是找1到6有多少个2k 问题转化为计算k的最大值 显然在这个例子里，k = \\frac{n}{2} = 3 。\n因此 我们得到一个小结论，计算 1 ~ n 有多少个数字整除 i 只需要计算 \\lfloor \\frac{n}{i} \\rfloor 即可。\n那么这道题我们就成功的转化为\nint ans = 0;\nfor (int i = 1; i &lt;= n; i++) ans += n / i;\n但是 n \\leq 2^{31}  这样做是很有可能超时的，因此我们有必要学习数论分块。\n\n数论分块，也称整除分块，是一种 用来解决形如 \\sum_{i=1}^{n} f(i) \\ \\lfloor \\frac{n}{i} \\rfloor  的问题 的优化技巧。\n观察一个重要性质：对于固定的 n , \\lfloor \\frac{n}{i} \\rfloor 的取值是有限的。\n关键定理 ：对于正整数 n ，\\lfloor \\frac{n}{i} \\rfloor 最多只有 2 \\sqrt{n}​ 种不同的取值。\n在一个 \\lfloor \\frac{n}{i} \\rfloor 相等 的区间R内，我们显然有 \\forall i, j \\in R, \\ \\ \\frac{n}{i} = \\frac{n}{j}\n那么我们如果已经知道一个区间的左端点是 l 也就可以通过这个式子 计算出 区间的右端点 r = \\frac{n}{\\frac{n}{l}}\n特别注意的是，这里的除法都是整除，不要觉得好看就轻易化简。\n在计算出区间左右端点之后，我们累计答案，然后更新左端点，再次计算即可。\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tint ans = 0;\n\tint l = 1, r;\n\twhile (l &lt;= n)\n\t{\n\t\tr = n / (n / l);\n\t\tauto tot = r - l + 1; // 有多少个数字 满足 n/i 不变\n\t\tans += tot * (n / l);\n\t\tl = r + 1;\n\t}\n\tcout &lt;&lt; ans;\n}\n或者我们也可以精简一点，写成\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tint ans = 0;\n \n\tfor (int l = 1, r; l &lt;= n; l = r + 1)\n\t{\n\t\tr = n / (n / l);\n\t\tans += (r - l + 1) * (n / l);\n\t}\n\tcout &lt;&lt; ans;\n}\n问题得到解决。"},"ACM-research/补题-补题-补题！/nowcoder/2025暑期多校/20250722":{"slug":"ACM-research/补题-补题-补题！/nowcoder/2025暑期多校/20250722","filePath":"ACM research/补题 补题 补题！/nowcoder/2025暑期多校/20250722.md","title":"20250722","links":[],"tags":[],"content":"F\n记 a + b = tot 分 n &gt;= tot 和 n &lt; tot 两类讨论。\n\n对于 n &lt; tot 如果 n &lt;= a 那么一定无法做到；如果 n &gt; a 那么直接可以做到 输出0\n对于 n &gt;= tot 我们直接令 n %= tot 表示可以经历完整的 n / tot 轮；对于剩下的余数 当 n &gt; a 时一个都不用删，当 n &lt;= a 时候必须全部删完。\n\nD\n签到。\n根据题目意思，我们可以发现 当已经有现成的 a 个并列的1 我们总可以先把他变成0然后再跟前后连续的一个0组成a + 1 个并列的0 也就是说 只要找到 a 个现成的连续1 或者 a + 1 个现成的连续0 我们就可以做到无限扩增，即输出 n 。\n对于剩下的情况 那就一步都无法操作 直接输出 count(all(s), &#039;1&#039;) 即可。\nJ\n一个重要的发现是 我们把 [x, y] (x &gt; y) 变成 [x - y, y * 2] 之后，左右的gcd是没有变化的，这个很容易证明。\n也就是说 对于 100 200 这样的情况 其实完全等价于 1 2。\n这之后 赛时猜了个 x + y 属于 二的次幂 … 就过了\n附上官方给的证明。\n\n令：判断数字 num 是否是 2的次幂，只需要判断 num &amp; (num - 1) 是否等于0即可。\nac code:\nvoid solve()\n{\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n \n    int g = __gcd(x, y);\n    int s = (x + y) / g;\n \n    if ((s &amp; (s - 1)) != 0)\n    {\n        cout &lt;&lt; -1;\n    }\n    else\n    {\n        cout &lt;&lt; 63 - __builtin_clzll(s);\n    }\n}\nA\n赛时没有注意到 1 &lt;= f[i] &lt;= i 注意到之后就很好写了。\n对于 0-based 的 第i行第i列，实际上它占用的格子就是 v[i][0] ~ v[i][i] 和 v[0][i] ~ v[i][i] 这两条 因为要让 mex = i 前面有 0 ~ i - 1 一共 i 个元素 所以是刚刚好的。\n对于第一行 / 第一列 由于 mex &lt;= 1 那么 这一列的剩下格子里 必须要大于1的才能出现；对于第二行 / 第二列，必须要大于2的才能出现…以此类推 一个比较简单的构造思路如下：\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; f(n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; f[i];\n    }\n \n    vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n, 0));\n \n    for (int i = 0; i &lt; n; i++)\n    {\n        if (f[i] == 1)\n        {\n            // 初始化全为0 什么都不做也行\n        }\n        else\n        {\n            for (int j = 0; j &lt; f[i] - 2; j++) // 第一行得是2 第二行得是3 以此类推 直到f[i] - 1被放下\n            {\n                a[i][j] = a[j][i] = j + 2;\n            }\n \n            a[i][i] = 1; // 对角线处放1\n        }\n    }\n \n    // 输出\n}\nE\n两个数字可以被同时除以d 那么d就是他们的公因数；譬如12和16可以同时被4整除的话，自然也可以同时被2整除；根据质因数分解定理，任何一个大于1的正整数都可以被分解为质数的乘积。\n因此 如果要让数列中所有数字经过这样的操作之后相等，其实就是判断 我们能否通过两两配对互相减少的方式 让这些数字中的每一个质数数量都减少到0\n不妨对每一个独立的质数p展开讨论：\n对于 n % 2 == 0 我们任选两个数字并让他们同时 *p or /p 质数数量的奇偶性是不会变的 那么如果cnt[p] % 2 == 0 最后就一定能被全部消去，反之则一定会留下一个；\n对于 n &amp; 1 我们做上面同样的操作 可以发现最后会留下一个，但是剩下就有若干对都是0 只需要把他们同时乘以 p 即可让数字达到一样。\n以 2 3 7 为例，其实通过\nv[0] *= 3 * 7\nv[1] *= 2 * 7\nv[2] *= 2 * 3\n即可让他们相等 亦即对于任何一个质数 我们让较少的若干对一直乘 就能达到效果。\n特别的，对于 n == 2 我们判断的唯一条件就是 v[0] == v[1] 这一点也很好想，如果本来不相同的话不管怎么操作都不能让他们相同。\n那么最后要解决的问题就是如何高效率计算质因数了，可以用 O(n ^ 2) 复杂度把每一个数字的最小质因子都预先求出来，然后O(1)查询即可，具体可以参考下方代码：\nconst int MAXN = 5000100;\nvector&lt;int&gt; minP(MAXN + 1);\n \nvoid pre()\n{\n    // 计算最小质因子表\n    for (int i = 0; i &lt;= MAXN; i++)\n    {\n        minP[i] = -1;\n    }\n \n    for (int i = 2; i &lt;= MAXN; i++)\n    {\n        if (minP[i] == -1) // i是质数\n        {\n            for (int j = i; j &lt;= MAXN; j += i)\n            {\n                if (minP[j] == -1)\n                {\n                    minP[j] = i;\n                }\n            }\n        }\n    }\n}\n \nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; a[i];\n    }\n \n    // 特殊情况\n    if (n == 2)\n    {\n        cout &lt;&lt; (a[0] == a[1] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;\n        return;\n    }\n \n    if (n % 2 == 1)\n    {\n        cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n        return;\n    }\n \n    // 统计每个质因子的总出现次数\n    map&lt;int, int&gt; cnt;\n    for (int x : a)\n    {\n        while (x &gt; 1)\n        {\n            int p = minP[x];\n            int tot = 0;\n            while (x % p == 0)\n            {\n                x /= p;\n                tot++;\n            }\n            cnt[p] += tot;\n        }\n    }\n \n\t// 检查所有质因子的出现次数是否都是偶数\n    for (auto &amp;[p, tot] : cnt)\n    {\n        if (tot % 2 == 1)\n        {\n            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n            return;\n        }\n    }\n \n    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n}"},"ACM-research/补题-补题-补题！/nowcoder/牛客周赛/101":{"slug":"ACM-research/补题-补题-补题！/nowcoder/牛客周赛/101","filePath":"ACM research/补题 补题 补题！/nowcoder/牛客周赛/101.md","title":"101","links":[],"tags":[],"content":"A\n签到。\n值得注意的是，log2 是以2为底的对数，log10 是以10为底的对数，所以 log 就是ln 了，直接输出 150 * log(n) 即可。\nB\n签到，找准除法的细节。\nC\n记 n 的最高位是 pos 那么这个数字就是 1 &lt;&lt; (pos + 1) - 1\n最高位可以用 __lg(n) 来快速求得\nvoid solve()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; (1 &lt;&lt; (__lg(n) + 1) - 1);\n}\nD\n注意到区间内包含1的 gcd的结果一定是1 所以想办法把需要的数字单独划分为一个区间，不需要的数字跟1放在一个区间 就行了\n怎么是需要的数字呢？譬如，1101 需要的数字就是 1000, 100, 1\n其实就是一个 lowbit\n有一些数字是无法取得的，具体来说，因为 gcd 中 1是必然出现的， 所以所有偶数都不行；排列中全体数字的或也就是 (1 &lt;&lt; (__lg(n) + 1) - 1 所以 m 超过这个数字也不行\n具体代码可以参考下方：\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    if (m % 2 == 0 or m &gt;= (1ll &lt;&lt; (__lg(n) + 1)))\n    {\n        cout &lt;&lt; -1;\n        return;\n    }\n \n    auto pos = __lg(m);\n    auto mm = m;\n    vector&lt;int&gt; v;\n    int idx = 0;\n    while (mm)\n    {\n        if (mm &amp; 1)\n        {\n            v.emplace_back(1ll &lt;&lt; idx);\n        }\n        mm &gt;&gt;= 1;\n        idx++;\n    }\n \n    reverse(all(v));\n    map&lt;int, int&gt; mp;\n    for (auto num : v)\n    {\n        cout &lt;&lt; num &lt;&lt; &#039; &#039;;\n        mp[num] = 1;\n    }\n    for (int i = 1; i &lt;= n; i++)\n    {\n        if (!mp.count(i))\n        {\n            cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n        }\n    }\n    cout &lt;&lt; endl;\n    cout &lt;&lt; v.size() &lt;&lt; endl;\n \n    for (int i = 0; i &lt; v.size(); i++)\n    {\n        cout &lt;&lt; i + 1 &lt;&lt; &#039; &#039;;\n        if (i + 1 == v.size())\n        {\n            cout &lt;&lt; n;\n        }\n        else\n        {\n            cout &lt;&lt; i + 1 &lt;&lt; endl;\n        }\n    }\n}\nE\n可以考虑对所给表达式求导，令导数为0，然后对导数二分或者直接求解都可以。\n这里着重讲一下三分。\n二分法适用于给出单调函数，查找特定值；三分法适用于给出单峰函数，让求极值。\n具体来说，我们给出 lmid = l + (r - l) / 3 rmid = r - (r - l) / 3 这就把整个区间划分成了三个部分 [l, lmid], [lmid, rmid], [rmid, r]\n这之后 我们比较 f(lmid) 和 f(rmid) 的关系\n对于求最小值：\n\n如果 f(lmid) &gt; f(rmid)：最小值在右半部分，舍弃左半部分\n如果 f(lmid) ≤ f(rmid)：最小值在左半部分，舍弃右半部分\n\n然后不断重复这个过程即可\n代码参考：\ndouble f(double k, double e)\n{\n    return 2 * k + 2 * e / pow(2, k);\n}\n \nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n \n    double px, py;\n    cin &gt;&gt; px &gt;&gt; py;\n \n    double ans = 0.0;\n    const double eps = 1e-9;\n \n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        double x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n \n        double e = sqrt(pow(x - px, 2) + pow(y - py, 2));\n \n        // 三分法求最小值\n        double l = 0.0, r = 100.0;\n        while (r - l &gt; eps)\n        {\n            double lmid = l + (r - l) / 3;\n            double rmid = r - (r - l) / 3;\n            if (f(lmid, e) &gt; f(rmid, e))\n            {\n                l = lmid;\n            }\n            else\n            {\n                r = rmid;\n            }\n        }\n \n        double k = (l + r) / 2;\n        ans += 2 * k + 2 * e / pow(2, k);\n        px = x;\n        py = y;\n    }\n \n    cout &lt;&lt; ans;\n}"},"ACM-research/贪心套路/P1":{"slug":"ACM-research/贪心套路/P1","filePath":"ACM research/贪心套路/P1.md","title":"P1","links":["ACM-research/贪心套路/P2"],"tags":[],"content":"题目1\n题目1\n题目1\n题目1\n题目1\n题目1\nP2"},"ACM-research/贪心套路/P2":{"slug":"ACM-research/贪心套路/P2","filePath":"ACM research/贪心套路/P2.md","title":"P2","links":["模下快速幂","ACM-research/贪心套路/P3"],"tags":[],"content":"题目1\n现需要将一根长为正整数n的竹子砍为若干段\n每段长度均为正整数\n请返回每段竹子长度的最大乘积是多少\n答案需要对1000000007取模\n前置知识：模下快速幂\n观察得到：\nn = 4 -&gt; 2 * 2 -&gt; 4 % 3 = 1\nn = 5 -&gt; 3 * 2 -&gt; 5 % 3 = 2\nn = 6 -&gt; 2 * 2 -&gt; 6 % 3 = 0\nn = 7 -&gt; 3 * 2 * 2 -&gt; 7 % 3 = 1\nn = 8 -&gt; 3 * 3 * 2 -&gt; 8 % 3 = 2\nn = 9 -&gt; 3 * 3 * 3 -&gt; 9 % 3 = 0\n \n进而\nn &lt;= 3 特判\nn &gt; 3 时\nif (n % 3 == 0)\n{\n\treturn quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 1)\n{\n\tn -= 4;\n\treturn 4 * quickmod(3, n / 3, mod) % mod;\n}\nif (n % 3 == 2)\n{\n\tn -= 2;\n\treturn 2 * quickmod(3, n / 3, mod) % mod;\n}\n \n也可以这么写：\nauto tail = n % 3 == 0 ? 1 : (n % 3 == 1 ? 4 : 2);\nauto power = tail == 1 ? n : (n - tail) / 3;\nreturn quickmod(3, power, mod) * tail % mod;\n题目2\n一个数字n一定要分成k份 得到的乘积最大是多少\n数字n 和 k 有可能到达{10}^{12}\n结果需要对 1e9 + 7 取模\n先计算平均值 再算多多少\nint n, k, mod = 1e9 + 7;\ncin &gt;&gt; n &gt;&gt; k;\nauto a = n / k;\nauto b = n % k;\nauto ans1 = quickmod(a + 1, b, mod);\nauto ans2 = quickmod(a, k - b, mod);\nreturn ans1 * ans2 % mod;\n题目3\n给若干会议的开始，结束时间\n参加某个会议的期间 不能参加其他会议\n返回能参加的最大会议数量\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[v1, v2] : v)\n{\n\tcin &gt;&gt; v1 &gt;&gt; v2;\n}\n \n// 贪心策略 结束时间早的早排\nranges::sort(v, [](auto &amp;v1, auto &amp;v2) { return v1.second &lt; v1.second; });\nint ans = 1;\nauto [beg, en] = v[0];\nfor (int i = 1; i &lt; n; i++)\n{\n\tauto [curbe, curen] = v[i];\n\tif (curbe &gt;= en)\n\t{\n\t\ten = curen;\n\t\tans++;\n\t}\n}\nreturn ans;\n题目4\n给定若干会议的开始，结束时间\n任何会议的召开期间 你只需要抽出一天来参加\n但是 同一天只能参加一个会议\n返回你能参加的最大会议数量\n\n思路：\n等价于牛客寒假H\n两种做法 一种是维护一个小根堆 一种是集合 + 二分\n\n二分做法\nint n, ans = 0, last = -1;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (auto &amp;&amp;[a, b] : v) cin &gt;&gt; a &gt;&gt; b; last = max(last, b);\nranges::sort(v, [](auto &amp;&amp;v1, auto &amp;&amp;v2)\n{\n\tauto [a, b] = v1, [c, d] = v2;\n\treturn a == c ? b &lt; d : a &lt; c;\t\n});\nset&lt;int&gt; st;\nfor (int i = 1; i &lt;= last; i++) st.insert(i);\n \nfor (auto &amp;&amp;[a, b] : v)\n{\n\tauto it = st.lower_bound(a);\n\tif (it != st.end() and *it &lt;= r)\n\t{\n\t\tans++;\n\t\tst.erase(*it);\n\t}\n}\n \ncout &lt;&lt; ans;\n小根堆做法：\nint n, ans = 0;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nmap&lt;int, vector&lt;int&gt;&gt; mp;\nfor (auto &amp;&amp;[a, b] : v) \n{\n\tcin &gt;&gt; a &gt;&gt; b;\n\tmp[a].emplace_back(b);\n}\n \npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nint index = 1;\nfor (auto &amp;&amp;i : mp[index]) pq.push(i);\nwhile (pq.size())\n{\n\twhile (pq.size() and pq.top() &lt; index) pq.pop();\n\tif (!pq.empty()) \n\t{\n\t\tpq.pop();\n\t\tans++;\n\t\tindex++;\n\t\tfor (auto &amp;&amp;i : mp[index]) pq.push(i);\n\t}\n}\ncout &lt;&lt; ans;\n题目5\n给你n个项目，对于每一个项目i\n有一个纯利润prefits[i] 和启动该项目需要的最小资本 capital[i]\n最初你的资本是w 完成一个项目的时候你将获得纯利润 添加到你的总资本中\n从给定项目中选择最多k个不同项目的列表 最大化你的最终资本ans\nint n, w, k; \ncin &gt;&gt; n &gt;&gt; w &gt;&gt; k; \nvector&lt;pair&lt;int, int&gt;&gt; projects(n); // pair&lt;capital, profit&gt; \nfor (int i = 0; i &lt; n; i++) \n{ \n\tcin &gt;&gt; projects[i].second; // profit \n} \nfor (int i = 0; i &lt; n; i++) \n{\n\tcin &gt;&gt; projects[i].first; // capital \n} \n// 按启动资本排序\nranges::sort(projects);\n// 优先队列保存利润，默认是大顶堆 \npriority_queue&lt;int&gt; pq; \nint index = 0; \nfor (int i = 0; i &lt; k; i++) \n{ \n\t// 将所有启动资本小于等于当前资金的项目加入优先队列 \n\twhile (index &lt; n &amp;&amp; projects[index].first &lt;= w) \n\t{ \n\t\tpq.push(projects[index].second); \n\t\tindex++; \n\t} \n\t// 如果没有可做的项目，则退出 \n\tif (pq.empty()) break; \n\t// 选择当前利润最大的项目 \n\tw += pq.top(); \n\tpq.pop(); \n} \ncout &lt;&lt; w;\n题目6\n给定一个非负数组v 计算任何两个数差值的绝对值\n如果v中没有 将绝对值加入到v里 但是只加入一次\n直到arr大小固定 返回最终长度\n结论：求出这个数组中所有数字的gcd 记为num\n这个数组中所有数字的最大值 记为max\n那么\nfor (int i = num; i &lt;= max; i += num) // 所有的i都会在这个数组中\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n;i ++) \n{\n\tcin &gt;&gt; v[i];\n\tmp[v[i]]++;\n}\nint ans = n, num = gcd(v[0], v[1]);\nfor (int i = 2; i &lt; n; i++) num = gcd(num, v[i]);\n// 现在num是所有数字的最大公约数\nint maxnum = ranges::max(v);\nfor (int i = num; i &lt;= max; i += num) ans += (mp.count(i) == 0);\ncout &lt;&lt; ans;\nP3"},"ACM-research/贪心套路/P3":{"slug":"ACM-research/贪心套路/P3","filePath":"ACM research/贪心套路/P3.md","title":"P3","links":["ACM-research/贪心套路/P4"],"tags":[],"content":"题目1\n给一个整数数组nums 需要找出一个连续子数组\r\n如果对这个子数组进行升序排序 那么整个数组都会变成升序排序\r\n请你找出这个最小的连续子数组\n// 这个空着不写 看下次能不能想起来\n题目2\n给很多个有序数组 返回一个长度最小的区间 [a, b] 使得每一个数组中都有一个数字在这个区间中\n用一个最小堆维护最小值 最大堆维护最大值\n题目3\n组团买票\r\n景区里一共有m个项目，景区的第i个项目有如下两个参数：\r\ngame[i] = { Ki, Bi }，Ki、Bi一定是正数\r\nKi代表折扣系数，Bi代表票价，举个例子 : Ki = 2, Bi = 10\r\n如果只有1个人买票，单张门票的价格为 : Bi - Ki * 1 = 8\r\n所以这1个人游玩该项目要花8元\r\n如果有2个人买票，单张门票的价格为 : Bi - Ki * 2 = 6\r\n所以这2个人游玩该项目要花6 * 2 = 12元\r\n如果有5个人买票，单张门票的价格为 : Bi - Ki * 5 = 0\r\n所以这5个人游玩该项目要花5 * 0 = 0元\r\n如果有更多人买票，都认为花0元(因为让项目倒贴钱实在是太操蛋了)\r\n于是可以认为，如果有x个人买票，单张门票的价格为 : Bi - Ki * x\r\nx个人游玩这个项目的总花费是 : max { x * (Bi - Ki * x), 0 }\r\n单位一共有n个人，每个人最多可以选1个项目来游玩，也可以不选任何项目，由你去按照上面的规则，统一花钱购票\r\n你想知道自己需要准备多少钱，就可以应付所有可能的情况，返回这个最保险的钱数\r\n1 &lt;= M、N、Ki、Bi &lt;= 10^5\n\n其实就是要找出景区公园赚最多钱的情况\n\n如何让公园最赚钱？\r\n我们只需要把人 挨个送到最赚钱的项目去\r\n如何统计这个指标？\r\n假设现在来了a人 每个人要付的钱就是b - k * a\r\n现在又来了一个 每个人要付的钱就变成了 b - k * (a + 1) - k * a\n题目4\n平均值最小累加和\r\n给定数组v 长度为n 需要从中划分出 k 组\r\n返回每组的平均值累加起来的 最小值\n\n思路：\r\n其实就是把前k - 1 个数单独放一组， 剩下的n - k + 1 个大数字求平均值 然后累加\n\n题目5\n执行所有任务的最少初始电量\r\n每一个任务有两个参数，需要耗费的电量 a 、至少多少电量才能开始这个任务 b\r\n返回手机至少需要多少的初始电量，才能执行完所有的任务\r\n现在是m m 需要 &gt;= b 执行完任务之后变成m - a\n\n结论：耗费 - 至少的差值越小 越先进行; 耗费 - 至少的差值越大 越先倒推\n\n题目6\n两个0和1数量相等区间的最大长度\r\n给出一个长度为n的01串，现在请你找到两个区间\r\n使得这两个区间中，1的个数相等，0的个数也相等\r\n这两个区间可以相交，但是不可以完全重叠，即两个区间的左右端点不可以完全一样\r\n现在请你找到两个最长的区间，满足以上要求\r\n返回区间最大长度\n011010 的两个区间 分别是 01101 11010\n\n可能性1 找到区间最左侧 最右侧 的0\n可能性2 找到区间最左侧 最右侧 的1\n两者求最大值即可\n\nP4"},"ACM-research/贪心套路/P4":{"slug":"ACM-research/贪心套路/P4","filePath":"ACM research/贪心套路/P4.md","title":"P4","links":["ACM-research/贪心套路/P5"],"tags":[],"content":"题目1\n给你一个数组 对于其中的奇数 你可以让他*＝ 2 对于其中的偶数 你可以让他 /= 2 记这个数组最大值与最小值之差为 偏移量 返回偏移量的最小值\n\n思路：\n对于所有的奇数 我们可以先 *＝ 2 让它获得被除的机会 接下来 我们只需要用multiset 维护这个数组 然后不断对最大值除以二 并记录偏移量即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nmultiset&lt;int&gt; mst;\nfor (int i = 0; i &lt; n; i++)\n{\n\tif (v[i] &amp; 1) v[i] *= 2;\n\tmst.insert(v[i]);\n}\n \nint ans = *mst.rbebin() - *mst.begin();\nwhile (*mst.rbegin() % 2 == 0)\n{\n\tauto num = *mst.rbegin();\n\tmst.erase(num);\n\tnum /= 2;\n\tmst.insert(num);\n\tans = min(ans, *mst.rbebin() - *mst.begin());\n}\ncout &lt;&lt; ans;\n题目2\n森林中有很多只兔子 你问了一些兔子”有几只兔子跟你颜色相同？” 兔子们的回答绝对真实 但是你可能只问了一部分兔子 现在你得到了兔子们的回答answer 求森林中至少有多少只兔子\n\n思路：\n对于所有回答一样的兔子，对他们分组 每n + 1 只兔子分为一组，最后乘n + 1 就得到了答案\n\n代码：\nint n;\ncin &gt;&gt; n;\nmap&lt;int, int&gt; mp;\nwhile (n--)\n{\n\tint num;\n\tcin &gt;&gt; num;\n\tmp[num]++;\n}\n \nint ans = 0;\n \nfor (auto &amp;&amp;[k, v] : mp)\n{\n\t// 每n + 1只分为一组 也就是总数 / n + 1 向上取整\n\tauto a = (v + (k + 1) - 1) / (k + 1);\n\tans += a * (k + 1);\n}\n \ncout &lt;&lt; ans;\n\n总结：\n向上取整的操作通常应用于对某个目标分组，比如\n现在有七十个学生，每辆车最多可以垃50个 请问一共需要用几辆车\n这种时候分组策略就是总数 / 分组依据 然后向上取整\n也就是ans = (a + b - 1) / b\n\n题目3\n给定两个数组nums和target 你可以对nums的任意两个元素作变换（其中一个+= 2 另外一个-= 2 返回你要操作多少次才能使得这两个数组相等 （可以证明一定存在相等策略\n\n思路：这道题的简化背景其实是 给两个数组 可以对其中一个的任意元素增减 返回使得这两个数组元素相等的最小操作次数\n对两个数组都排序，就显而易见的得出答案了\n\n那么对于这一题 我们需要注意到，每次增加减少2 不会改变他们的奇偶性——所以我们应该对奇偶性分组\n分组之后 我们直接记录变换次数然后除以二即可\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n), t(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; t[i];\n \nauto change = [&amp;](vector&lt;int&gt; &amp;v) -&gt; void\n{\n\tvector&lt;int&gt; odd, even;\n\tfor (int i = 0; i &lt; n; i++)\n\t{\n\t\tif (v[i] &amp; 1)\n\t\t{\n\t\t\todd.emplace_back(v[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\teven.emplace_back(v[i]);\n\t\t}\n\t}\n\tranges::sort(odd);\n\tranges::sort(even);\n\todd.insert(odd.end(), all(even));\n\tv = odd;\n};\n \nchange(v);\nchange(t);\n \nint ans = 0;\nfor (int i = 0; i &lt; n; i++) ans += abs(v[i] - t[i]) / 2;\ncout &lt;&lt; ans / 2;\n\n总结：\n下次遇到增减2的时候 要注意这不会改变奇偶性\n\n题目4\n部门要挑选两个员工去参加竞赛，每一个员工有a b 两个指标 部门会把两个员工的两个指标分别取平均值得到A B 求min(A,B)的最大值\n\n思路：\nn^2 的思路是容易想到的，但是我们不允许这样的复杂度 在此基础上 我们应当保证尽可能取消内层循环\n我们应当使用abs(a_1 - b_1) &lt; abs(a_2 - b_2) 来sort 这样一来 我们有：\n对于任意 v[i] (abs(a - b) == k) 它前面的所有a和b一定满足abs(a - b) ⇐ k 也就是说 相加之后不会改变min所在的位置\n因此 我们直接设置两个变量记录最大值最小值即可\n\nint n;\ncin &gt;&gt; n;\nvector&lt;pair&lt;int, int&gt;&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].first &gt;&gt; v[i].second;\nranges::sort(v, [](auto a, auto b) { \nreturn abs(a.first - a.second &lt; b.first - b.second;) });\n \nint max1 = a.first, max2 = a.second, ans = 0;\nfor (int i = 1; i &lt; n; i++)\n{\n\tans = min(v[i].first + max1, v[i].second + max2);\n\tmax1 = max(max1, v[i].first);\n\tmax2 = max(max2, v[i].second);\n}\ncout &lt;&lt; ans * 0.1 / 2;\n题目5\n题目6\nP5"},"ACM-research/贪心套路/P5":{"slug":"ACM-research/贪心套路/P5","filePath":"ACM research/贪心套路/P5.md","title":"P5","links":[],"tags":[],"content":"题目1\n跳跃游戏ii\r\n给你一个数组v v[i] 表示从i开始最多能跳几格，求到达n - 1下标的最少次数\n\n思路：\r\n我们设置一个变量right 来维护当前跳跃的范围，endd来维护当前可以到达的最大格子，ans 来记录答案\n\n操作过程如下：\n\n每走到一个新的格子 判断当前格子在不在跳跃可达的范围内，如果不行的话 说明需要一次额外的跳跃，此时ans++, right = endd\n每走到一个新的格子 更新end = max(end, i + v[i])\r\n代码：\n\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt; v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\n \nint ans = 0, right = 0, endd = 0;\nfor (int i = 0 ; i &lt; n; i++)\n{\n\tendd = max(endd, i + v[i]);\n\tif (i == right)\n\t{\n\t\tif (i == endd)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tright = endd;\n\t}\n}\n题目2\n浇水问题：\r\n给你一个数组v 其中 v[i] 表示第i个地方有一个水管 浇水可以覆盖[i - v[i], i + v[i]] 求使得整个花园都能浇到水的最少水管数目 如果无法完全覆盖，返回－1\n\n思路：\r\n我们先创建一个新的数组right 其中right[i] 表示第i个位置开始 能到达的范围\r\n例如：v[3] = 2 那么v[3] 可以覆盖[1, 5] 的范围 那么 right[1] = max(right[1], 5)\n\n\n随后，这个问题就跟题目一一模一样了\n\n代码：\nint n;\ncin &gt;&gt; n;\nvector&lt;int&gt;v(n);\nfor (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];\nvector&lt;int&gt; right(n);\nfor (int i = 0; i &lt; n; i++) right[i - v[i]] = max(right[i - v[i]], i + v[i]);\n \nint ans = 0, curright = 0, nextright = 0;\nfor (int i = 0; i &lt; n; i++)\n{\n\tnextright = max(nextright, right[i]);\n\tif (i == curright)\n\t{\n\t\tif (i == nextright)\n\t\t{\n\t\t\tcout &lt;&lt; -1;\n\t\t\treturn;\n\t\t}\n\t\tans++;\n\t\tcurright = nextright;\n\t}\n}\ncout &lt;&lt; ans;\n题目3\n题目4\n题目5\n题目6"},"ACM-research/贪心套路/贪心":{"slug":"ACM-research/贪心套路/贪心","filePath":"ACM research/贪心套路/贪心.md","title":"贪心","links":[],"tags":[],"content":"贪心算法通常具有以下几个重要性质：\n1. 贪心选择性质\n\n局部最优：每一步都做出当前看起来最优的选择\n不可撤销：一旦做出选择，不会回溯修改\n子问题独立：当前决策不依赖于后续决策 1\n\n示例：\n// 常见的贪心模式\nwhile(有选择) {\n    choice = 选择当前最优解;\n    result = 将选择添加到结果中;\n    problem = 在剩余问题上继续;\n}\n2. 最优子结构性质\n\n问题的最优解包含子问题的最优解\n子问题之间相互独立，不存在交叉影响\n\n3. 特征识别\n贪心问题通常具有以下特征：\n\n排序帮助：\n\n// 很多贪心问题第一步是排序\nsort(arr.begin(), arr.end()); // 按某种规则排序\n\n局部决策：\n\nfor(int i = 0; i &lt; n; i++) {\n    // 每一步只考虑当前最优\n    if(isGood(current)) {\n        ans = max(ans, current);\n    }\n}\n\n不需要回溯：\n\n// 贪心通常是单向遍历\n// 不需要考虑之前的决策\nvisited[current] = true; // 标记已访问\n// 不会再修改visited[current]\n4. 正确性证明方法\n贪心算法的正确性证明通常包含：\n\n归纳证明：\n\n\n证明局部最优能导致全局最优\n证明不存在更优解\n\n\n反证法：\n\n\n假设存在更优解\n证明可以通过贪心策略得到相同或更优结果\n\n\n交换论证：\n\n\n证明任何非贪心策略都可以通过交换变成贪心策略\n且交换不会使结果变差\n\n5. 常见贪心策略\n\n选择排序：\n\n// 按照某种规则排序后遍历\nsort(intervals.begin(), intervals.end());\nfor(auto interval : intervals) {\n    // 处理每个区间\n}\n\n优先队列：\n\npriority_queue&lt;int&gt; pq;\n// 维护当前最优选择\nwhile(!pq.empty()) {\n    int top = pq.top();\n    pq.pop();\n    // 处理最优选择\n}\n\n双指针：\n\nint left = 0, right = n-1;\nwhile(left &lt; right) {\n    // 从两端向中间处理\n    // 每次选择最优的移动方向\n}\n6. 反例识别\n不适合用贪心的情况：\n\n需要考虑全局最优\n当前决策依赖于后续决策\n存在多个相互影响的约束条件\n\n记住：贪心算法的关键是证明局部最优能导致全局最优！"},"BEGINNING-of-markdown":{"slug":"BEGINNING-of-markdown","filePath":"BEGINNING of markdown.md","title":"BEGINNING of markdown","links":["ACM-research/学习笔记"],"tags":["begin"],"content":"heading 1\nheading 2\nheading 3\nheading 4\nheading 5\nheading 6\nbold\nitalic\n\nbullet item 1\nbullet item 2\n\nnested item\n\n\nbullet item 1\n\n\nno.1\nno.2\n\n学习笔记\nlink text\nHighlight Text\n～～ dont know why i cant use strikethrough ～～\n\n checkbox\n put ‘x’\n\n\n\n                  \n                  Node\n                  \n                \n\n\n1\n\n\n\n\n%这是一个注释%\n\n以下是 latex 教程\n\n+\n-\n\\times\n\\div\n=\n\\neq \n(a + b)\n\\{a + b\\}\n[a + b]\n\\frac{a}{b}\n\na^2\nx_1\n\\sqrt{a}\n\\alpha \\times \\beta = \\gamma\n\\sum_{i = 1}^{n} i\n\\Sigma_{i = 1}^{n} i\n\\Pi_{i = 1}^{n} i"},"Quick-LaTeX-readme":{"slug":"Quick-LaTeX-readme","filePath":"Quick LaTeX readme.md","title":"Quick LaTeX readme","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShorthandStringShorthandStringShorthandStringsq\\sqrt{}bb\\mathbb{}bf\\mathbf{}te\\text{}inf\\inftybi\\binom{#cursor}{#tab}cd\\cdotqu\\quadti\\timesal\\alphabe\\betaga\\gammaGa\\Gammade\\deltaDe\\Deltaep\\epsilonze\\zetaet\\etath\\thetaTh\\Thetaio\\iotaka\\kappala\\lambdaLa\\Lambdamu\\munu\\nuxi\\xiXi\\Xipi\\piPi\\Pirh\\rhosi\\sigmaSi\\Sigmata\\tauup\\upsilonUp\\Upsilonph\\phiPh\\Phich\\chips\\psiPs\\Psiom\\omegaOm\\Omega"},"collage-study/大学物理":{"slug":"collage-study/大学物理","filePath":"collage study/大学物理.md","title":"大学物理","links":[],"tags":[],"content":"质点运动学\n位移 速度 加速度\n\n位置矢量(位矢)\n\n建立直角坐标系后，物体位置用坐标A(x, y, z) 表示\n向量\\vec{r} = \\vec{OA} 就称为 位置矢量 也记作 \\vec{r} = x\\vec{i} +y \\vec{j} + z \\vec{k}\n\n\n运动方程\n\n质点坐标x, y, z 随 t 的变化关系，将 t 消掉即可\n\n\n\n例：已知质点运动学方程是 \\vec{r} = 4t^{2} \\vec{i} + (2t +3)\\vec{j} 求质点的运动方程\nx = 4t^{2}, y = 2t +3 \\to t = \\frac{y - 3}{2} \\to x = 4(\\frac{y - 3}{2}) ^{2}\n\n位移与路程\n\n物体的位置变化记为位移\\triangle\\vec{r}  用起点到终点的有向线段表示\n物体实际运动的路径长为路程\\triangle s\n注意\n\n\\triangle \\vec{r} 是位移，|\\triangle \\vec{r} | 是 位移的大小，\\triangle r 是物体到原点距离的变化\n只有 ds = |d\\vec{r}| 是对的\n\n\n\n\n\n圆周运动的参数\n相对运动\n机械振动\n\\begin{align}\n\\text{位移:} \\quad &amp; x = A \\cos(\\omega t + \\phi) \\\\\n\\text{速度:} \\quad &amp; v = \\frac{dx}{dt} = -A \\omega \\sin(\\omega t + \\phi) \\\\\n\\text{加速度:} \\quad &amp; a = \\frac{dv}{dt} = -A \\omega^2 \\cos(\\omega t + \\phi) \\\\\n\\text{角频率:} \\quad &amp; \\omega = \\sqrt{\\frac{k}{m}} = \\frac{2\\pi}{T} = 2\\pi f \\\\\n\\text{动能:} \\quad &amp; E_k = \\frac{1}{2}mv^2 = \\frac{1}{2}m\\omega^2 A^2 \\sin^2(\\omega t + \\phi) \\\\\n\\text{势能:} \\quad &amp; E_p = \\frac{1}{2}kx^2 = \\frac{1}{2}kA^2 \\cos^2(\\omega t + \\phi) \\\\\n\\text{总能量:} \\quad &amp; E = E_k + E_p = \\frac{1}{2}kA^2 \\\\\n\\text{最大速度:} \\quad &amp; v_{\\text{max}} = A\\omega \\\\\n\\text{最大加速度:} \\quad &amp; a_{\\text{max}} = A\\omega^2 \\\\\n\\text{微分方程:} \\quad &amp; \\frac{d^2x}{dt^2} + \\omega^2 x = 0\n\\end{align}\n以下是一些简谐振动的经典二级结论及其详细推导过程，适合用于快速解题和理解物理本质。所有公式均提供 LaTeX 源码。\n\n结论1：弹性力在半个周期内所做的功为 0\n推导过程：\n弹性力是保守力，其做功仅取决于初末位置的势能差。\n简谐振动中，半个周期（T/2）内振子从位置 x_0 移动到对称位置 -x_0，势能变化为：\n\\Delta E_p = \\frac{1}{2}k(-x_0)^2 - \\frac{1}{2}k x_0^2 = 0\n因此弹性力做功 W = -\\Delta E_p = 0。\n\n结论2：动能与势能相等时的位移 x = \\pm \\frac{A}{\\sqrt{2}}\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，当动能等于势能时：\nE_k = E_p = \\frac{1}{2}E \\Rightarrow \\frac{1}{2}kx^2 = \\frac{1}{2} \\cdot \\frac{1}{2}kA^2\n解得：\nx^2 = \\frac{A^2}{2} \\Rightarrow x = \\pm \\frac{A}{\\sqrt{2}}\n\n结论3：最大速度 v_{\\text{max}} = A\\omega（平衡位置）\n推导过程：\n动能最大值对应速度最大值：\nE_k^{\\text{max}} = \\frac{1}{2}mv_{\\text{max}}^2 = \\frac{1}{2}kA^2\n\\Rightarrow v_{\\text{max}} = A \\sqrt{\\frac{k}{m}} = A\\omega\n\n结论4：最大加速度 a_{\\text{max}} = A\\omega^2（端点）\n推导过程：\n加速度由胡克定律 F = -kx 和牛顿第二定律 F = ma 得：\na = -\\frac{k}{m}x \\Rightarrow |a|_{\\text{max}} = \\frac{k}{m}A = A\\omega^2\n\n结论5：速度与位移的相位差 \\frac{\\pi}{2}\n推导过程：\n位移 x = A\\cos(\\omega t + \\phi)，速度 v = -A\\omega\\sin(\\omega t + \\phi)。\n利用三角恒等式：\n\\sin\\theta = \\cos\\left(\\theta - \\frac{\\pi}{2}\\right)\n\\Rightarrow v = A\\omega\\cos\\left(\\omega t + \\phi + \\frac{\\pi}{2}\\right)\n因此速度超前位移 \\frac{\\pi}{2}。\n\n结论6：周期与振幅无关（等时性）\n推导过程：\n简谐振动周期 T = 2\\pi\\sqrt{\\frac{m}{k}}，仅依赖于系统参数（质量 m 和劲度系数 k），与振幅 A 无关。\n这是简谐振动的核心特性。\n\n结论7：能量与振幅平方成正比\n推导过程：\n总能量 E = \\frac{1}{2}kA^2，直接表明能量与振幅的平方成正比。\n\n结论8：单摆周期公式（小角度近似）\n推导过程：\n单摆受力矩 \\tau = -mgl\\sin\\theta，小角度下 \\sin\\theta \\approx \\theta，\n微分方程为：\n\\frac{d^2\\theta}{dt^2} + \\frac{g}{l}\\theta = 0 \\Rightarrow T = 2\\pi\\sqrt{\\frac{l}{g}}\n\n结论9：垂直弹簧振子的平衡位置偏移\n推导过程：\n竖直悬挂时，平衡位置满足 mg = kx_0 \\Rightarrow x_0 = \\frac{mg}{k}。\n振动仍为简谐运动，振幅以该平衡位置为中心。\nx_0 = \\frac{mg}{k} \\quad \\text{(竖直悬挂时的平衡位置)}\n\\end{equation}$$\n\n---\n\n### **结论10：串联/并联弹簧的等效劲度系数**\n\n- **串联**：$\\frac{1}{k_{\\text{eq}}} = \\frac{1}{k_1} + \\frac{1}{k_2}$  \n- **并联**：$k_{\\text{eq}} = k_1 + k_2$\n\n\n### 例题\n\\begin{align}\n&amp;m = 10^{-3} kg \\\n&amp;x = 0.1 \\cos (8 \\pi t +\\frac{2\\pi}{3})\n\\end{align}\n求弹簧周期，振幅，初相位，速度和加速度的最大值\n\\begin{align}\n&amp;\\omega = 8\\pi \\\n&amp;T = \\frac{2\\pi}{\\omega} = \\frac{2\\pi}{8\\pi} = \\frac{1}{4} \\\n&amp;A= 0.1 \\\n&amp;\\phi = \\frac{2\\pi}{3} \\\n&amp;v_{max} =  A\\omega = 0.8\\pi \\\n&amp;a_{max} =  A\\omega ^ 2 = 6.4 \\pi ^ 2\n\\end{align}\n求最大回复力，最大动能，平均动能和平均势能，在哪些位置上动能势能相等？\n\\begin{align}\n&amp;F_{max} = -kA \\\n&amp;E_k , {max} = \\frac{1}{2}mv{max} \\\n&amp;\\overline{E_k} = \\overline{E_p} = \\frac{1}{2}E_{总} = \\frac{1}{4}\\omega A ^ 2 \\\n&amp;x = \\pm \\frac{A}{\\sqrt{2}} \\quad \\text{时，动能势能相等}\n\\end{align}\n求 $t_2 = 5s$ 和 $t_1 = 1s$ 两个时刻的相位差\n\\begin{align}\n&amp;\\phi(t) = 8\\pi t + \\frac{2\\pi}{3} \\\n&amp;\\triangle \\phi = 32 \\pi\n\\end{align}\n## 机械波\n## 静电场\n\\begin{align*}\n\\text{库仑定律:} \\quad &amp; F = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q_1 q_2}{r^2} \\\n\\text{电场强度:} \\quad &amp; \\vec{E} = \\frac{\\vec{F}}{q_0} \\\n\\text{高斯定律:} \\quad &amp; \\oint \\vec{E} \\cdot d\\vec{A} = \\frac{Q_{\\text{enc}}}{\\varepsilon_0} \\\n\\text{电势:} \\quad &amp; V = \\frac{1}{4\\pi\\varepsilon_0} \\cdot \\frac{q}{r} \\\n\\text{电容:} \\quad &amp; C = \\frac{Q}{V}, \\quad C_{\\text{平行板}} = \\varepsilon_0 \\frac{A}{d} \\\n\\text{电容器储能:} \\quad &amp; U = \\frac{1}{2} C V^2\n\\end{align*}\n对电荷连续分布的带电体：\n\\begin{align*}\nd\\vec{F} &amp;= \\frac{q_{0} dq}{4\\pi \\epsilon_{0}r} \\vec{r^{0}} \\\n即:\\\nd\\vec{F} &amp;= \\frac{q_{0} \\vec{r^{0}}}{4\\pi \\epsilon r} , dq\\\n则有\\\n\\vec{F} &amp;= \\int_{Q} \\frac{q_{0} \\vec{r^{0}}}{(4\\pi \\epsilon r) }, dq\\\n\\\n其中，dq &amp;=\n\\begin{cases}\n\\lambda , dl \\quad \\text{(线密度)}\\\n\\sigma , dS \\quad \\text{(面密度)}\\\n\\rho , dV \\quad \\text{(体分布)}\n\\end{cases}\\\n\\end{align*}\n矢量积分的一般步骤：\n1. 设坐标，取积分微元，这里是 $dq$ (按照电荷的分布情况取)\n2. 写出点电荷 $dq$ 的电场强度 $d\\vec{E}$ 的大小，方向（标在图上）\n3. 坐标分解 $d\\vec{E}$ (在图上也要画出）\n4. 对 $d\\vec{E}$ 的各个坐标分量 积分\n\n##### 长为 $L$ 的均匀带电直杆，电荷线密度为 $\\lambda$ 求：\n它在空间一点 $P$ 产生的电场强度 （$P$ 点到杆的垂直距离为 $a$)\n\n\\begin{align*}\n\\text{电场强度} ; d\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{dq}{r} \\\nr &amp;= \\sqrt{a^{2} + x^{2}}\\\n设所成角度为 , \\theta ,则有\\\n\\frac{a}{x} &amp;= \\tan \\theta\\\n\\text{这道题是杆子 有}\\\ndq &amp;= \\lambda , dx\\\n\\end{align*}\n##### 一个半径为 $R$ 的导体球表面的面电荷密度为 $\\sigma$ 那么，在距球面 $R$ 处的电场强度为\n\\begin{align*}\n电场强度 \\quad d\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{dq}{r} \\vec{r^{0}}\\\n由高斯定理\\\n\\oint \\vec{E} , dS &amp;= \\frac{Q}{\\epsilon} \\\n则有 \\\n\\vec{E} ,4\\pi (2R) ^{2} &amp;= \\frac{\\sigma \\int dS}{\\epsilon}\\\n解得\\\n\\vec{E} &amp;= \\frac{\\sigma 4 \\pi R^{2}}{4 \\pi 4R ^ {2} \\epsilon} \\\n&amp;= \\frac{\\sigma}{4\\epsilon}\n\\end{align*}\n##### 已知球体半径为 $R$ 带电量为 $q$ （电荷体密度为 $\\rho$ ）求均匀带电体的电场强度分布\n\\begin{align*}\n对于球外 (r &gt;= R)\\\n\\vec{E} &amp;= \\frac{1}{4\\pi \\epsilon} \\frac{q}{r^{2}}\\vec{r}^{0}\\\n\\\n由高斯定理，有\\\n\\oint \\vec{E} ,dS &amp;= \\frac{Q}{\\epsilon}\\\n即\\\n\\vec{E} , 4 \\pi r^{2} &amp;= \\frac{q}{\\epsilon}  \\\n\\\n对于球内 （r &lt; R) \\\n\\oint \\vec{E} , dS &amp;= \\vec{E} , 4 \\pi r ^{2} \\\n&amp;= \\frac{\\sigma \\int_{0}^{r} \\rho , dV}{\\epsilon}\\\n&amp;= \\frac{\\sigma \\rho 4 \\pi r^{3} }{3\\epsilon}\n\\end{align*}\n\n\\begin{align*}\\\n\\vec{E} &amp;= \\frac{1}{4 \\pi \\epsilon} \\frac{q}{r^{2}} \\vec{r^{0}} \\\n\\\n\\\nF &amp;= k \\frac{q_{1}q_{2}}{r^{2}}\n\\end{align*}\n"},"collage-study/离散数学-充分复习":{"slug":"collage-study/离散数学-充分复习","filePath":"collage study/离散数学 充分复习.md","title":"离散数学 充分复习","links":[],"tags":[],"content":"集合论\n给定两集合 A、B 全集S 求各种东西\n交并补很显然 需要特别注意 补集也有叫余集的 A在C中的补集等于A在C中的余集\n差集 A - B 就是A有B没有的\n对称差 A \\triangle B 就是并集减去交集\n笛卡尔积 A \\times B 就是A中拿一个元素 B中拿一个元素 得到的集合应该形如 \\{(a_{1},b_{1}),(a_{2},b_{2})...(a_{n},b_{m})\\}\n幂集 2^{A} 就是空集开始 A本身结尾的那个超大集合\n证明两个集合相等\n就是证明AB两个集合互为对方的子集\n要证明两个集合 A 和 B 互为对方的子集（即 A⊆B 且 B⊆A ），从而证明 A=B ，可以按照以下步骤进行：\n1. 证明 A⊆B\n目标 ：证明集合 A 中的所有元素都属于集合 B 。\n方法 ：\n\n任取元素 ：设 x∈A 。\n逻辑推导 ：根据集合 A 的定义和已知条件，推导出 x∈B 。\n结论 ：由 x 的任意性，得出 A⊆B 。\n示例 ： 假设 A={x∈Z∣x 是偶数} ，B={x∈Z∣xmod2=0} 。\n证明 A⊆B ：\n设 x∈A ，则 x 是偶数，即存在整数 k 使得 x=2k 。\n因此 xmod2=0 ，故 x∈B 。\n结论：A⊆B 。\n\n2. 证明 B⊆A\n目标 ：证明集合 B 中的所有元素都属于集合 A 。\n方法 ：\n\n任取元素 ：设 x∈B 。\n逻辑推导 ：根据集合 B 的定义和已知条件，推导出 x∈A 。\n结论 ：由 x 的任意性，得出 B⊆A 。\n\n示例 （接上例）：\n证明 B⊆A ：\n\n设 x∈B ，则 xmod2=0 ，即 x 是偶数。\n因此 x∈A 。\n结论：B⊆A 。\n\n最后得到：\n\n若 A⊆B 且 B⊆A ，则 A=B 。\n\n用运算定律证明对称差满足结合律\n兄弟 这他妈是啥？搜了我都没看懂\n映射\n判断给定映射是否是单射 满射 双射 给出证明\n\\begin{align*}\n&amp;双射\\begin{cases}\n单射 \\ \\ \n\\forall x_{1}, x_{2} \\in 定义域,\\  x_{1} \\neq x_{2} \\implies f(x_{1}) \\neq f(x_{2})\n\\\\\n满射 \\ \\ \n\\forall y \\in 值域,\\  \\exists x \\in 定义域 \\ 使得 \\ f(x) = y\n\\end{cases}\\\\\n\\end{align*}\n我们通常可以把单射和单调性结合起来理解 单调性不变 那么就是单射\n至于满射 我们需要结合定义域和至于判断\n双射需要同时满足单射和满射的条件\n求f, g, h 的合成结果，求逆\n例如f \\circ g 我们可以理解成 f(g(x)) 这样一来先后关系就一目了然了\n映射 f 可求逆的前提条件是 f 是双射\n因此我们需要留一个心眼 求逆的时候重新看一遍所求映射是不是双射\n比如：f(x) = x + 15\\ \\  g(x) = 15x + 1 x,\\ y \\in R  让我们求逆\n逆通常表示成 f^{-1}(y)\\ \\  g^{-1}(y)\n对于 f 显然满足双射的条件 可以得到 f^{-1}(y) = y - 15\n对于 g 发现 y = 2 时, 不存在x \\in R 使得 f(x) = y 因此 g根本不存在逆\n二元关系\n给定集合A 关系R 判断对于A来说 R是否是等价关系 偏序关系\n我们有：\n\\begin{align*}\n&amp;等价关系\\begin{cases}\n自反性\\\\\\\\\n对称性\\\\\\\\\n传递性\n\\end{cases}\n\\end{align*}\n我们把x, y满足R关系 写作 xRy 因此有如下定义：\n自反性：\\forall x \\in A,\\ xRx\n对称性：若 \\, xRy,\\ 则有yRx\n传递性：若 \\ xRy,\\ yRz\\ ,\\ 则有 \\,xRz\n我们有：\n\\begin{align*}\n偏序关系（偏序集）\\begin{cases}\n自反性\\\\\\\\\n反对称性\\\\\n\\\\\n传递性\n\\end{cases}\n\\end{align*}\n反对称性：若 \\, xRy\\ 的同时有\\ yRx,\\ 则x=y\n自行证明即可\n如何求关系的复合运算 逆运算 闭包运算 用关系矩阵求 用关系矩阵的乘法运算求传递闭包\n不会捏\n图论\n无向图，邻接矩阵\n无向图就是没有方向的图\n邻接矩阵就是把图用矩阵表示出来 比如a b 中间有一条无向边 那么 v[a][b] = 1, v[b][a] = 1\n判断图是不是 欧拉图 哈密顿图\n欧拉回路：经过每条边恰好一次的闭合路径（起点 终点 相同）\n欧拉图：存在欧拉回路的图\n欧拉路径：经过每条边恰好一次 而且起点终点不相同的图\n哈密顿回路 ：一条经过图中每个顶点恰好一次 的闭合路径（起点 终点 相同）。\n哈密顿图 ：存在哈密顿回路的图。\n哈密顿路径 ：经过每个顶点一次 起点和终点不同的路径。\n如何判断？\n判断前提：如果图不是连通的 就什么图都不是了  连通性：任意两个顶点可以到达\n欧拉图：所有顶点的度数 deg(v) 都是偶数\n哈密顿图是一个NP完全问题，判断起来比欧拉图复杂得多，但我们仍有一些充分条件和必要条件可以辅助判断\n若顶点数 n &gt;= 3 ：\n\nDirac 定理：若每个顶点的度数 deg(v) &gt;= \\frac{n}{2} 则是哈密顿图\nOre 定理：若对任意两个不相邻的顶点 u, v 有 deg(u) + deg(v) &gt;= n 则是哈密顿图\n\n需要特别注意的是 即使一个图不满足这两个定理 它仍然有可能是哈密顿图 在这种情况下 我们不仿自己动笔画一画 看能不能在图中 构造出一个 经过所有点恰好一次 的 闭合回路\n欧拉图 哈密顿图 的应用\n一笔画问题，邮递员问题 属于欧拉图的应用\n旅行商问题，任务调度问题 属于哈密顿图的应用\n建议自己ai问一下题干 然后看能不能观察出这是xxx图的应用\n能观察出来 基本上就差不多了\n树\n树的六个基本性质\n无圈性（无环性）：树中不存在环\n连通性：任意两个顶点可以到达\n唯一路径性：任意两个顶点的路径唯一\n边数公式：（边数 = 顶点数 - 1）\n极小连通性：删除任意边导致不连通\n极大无圈性：增加任意边导致有环\n判断图是不是平面图\n没找到例题\n有向树\n用二元有序树表示算术表达式（前中后序）\n算术表达式的写法：\n符号在上 字母在下\n加减在上 乘除在下\n前中后序 说的是 根 的顺序 可以具体查询ai来理解\n近世代数\n判断给定代数系统是不是群\n一个代数系统包含一个集合A和一个关系* 通常写作（A,* )\n\\begin{align*}\n群\\begin{cases}\n半群\\begin{cases}\n封闭性\\\\\n\\\\\n结合律\n\\end{cases}\\\\\\\\\n\n幺半群 \\to 单位元\\\\\\\\\n\n\\to 逆元\n\\end{cases}\n\\end{align*}\n封闭性和结合律都是比较显然的 现在重点讲单位元和逆元。\n单位元：\\forall a \\in A, \\ e \\in A,\\ 使得\\ a* e=a成立 解出e e被称作单位元\n对于不同的a e应当是唯一的\n逆元：\\forall a \\in A, \\ \\exists a^{-1} \\in A,\\ 使得 a*a^{-1}=e\\ 成立 解出a^{-1} 对于不同的a a^{-1} 可以是不唯一的 但是如果有一个a不存在a^{-1} 那么这个代数系统就没有逆元 也就不是群\n格 / 布尔代数\n判断给定代数系统是否是偏序集，格，有界格，有补格，分配格，布尔代数\n偏序集：也就是偏序关系 满足自反 反对称 传递\n格：特殊的偏序集，对代数系统中任意两个元素都存在 最小上界（记作 a∨b ) 和 最大下界(记作 a∧b )\n有界格：特殊的格，存在 最大元素 (记作 1) 和 最小元素 (记作 0) ！！\n有补格：特殊的有界格，对代数系统中任意元素都存在补元 使得同时满足 1 和 0\n分配格：特殊的格，满足分配律 \\begin{align*}\na∧(b∨c)=(a∧b)∨(a∧c) \\\\\na∨(b∧c)=(a∨b)∧(a∨c)\n\\end{align*}\n布尔代数：有补的分配格\n概念很多 需要多看几遍\n数理逻辑\n对于给定问题，求结论 / 求结论的有效性\n相对板子的题，自行推导即可。步骤是：\n\n符号化\n推理\n\n求一个命题公式的主析取范式 / 主合取范式\n主析取范式：极小项的或 对应结果是 1 的行\n主合取范式：极大项的与 对应结果是 0 的行\n析取 指的是逻辑或\n合取 指的是逻辑与\n数电怎么做 这个就怎么做\n\n列真值表 000 001 010 写出来\n找到结果 是 1 / 0 的行\n按照要求 先与再或 / 先或再与\n\n谓词逻辑\n求一个谓词公式的命题表示的真值\n涉及部分 德摩根定律 类似的技巧 需要结合具体题目来理解\n通常就是把那个命题写清晰一点 判断是 1 还是 0 即可\n使用谓词公式表示任意命题（符号化）\n符号化有些地方比较恶心 需要结合往年真题逐题分析\n近世代数 考 群 布尔代数\n图论 基本概念 最小生成树 有向图 / 有向树\n数理逻辑 命题 谓词\n集合论 老三样 都是简单题"},"deep-learning/python":{"slug":"deep-learning/python","filePath":"deep learning/python.md","title":"python","links":[],"tags":[],"content":"os 模块的作用：\nos 是 Python 的标准库模块，用于与操作系统交互，核心功能包括：\n\n路径操作：\n\nos.path.join(path1, path2)：将路径拼接成系统兼容格式（自动处理 / 或 \\）。\n例如：os.path.join(&quot;data&quot;, &quot;train&quot;) → &quot;data/train&quot;（Linux）或 &quot;data\\\\train&quot;（Windows）。\n\n\n目录遍历：\n\nos.listdir(path)：列出指定路径下的所有文件和子目录名称（返回字符串列表）。\n\n\n文件/目录管理：\n\n创建、删除、重命名文件/目录（如 os.makedirs()、os.remove()）。\n\n\n环境信息：\n\n获取操作系统类型、环境变量等（如 os.name, os.getenv()）。\n\n\n\n\nImage 模块的作用（来自 PIL 库）：\nImage 是 Python Imaging Library (PIL) 的核心模块，现由 Pillow 维护，用于图像处理。核心功能包括：\n\n图像加载：\n\nImage.open(path)：从文件加载图像，返回一个 PIL.Image.Image 对象。\n\n\n图像操作：\n\n裁剪、旋转、缩放、滤波、颜色转换等（如 img.resize(), img.convert()）。\n\n\n图像保存：\n\n将图像保存为不同格式（如 img.save(&quot;output.jpg&quot;)）。\n\n\n图像数据访问：\n\n获取像素数据（如 img.getdata()）、图像尺寸（如 img.size）等。\n\n\n\n\nimg 的数据类型：\nimg = Image.open(img_item_path)\n\n类型：PIL.Image.Image 对象。\n本质：这是一个封装了图像像素数据的类实例，包含以下关键属性：\n\nimg.mode：图像模式（如 &#039;RGB&#039;, &#039;L&#039; 表示灰度图）。\nimg.size：图像尺寸（如 (width, height)）。\nimg.format：图像格式（如 &#039;JPEG&#039;, &#039;PNG&#039;）。\n\n\n内存中的数据：图像像素值以二进制形式存储在对象内部，需通过 np.array(img) 或 torchvision.transforms.ToTensor() 转换为数值数组（如 NumPy 数组或 PyTorch 张量）才能用于深度学习模型。\n\n\n代码流程解析：\ndef __getitem__(self, idx):\n    img_name: str = self.img_path[idx]            # 获取第 idx 个文件名（str）\n    img_item_path: str = os.path.join(self.path, img_name)  # 拼接完整路径（str）\n    img = Image.open(img_item_path)              # 加载图像，得到 PIL.Image.Image 对象\n\nimg_name：str 类型，表示单个图像文件名（如 &quot;cat.jpg&quot;）。\nimg_item_path：str 类型，表示图像文件的完整路径（如 &quot;./data/train/cat.jpg&quot;）。\nimg：PIL.Image.Image 类型，表示加载后的图像对象。\n\n\n后续处理建议（深度学习场景）：\nPIL.Image.Image 对象不能直接输入神经网络，需进一步转换：\n\n转换为 NumPy 数组：\nimport numpy as np\nimg_array = np.array(img)  # 形状为 (height, width, channels)，值范围 [0, 255]\n\n转换为 PyTorch 张量：\nfrom torchvision import transforms\ntransform = transforms.ToTensor()\nimg_tensor = transform(img)  # 形状为 (channels, height, width)，值范围 [0.0, 1.0]\n\n标准化（常见预处理）：\nnormalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\nimg_normalized = normalize(img_tensor)  # 标准化后的张量\n\n\n\n总结：\n\nos 模块：处理文件系统路径和目录遍历，确保代码跨平台兼容。\nImage 模块：加载和处理图像，返回 PIL.Image.Image 对象。\nimg 的类型：PIL.Image.Image，需进一步转换为数值数组或张量才能用于深度学习模型。\n"},"deep-learning/神经网络与深度学习笔记":{"slug":"deep-learning/神经网络与深度学习笔记","filePath":"deep learning/神经网络与深度学习笔记.md","title":"神经网络与深度学习笔记","links":[],"tags":[],"content":"神经网络\n如同大脑需要神经元配合一样，深度学习也需要相应的网络。一个典型的神经网络包含一层层的节点，每一层节点的输入都是前一层或多层的输出（有点像动态规划）。现在的神经网络可以达到几十层甚至上千层，我们称之为深度神经网络。\n认识这个世界\n人之所以能够区分生活中常见的事物，是因为我们感知的信号传递给了大脑；大脑将复杂的信号处理分类，最后得到正确的结果。\n计算机也是如此。在学习过程中，它将大量的不同物体之间的异同点变成神经网络的参数。当你给计算机一张动物图片时，它就能通过对图片的分析，告诉你它是不是小猫。\n深度学习就这样通过构建多层的人工神经网络来模拟人类大脑的信息处理和学习机制，从海量的数据中学习到丰富的规律和知识，从而实现对大量数据的高效处理和分析，解决复杂任务。\n如今，我们可以使用现有的工具快速构建这样的人工神经网络：\n\n\nPython: 一种编程语言，以其简洁、强大、易于学习而著称。\n\n\nPyTorch: 专为Python设计的用于构建和训练深度神经网络的工具包。作为一款流行的深度学习框架，PyTorch以其简洁灵活的特性，让我们能够轻松构建、训练和部署深度学习模型。\n\n\n计算机如何识别你书写的数字？\n让我们看看PyTorch的解题思路。解决这个问题总共需要5步：准备数据、定义模型、训练模型、评估模型、做出预测。\n1. 准备数据\n当我们学习时遇到一道做不出来的题该怎么办？我们会去求助老师，会和同学讨论，或者是寻找学习资料的帮助。当计算机遇到复杂问题时也是这样，不过它用的学习资料都是特定的数据。深度学习框架PyTorch提供了日常练习所需的基础数据集，我们可以从PyTorch里导入手写数字分类数据集，并使用Python来进行可视化展示。\n就算有这样的数据，计算机又是怎么看出我写的数字的呢？其实很简单，我们看到的图和计算机看到的图是不一样的。计算机将图片进行分割，根据图片的颜色信息将其转化成各种通道的数据信息并保存下来，这样计算机就能很好地记住这张图了。\n2. 定义模型\n在正式开始前，我们需要几个概念：卷积层、池化层、全连接层。\n\n\n卷积层: 是计算机认识一张图片最基础的步骤，它将一张图像变成一系列0∼1之间的数据矩阵。\n\n\n池化层: 可以理解为把原来很大的图像矩阵压缩变成一张更小、更容易计算的图像矩阵。\n\n\n全连接层: 计算机还要把这张更小的图像展开成一段数据（过程大概有点类似中序遍历算术表达式？）。这个过程被称为全连接层。\n\n\n而这段处理完的数据就是这张图片的“身份证”了。计算机就用这样的方式认识了这张照片，神经网络的模型也是这样产生的。\n下面是一个这些概念的简要总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念功能作用卷积层提取图像特征，将图像转化为数据矩阵。识别图像中的边缘、纹理等基本特征。池化层压缩图像矩阵，减少数据量和计算复杂度。保留重要特征，同时减少过拟合的风险。全连接层将处理后的图像数据展开成一维向量，进行高级特征组合和分类。整合所有特征，最终输出分类结果或预测值。\n3. 训练模型\n在定义好模型之后就可以开始训练模型了。训练模型的过程实际上就是将训练数据输入模型，计算损失并调整更新模型参数，这样重复进行多个周期，直到模型很好地学到了训练数据里的特征。\n简单来说，训练模型就是我们把大量的已经标定的手写数字图片作为数据告诉计算机，在不断学习复习的过程中，计算机的考试成绩越来越好的过程。\n在这个过程中，我们需要定义损失函数和优化器：\n\n\n损失函数: 用于衡量模型预测的准确性。\n\n\n优化器: 用于调整模型的参数。\n\n\n在这个例子中，我们使用交叉熵损失作为损失函数；使用随机梯度下降作为优化器。\n下面是关于损失函数和优化器的总结：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n概念作用示例（手写数字识别）损失函数衡量模型预测结果与真实值之间的差异。交叉熵损失优化器根据损失函数的结果，调整模型参数以最小化损失。随机梯度下降（SGD）\n4. 评估模型 / 预测\n最后我们当然要给计算机检查一下卷子，看看它学得怎么样了。我们随便写下计算机没见过的某个数字，让它用训练好的模型判断一下，看看是不是和我们写下的数字一致。\nPyTorch五步解题法回顾\nPyTorch的解题思路可以概括为以下五步：\n\n\n准备数据\n\n\n定义模型\n\n\n训练模型\n\n\n评估模型\n\n\n做出预测\n\n\n神经网络架构基础\n以一个典型的神经网络为例，其基本构成包括：\n\n\n输入层（Inputs）：接收原始数据。\n\n\n权重（Weights）：每个输入数据与不同的权重相乘。\n\n\n偏差（Bias）：与加权后的输入数据相加。\n\n\n激活函数（Activation Function）：对加权和与偏差的结果进行非线性变换，得到输出。\n\n\n输出层（Output）：将结果传递给下一层神经网络，直至损失函数收敛到最小，得到最终结果。\n\n\n卷积神经网络（CNN）简介与LeNet-5示例\n卷积神经网络是专门为图像输入设计的网络。以经典的LeNet-5为例，它于20世纪90年代推出，是早期成功的CNN架构之一，专为手写数字识别设计，奠定了后续CNN发展的基础。\nLeNet-5包含以下核心要素：\n\n\n卷积层（Convolutional Layer）：用于提取图像特征，生成特征图。\n\n\n池化层（Pooling Layer）：对特征图进行降维，提取最突出的元素。\n\n\n全连接层（Fully Connected Layer）：在特征提取后进行分类预测。\n\n\nLeNet-5图像处理过程示例：\n\n\n原始输入：一张32x32像素的手写数字图像。\n\n\n第一卷积层处理：图像转换为6个28x28像素的特征图。\n\n\n第一池化层作用：特征图降维至6个14x14像素的图像。\n\n\n第二卷积层处理：数据进一步变为16个10x10像素的特征图。\n\n\n第二池化层作用：特征图尺寸减小为16个5x5像素的图像。\n\n\n全连接层处理：网络最终输出一个10维向量，每一维代表一个数字类别的预测概率。 通过这一系列层层深入的处理，LeNet-5能够有效地识别和分类手写数字图像，随着数据量的减少，特征的精确度逐渐增高。\n\n\nPyTorch实操：数据准备\n实操的第一步是准备数据，这包括数据下载、数据格式转换和数据集划分。\n1. 数据下载：MNIST数据集\n手写数字分类是流行的图像分类任务。MNIST数据集包含了6万个用于训练的手写数字样本和1万个用于测试的样本。每个样本都是一个28x28像素的灰度图像，表示0-9的单一数字。该数据集经过预处理，数字位于图像中心，便于研究人员专注于模型构建。\nPyTorch通过torchvision API提供了直接下载和加载MNIST数据集的便捷功能。\n2. 数据格式转换：PIL图像到PyTorch Tensor\n图像数据通常以PIL图像格式（像素数组）存在。为了让计算机程序更容易理解和处理，我们需要将其转换为PyTorch Tensor格式。ToTensor工具可以完成这项工作，它不仅转换格式，还会将每个像素的亮度值（0-255整数）归一化到0-1之间的浮点数。其中，0表示黑色，1表示白色，0到1之间的值表示不同程度的灰色。\n3. 数据集划分：使用Batch和DataLoader\n为了解决每次遍历整个数据集可能导致的效率低下和内存不足问题，深度学习中通常将数据划分为更小的“批次”（batch）。一个batch可以理解为总数据集中的一小部分子数据集。\n这种做法的优势在于：\n\n\n效率提升：模型可以更快地进行小幅度的调整，而不是等待长时间进行一次大的调整。\n\n\n内存优化：避免一次性加载所有数据导致的内存溢出。\n\n\nPyTorch提供了DataLoader工具，可以方便地实现数据集的批次划分和加载功能。通过枚举方式不断进行训练，实现高效的模型优化。\n可视化训练数据示例\n我们使用的数据集是一个形状为Height x Width的二维矩阵（Height和Width都是28）。这个二维矩阵的每个元素都是一个介于0到1之间的浮点数，表示像素值的归一化强度。通过Python循环，可以随机抽样并展示训练集中的25个数据可视化图案。"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"Welcome to my GitHub page!\nhere u will find many of my crazy ideas and rubbish-like thoughts. You might find some gems, you might find some… well, let’s just call them ‘experimental features’ that never quite made it past the concept stage. But hey, it’s all part of the learning (and coding) journey!\nSo, pull up a chair, grab a coffee, and explore at your own risk! Who knows, you might even find something that sparks your own next big (or wonderfully weird) idea.\nAnyway, it’s late, my brain’s officially fried from all the ‘idea-generating,’ and now I just gotta catch some Z’s. Hope you found something interesting here – or at least had a chuckle!"},"关于":{"slug":"关于","filePath":"关于.md","title":"关于","links":[],"tags":[],"content":"一个学生，现阶段最喜欢做的事是躺着。"},"找gemini问出来的Java速成方案":{"slug":"找gemini问出来的Java速成方案","filePath":"找gemini问出来的Java速成方案.md","title":"找gemini问出来的Java速成方案","links":[],"tags":[],"content":"Java速成指南：从C++到Java\n您好！很高兴能帮助您快速掌握Java。由于您有C++基础，我们将重点对比两者异同，让您更快上手。Java和C++都属于面向对象语言，因此许多概念是相通的。\n1. 基础语法对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性C++Java备注主函数int main() { ... }public static void main(String[] args) { ... }public (公开), static (静态，无需创建对象即可调用), void (无返回值), String[] args (命令行参数)输出std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;System.out.println(&quot;Hello&quot;);System.out 是标准输出流，println 自动换行，print 不换行。输入std::cin &gt;&gt; var;Scanner scanner = new Scanner(System.in); int var = scanner.nextInt();Java需要导入 java.util.Scanner 类来处理输入。注释// 单行注释 /* 多行注释 */// 单行注释 /* 多行注释 */ /** 文档注释 */Java有专门的文档注释，可用于生成API文档。头文件/包#include &lt;iostream&gt;import java.util.Scanner;Java使用 package 和 import 来组织和引用类。\n示例：Hello World\nC++:\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; &quot;Hello, C++!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n\nJava:\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(&quot;Hello, Java!&quot;);\n    }\n}\n2. 数据类型\nJava的数据类型与C++类似，但有一些关键区别：\n\n\n基本数据类型 (Primitive Types):\n\n\n整数: byte (1字节), short (2字节), int (4字节), long (8字节)。Java没有无符号类型 (unsigned)。\n\n\n浮点数: float (4字节), double (8字节)。\n\n\n字符: char (2字节，Unicode字符，C++中通常是1字节ASCII)。\n\n\n布尔: boolean (1位，只能是 true 或 false，不能转换为整数，C++中 bool 可以是 0 或 1)。\n\n\n\n\n引用数据类型 (Reference Types): 类(Class)、接口(Interface)、数组(Array)等。\n\n\n类型转换：\n\n\n隐式转换 (Implicit Conversion): 小范围类型自动转换为大范围类型（例如 int 到 long）。\n\n\n显式转换 (Explicit Conversion/Casting): 大范围类型转换为小范围类型需要强制转换（例如 (int) myLong），可能丢失精度。\n\n\n3. 变量与常量\n\n\n变量声明: 数据类型 变量名 = 初始值; (与C++相同)\nint age = 30;\nString name = &quot;Alice&quot;;\n\n\n\n常量: 使用 final 关键字定义常量 (C++中使用 const)。\nfinal double PI = 3.14159;\n\n\n\n4. 运算符与控制流\n\n\n运算符: 算术、关系、逻辑、位、赋值运算符与C++基本相同。\n\n\n控制流语句: if-else, for, while, do-while, switch 语句的语法和用法与C++几乎完全一致。\n\n\nswitch 语句: Java 7及以上版本支持 String 类型作为 switch 的表达式。\n\n\n增强型 for 循环 (Enhanced For Loop): 类似于C++11的基于范围的for循环。\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) { // 遍历数组或集合\n    System.out.println(num);\n}\n\n\n\n\n\n5. 数组\n\n\n声明与初始化:\n// 声明并分配内存，元素默认初始化为0/null/false\nint[] numbers = new int[5];\n// 声明并初始化\nString[] names = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;};\n\n\n\n访问元素: arrayName[index] (与C++相同)。\n\n\n数组长度: arrayName.length (C++中是 sizeof(array)/sizeof(array[0]) 或 std::vector::size())。\n\n\n6. 字符串\nJava中的字符串是 String 类的对象，与C++中的 std::string 类似，但有重要区别：\n\n\n不可变性 (Immutability): Java中的 String 对象一旦创建就不能被修改。所有修改字符串的操作（如连接、替换）都会创建新的 String 对象。\nString s1 = &quot;Hello&quot;;\nString s2 = s1 + &quot; World&quot;; // s1不变，s2是新字符串\n\n\n\n常用方法: length(), charAt(), substring(), indexOf(), equals(), equalsIgnoreCase(), startsWith(), endsWith(), replace(), trim() 等。\n\n\n7. 面向对象编程 (OOP)\nJava是纯粹的面向对象语言，所有代码都必须写在类中。\n\n\n类与对象:\n\n\n定义类:\npublic class Car {\n    String brand; // 成员变量\n    int year;\n\n    // 构造函数 (与C++类似，没有返回值，名称与类名相同)\n    public Car(String brand, int year) {\n        this.brand = brand; // this 指向当前对象\n        this.year = year;\n    }\n\n    // 方法 (成员函数)\n    public void drive() {\n        System.out.println(brand + &quot; is driving.&quot;);\n    }\n}\n\n\n\n创建对象: 使用 new 关键字 (C++中也可以使用 new，但Java没有 delete)。\nCar myCar = new Car(&quot;Toyota&quot;, 2023); // 调用构造函数创建对象\nmyCar.drive(); // 调用方法\n\n\n\n\n\n封装 (Encapsulation):\n\n\n访问修饰符: public, private, protected, (default/package-private)。\n\n\npublic: 任何地方都可访问。\n\n\nprivate: 只能在当前类内部访问。\n\n\nprotected: 同包内及不同包的子类可访问。\n\n\ndefault (无修饰符): 只能在同包内访问。\n\n\n\n\nGetter/Setter 方法: 通常用于访问和修改 private 成员变量。\npublic class Person {\n    private String name;\n\n    public String getName() { // Getter\n        return name;\n    }\n\n    public void setName(String name) { // Setter\n        this.name = name;\n    }\n}\n\n\n\n\n\n继承 (Inheritance):\n\n\n使用 extends 关键字。Java只支持单继承（一个类只能继承一个父类）。\n\n\nsuper 关键字：用于调用父类的构造函数或方法。\n\n\n方法重写 (Method Overriding): 子类提供父类已有的方法的不同实现。\n\n\n@Override 注解：推荐使用，用于标记方法是重写的，编译器会检查。\n\n\n\n\nclass Vehicle {\n    public void move() {\n        System.out.println(&quot;Vehicle moves.&quot;);\n    }\n}\n\nclass Bicycle extends Vehicle { // Bicycle 继承 Vehicle\n    @Override\n    public void move() { // 重写父类方法\n        System.out.println(&quot;Bicycle pedals.&quot;);\n    }\n}\n\n\n\n多态 (Polymorphism):\n\n\n方法重载 (Method Overloading): 同一个类中，方法名相同但参数列表不同（数量、类型、顺序）。\n\n\n动态绑定 (Dynamic Binding): 父类引用指向子类对象，调用方法时实际执行子类重写的方法。\n\n\nVehicle v1 = new Vehicle();\nVehicle v2 = new Bicycle(); // 多态：父类引用指向子类对象\nv1.move(); // 输出 &quot;Vehicle moves.&quot;\nv2.move(); // 输出 &quot;Bicycle pedals.&quot;\n\n\n\n抽象类 (Abstract Classes) 与 接口 (Interfaces):\n\n\n抽象类:\n\n\n使用 abstract 关键字。\n\n\n可以有抽象方法（只有声明，没有实现）和具体方法。\n\n\n不能直接实例化，必须被子类继承并实现所有抽象方法。\n\n\n类似于C++的纯虚函数类，但可以有非纯虚函数。\n\n\n\n\n接口:\n\n\n使用 interface 关键字。\n\n\nJava 8之前，接口中所有方法都是 public abstract 的，所有变量都是 public static final 的。\n\n\nJava 8及以后，接口可以有 default 方法和 static 方法。\n\n\n一个类可以实现多个接口 (implements 关键字)，实现了C++多重继承的部分功能。\n\n\n\n\n// 抽象类\nabstract class Shape {\n    public abstract double getArea(); // 抽象方法\n    public void display() {\n        System.out.println(&quot;This is a shape.&quot;);\n    }\n}\n\nclass Circle extends Shape {\n    double radius;\n    public Circle(double r) { this.radius = r; }\n    @Override\n    public double getArea() { return Math.PI * radius * radius; }\n}\n\n// 接口\ninterface Flyable {\n    void fly(); // 默认 public abstract\n    default void landing() { // Java 8 default 方法\n        System.out.println(&quot;Landing.&quot;);\n    }\n}\n\nclass Bird implements Flyable { // 实现接口\n    @Override\n    public void fly() {\n        System.out.println(&quot;Bird is flying.&quot;);\n    }\n}\n\n\n\n8. Java特有概念\n\n\nJVM (Java Virtual Machine) 和字节码 (Bytecode):\n\n\nJava源代码 (.java 文件) 编译成字节码 (.class 文件)，而不是机器码。\n\n\n字节码可以在任何安装了JVM的平台上运行，实现“一次编写，到处运行” (Write Once, Run Anywhere)。\n\n\nC++代码直接编译成特定平台的机器码。\n\n\n\n\n垃圾回收 (Garbage Collection):\n\n\nJava自动管理内存，当对象不再被引用时，垃圾回收器会自动回收其占用的内存。\n\n\n没有 delete 关键字，您无需手动释放内存，大大减少了内存泄漏的风险。\n\n\nC++需要手动管理内存 (new 和 delete)。\n\n\n\n\n包 (Packages) 和导入 (Imports):\n\n\npackage 用于组织相关的类和接口，避免命名冲突。\n\n\nimport 用于引入其他包中的类。\n\n\npackage com.example.myapp; // 定义包\n\nimport java.util.ArrayList; // 导入 ArrayList 类\n// import java.util.*; // 导入 java.util 包下的所有类\n\n\n\n异常处理 (Exception Handling):\n\n\n使用 try-catch-finally 块来处理运行时错误。\n\n\n受检异常 (Checked Exceptions): 必须在方法签名中使用 throws 声明或在 try-catch 块中处理。\n\n\n非受检异常 (Unchecked Exceptions/Runtime Exceptions): 不需要强制处理（例如 NullPointerException, ArrayIndexOutOfBoundsException）。\n\n\ntry {\n    // 可能抛出异常的代码\n    int result = 10 / 0;\n} catch (ArithmeticException e) { // 捕获特定异常\n    System.out.println(&quot;发生算术异常: &quot; + e.getMessage());\n} catch (Exception e) { // 捕获所有其他异常\n    System.out.println(&quot;发生未知异常: &quot; + e.getMessage());\n} finally {\n    System.out.println(&quot;无论是否发生异常，都会执行。&quot;);\n}\n\n// 声明可能抛出异常的方法\npublic void readFile(String filePath) throws IOException {\n    // ... 文件读取操作\n}\n\n\n\n集合框架 (Collections Framework):\n\n\n提供了一套统一的接口和类来处理数据集合，比C++的STL更易用。\n\n\n核心接口: List (有序可重复), Set (无序不重复), Map (键值对)。\n\n\n常用实现类: ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap 等。\n\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nList&lt;String&gt; names = new ArrayList&lt;&gt;(); // 列表\nnames.add(&quot;Alice&quot;);\nnames.add(&quot;Bob&quot;);\n\nMap&lt;String, Integer&gt; ages = new HashMap&lt;&gt;(); // 映射\nages.put(&quot;Alice&quot;, 30);\nages.put(&quot;Bob&quot;, 25);\n\n\n\n泛型 (Generics):\n\n\n在编译时提供类型安全，消除强制类型转换。\n\n\n类似于C++的模板，但实现方式不同 (Java泛型是类型擦除)。\n\n\n// 泛型列表\nList&lt;String&gt; stringList = new ArrayList&lt;&gt;();\nstringList.add(&quot;Hello&quot;);\n// stringList.add(123); // 编译错误，类型安全\nString s = stringList.get(0); // 无需强制转换\n\n\n\n总结与下一步\n通过这个速成指南，您应该对Java的基本概念和与C++的区别有了清晰的认识。您的C++面向对象基础将是学习Java的巨大优势。\n下一步建议：\n\n\n实践编码: 尝试编写一些简单的Java程序，例如：\n\n\n实现一个简单的计算器。\n\n\n创建一个员工管理系统（包含类、继承、封装）。\n\n\n使用集合框架存储和操作数据。\n\n\n\n\n深入学习:\n\n\nIO流: 文件读写、网络通信等。\n\n\n多线程: Java在并发编程方面有强大的支持。\n\n\n反射: 运行时检查和修改类、方法、字段的能力。\n\n\nLambda表达式和Stream API (Java 8+): 简化函数式编程。\n\n\n常用库/框架: 例如 Spring Boot (Web开发), Hibernate (ORM) 等。\n\n\n\n\n阅读官方文档: Oracle Java文档是最好的学习资源。\n\n\n祝您学习顺利！如果您在学习过程中遇到任何具体问题，请随时提问。"},"找gemini问出来的stl替代方案":{"slug":"找gemini问出来的stl替代方案","filePath":"找gemini问出来的stl替代方案.md","title":"找gemini问出来的stl替代方案","links":[],"tags":[],"content":"Java中C++ STL的替代方案（进阶）\n作为一名C++ ACMer，您对STL（标准模板库）的强大和便利性一定深有体会。在Java中，虽然没有一个直接名为“STL”的库，但其“Java集合框架”（Java Collections Framework, JCF）以及其他核心库提供了与STL高度相似甚至更强大的功能。本节将更深入地探讨这些对应关系，并提供更多针对C++背景的细节。\n1. 数据结构 (Containers)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC++ STL容器Java对应类/接口描述std::vectorjava.util.ArrayList动态数组，底层是数组实现。提供O(1)的随机访问，插入/删除尾部O(1)均摊，中间插入/删除O(N)。与C++ vector类似，当容量不足时会自动扩容，这可能导致一次性较大的开销。std::listjava.util.LinkedList双向链表。提供O(1)的插入/删除，但随机访问O(N)。在需要频繁在列表两端或中间插入删除时很有用。与C++ list不同，Java的LinkedList也实现了List接口，因此可以像ArrayList一样使用索引访问（虽然效率低）。std::dequejava.util.ArrayDeque双端队列，底层是循环数组。支持两端O(1)的插入和删除。也可以作为栈或队列使用。在竞技编程中，ArrayDeque是实现队列和栈的首选，因为它比LinkedList作为队列/栈时性能更好。std::setjava.util.TreeSet基于红黑树实现的有序集合。元素唯一且自动排序。插入、删除、查找都是O(logN)。元素必须实现Comparable接口或在构造TreeSet时提供Comparator。std::unordered_setjava.util.HashSet基于哈希表实现的无序集合。元素唯一，不保证顺序。平均O(1)的插入、删除、查找，最坏O(N)。元素需要正确实现hashCode()和equals()方法，否则可能导致错误的行为。std::mapjava.util.TreeMap基于红黑树实现的有序键值对映射。键唯一且自动排序。插入、删除、查找都是O(logN)。键必须实现Comparable接口或在构造TreeMap时提供Comparator。std::unordered_mapjava.util.HashMap基于哈希表实现的无序键值对映射。键唯一，不保证顺序。平均O(1)的插入、删除、查找，最坏O(N)。键需要正确实现hashCode()和equals()方法。std::queuejava.util.LinkedList 或 java.util.ArrayDequeJava中没有专门的Queue类，但LinkedList和ArrayDeque都实现了Queue接口，并提供了队列操作（offer, poll, peek）。ArrayDeque通常是更好的选择，因为它在作为队列使用时性能更优。std::priority_queuejava.util.PriorityQueue优先队列，底层是堆实现。默认是小顶堆（最小元素优先），可以通过传入自定义比较器实现大顶堆。插入和删除都是O(logN)。默认是小顶堆，若要实现大顶堆，需传入Collections.reverseOrder()或自定义Comparator。std::stackjava.util.Stack 或 java.util.ArrayDequejava.util.Stack是遗留类，不推荐使用。推荐使用ArrayDeque作为栈（push, pop, peek），因为它性能更好且更符合现代Java设计。std::pairjava.util.AbstractMap.SimpleEntry 或自定义类Java没有直接的pair类型。通常使用AbstractMap.SimpleEntry（或HashMap.Entry）来表示键值对，或者为了更清晰的语义，自定义一个包含两个字段的简单类。在竞技编程中，为了方便，通常会直接创建一个简单的Pair类。\nstd::pair 的Java实现示例：\n// 自定义Pair类\nclass Pair&lt;K, V&gt; {\n    public K key;\n    public V value;\n\n    public Pair(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    // 通常还会重写equals和hashCode方法，以便在集合中使用\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Pair&lt;?, ?&gt; pair = (Pair&lt;?, ?&gt;) o;\n        return Objects.equals(key, pair.key) &amp;&amp;\n               Objects.equals(value, pair.value);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(key, value);\n    }\n\n    @Override\n    public String toString() {\n        return &quot;(&quot; + key + &quot;, &quot; + value + &quot;)&quot;;\n    }\n}\n\n// 使用示例\nPair&lt;String, Integer&gt; p = new Pair&lt;&gt;(&quot;apple&quot;, 10);\nSystem.out.println(p.key + &quot;: &quot; + p.value); // apple: 10\n\n重要概念：\n\n\n接口与实现分离： Java集合框架大量使用接口（如List, Set, Map, Queue）来定义行为，然后由具体的类（如ArrayList, HashSet, HashMap）来实现这些接口。这提供了更大的灵活性。这意味着你可以用接口类型声明变量，而用具体实现类来创建对象，例如 List&lt;String&gt; myList = new ArrayList&lt;&gt;(); 这种多态性在C++中通过基类指针/引用实现。\n\n\n泛型（Generics）： Java的泛型 &lt;E&gt; 或 &lt;K, V&gt; 提供了编译时类型安全，类似于C++的模板。例如，ArrayList&lt;String&gt;表示一个只存储字符串的列表。\n\n\n2. 算法 (Algorithms)\nC++ STL的算法通常是独立函数，接受迭代器范围作为参数。在Java中，算法通常作为静态方法存在于工具类中，或者作为集合类自身的方法。\n\n\n排序：\n\n\nC++: std::sort(vec.begin(), vec.end());\n\n\nJava:\n\n\nCollections.sort(list); (用于List，默认升序)\n\n\nArrays.sort(array); (用于数组，默认升序)\n\n\n自定义排序：通过传入Comparator接口的实现。\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ArrayList;\n\n// 对List进行降序排序\nList&lt;String&gt; names = new ArrayList&lt;&gt;(List.of(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;));\nCollections.sort(names, (a, b) -&gt; b.compareTo(a)); // Lambda表达式\nSystem.out.println(names); // [Charlie, Bob, Alice]\n\n// 或者使用方法引用\nCollections.sort(names, Comparator.reverseOrder());\nSystem.out.println(names); // [Alice, Bob, Charlie] (又变回升序，因为reverseOrder是对自然顺序的逆序)\n\n// 对自定义对象列表排序\nclass Student {\n    String name;\n    int score;\n    public Student(String name, int score) { this.name = name; this.score = score; }\n    public int getScore() { return score; }\n    @Override public String toString() { return name + &quot;:&quot; + score; }\n}\nList&lt;Student&gt; students = new ArrayList&lt;&gt;();\nstudents.add(new Student(&quot;Alice&quot;, 90));\nstudents.add(new Student(&quot;Bob&quot;, 85));\nstudents.add(new Student(&quot;Charlie&quot;, 92));\n\n// 按分数升序排序\nCollections.sort(students, Comparator.comparingInt(Student::getScore));\nSystem.out.println(students); // [Bob:85, Alice:90, Charlie:92]\n\n// 按分数降序排序\nCollections.sort(students, Comparator.comparingInt(Student::getScore).reversed());\nSystem.out.println(students); // [Charlie:92, Alice:90, Bob:85]\n\n\n\n\n\n\n\n查找：\n\n\nC++: std::find(vec.begin(), vec.end(), value);\n\n\nJava: 集合类通常有contains()方法。对于更复杂的查找，需要手动遍历或使用Java 8的Stream API。\n\n\nlist.contains(value);\n\n\nmap.containsKey(key);\n\n\nmap.containsValue(value);\n\n\n\n\n二分查找：\n\n\nC++: std::lower_bound, std::upper_bound, std::binary_search\n\n\nJava: Collections.binarySearch(list, key); 或 Arrays.binarySearch(array, key);。注意：Java的binarySearch返回的是索引，如果找不到，返回 (-(insertion point) - 1)。它没有直接的lower_bound和upper_bound功能，需要自行实现或结合binarySearch的结果进行判断。\n\n\n\n\n\n\n最大/最小值：\n\n\nC++: *std::max_element(vec.begin(), vec.end());\n\n\nJava:\n\n\nCollections.max(collection);\n\n\nCollections.min(collection);\n\n\n对于自定义对象，需要传入Comparator。\n\n\n\n\n\n\n遍历：\n\n\nC++: 基于范围的for循环 for (int x : vec) 或迭代器 for (auto it = vec.begin(); it != vec.end(); ++it)\n\n\nJava:\n\n\n增强型for循环 (foreach): for (Type element : collection)\n\n\n迭代器: Iterator&lt;Type&gt; it = collection.iterator(); while (it.hasNext()) { Type element = it.next(); }\n\n\nJava 8 Stream API: 提供了更函数式的操作，如forEach, map, filter, reduce等。\nList&lt;String&gt; words = new ArrayList&lt;&gt;(List.of(&quot;apple&quot;, &quot;banana&quot;, &quot;cat&quot;, &quot;dog&quot;));\nwords.stream()\n    .filter(s -&gt; s.length() &gt; 3) // 过滤长度大于3的字符串\n    .map(String::toUpperCase)   // 转换为大写\n    .forEach(System.out::println); // 打印每个结果\n// 输出:\n// APPLE\n// BANANA\n// CHARLIE (如果之前有Charlie)\n\n\n\n\n\n\n\n3. 迭代器 (Iterators)\nC++ STL的迭代器是泛型指针，指向容器中的元素，支持指针算术（如it + 5）。Java的迭代器是对象，并且行为更受限制。\n\n\njava.util.Iterator&lt;E&gt;： 用于顺序遍历集合。\n\n\nhasNext(): 检查是否还有下一个元素。\n\n\nnext(): 返回下一个元素并前进迭代器。\n\n\nremove(): 从底层集合中移除迭代器最后返回的元素（可选操作）。注意：在遍历过程中使用集合的add()或remove()方法（而不是迭代器自身的remove()）会导致ConcurrentModificationException。\n\n\n\n\njava.util.ListIterator&lt;E&gt;： 仅用于List接口的实现（如ArrayList, LinkedList），提供了双向遍历和在遍历过程中修改列表的能力。\n\n除了hasNext(), next(), remove()，还提供hasPrevious(), previous(), add(), set(), nextIndex(), previousIndex()等方法。\n\n\n\n与C++迭代器的主要区别：\n\n\n无指针算术： Java迭代器不支持it + N或it - N这样的操作。要跳过多个元素，需要多次调用next()。\n\n\n类型安全： Java迭代器是泛型的，提供了编译时类型检查。\n\n\n修改限制： 在遍历过程中修改集合（除了通过迭代器自身的remove()或add()方法）会导致运行时错误。\n\n\n4. 泛型 (Generics)\nC++的模板在编译时生成特定类型的代码。Java的泛型在编译时进行类型检查，并在运行时擦除类型信息（Type Erasure），这意味着运行时所有泛型类型都被替换为其边界类型（通常是Object）。\n\n\n优势： 提供了编译时类型安全，避免了强制类型转换和运行时ClassCastException。\n\n\n限制（类型擦除的影响）：\n\n\n不能直接创建泛型数组： 例如，new T[size] 是不允许的。你需要创建Object[]然后进行强制类型转换，这通常会产生一个警告。\n// 错误：不能直接创建泛型数组\n// T[] array = new T[capacity];\n\n// 正确但有警告：\n// T[] array = (T[]) new Object[capacity];\n\n\n\n不能在运行时获取泛型类型信息： 例如，list instanceof ArrayList&lt;String&gt; 是不允许的，因为运行时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;都被擦除为ArrayList。\n\n\n不能使用基本类型作为泛型参数： 例如，ArrayList&lt;int&gt; 是不允许的。你必须使用对应的包装类，如 ArrayList&lt;Integer&gt;。\n\n\n\n\n5. 输入/输出 (Input/Output)\n在ACM/ICPC等竞技编程中，高效的I/O至关重要。\n\n\n标准输入：\n\n\nC++: cin &gt;&gt; var;\n\n\nJava: java.util.Scanner 是最常用的，但对于大量数据，BufferedReader 更快。\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Scanner;\n\n// 使用Scanner (方便，但可能较慢)\nScanner sc = new Scanner(System.in);\nint n = sc.nextInt();\nString s = sc.next();\ndouble d = sc.nextDouble();\nsc.nextLine(); // 消费掉nextInt/next等操作后留下的换行符，避免影响后续readLine()\n\n// 使用BufferedReader (更推荐用于竞技编程，速度快)\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\ntry {\n    String line = br.readLine(); // 读取一行\n    String[] parts = line.split(&quot; &quot;); // 分割字符串\n    int num = Integer.parseInt(parts[0]); // 转换为整数\n\n    // 读取整数数组\n    int[] arr = new int[n];\n    String[] numStrs = br.readLine().split(&quot; &quot;);\n    for (int i = 0; i &lt; n; i++) {\n        arr[i] = Integer.parseInt(numStrs[i]);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n\n\n\n\n标准输出：\n\n\nC++: cout &lt;&lt; var &lt;&lt; endl;\n\n\nJava: System.out.print(), System.out.println(), System.out.printf()。对于大量输出，PrintWriter 更快。\nimport java.io.BufferedWriter;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.IOException;\n\nSystem.out.println(&quot;Hello World!&quot;);\nSystem.out.printf(&quot;Value: %d%n&quot;, 123); // %n 是平台独立的换行符\n\n// 使用PrintWriter (更推荐用于竞技编程，速度快)\nPrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\npw.println(&quot;Result: &quot; + result);\npw.print(&quot;Another line without newline.&quot;);\npw.printf(&quot;Formatted output: %.2f%n&quot;, 123.456);\npw.flush(); // 确保输出被写入缓冲区，非常重要！\n// pw.close(); // 在程序结束时关闭，但竞技编程中通常不需要显式关闭System.out的PrintWriter\n\n\n\n\n\n竞技编程I/O模板：\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer; // 用于更高效地分割字符串\n\npublic class Main {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    static StringTokenizer st;\n\n    // 读取下一个token\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    // 读取下一个整数\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    // 读取下一个长整数\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    // 读取下一个双精度浮点数\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    // 读取一行\n    static String readLine() throws IOException {\n        return br.readLine();\n    }\n\n    public static void main(String[] args) throws IOException {\n        // 在这里编写您的主要逻辑\n        int T = nextInt(); // 读取测试用例数量\n        while (T-- &gt; 0) {\n            int N = nextInt();\n            int M = nextInt();\n            pw.println(N + M); // 打印结果\n        }\n\n        pw.flush(); // 务必刷新缓冲区\n        // pw.close(); // 通常不需要显式关闭\n    }\n}\n\n6. 其他常用工具类\n\n\n字符串：\n\n\nC++: std::string\n\n\nJava: java.lang.String (不可变), java.lang.StringBuilder (可变，用于字符串拼接，性能优于+操作符)。C++的std::string是可变的，而Java的String是不可变的。频繁的字符串修改操作应使用StringBuilder，类似于C++中对字符串进行大量拼接时考虑的效率问题。\n\n\n\n\n数学运算：\n\n\nC++: &lt;cmath&gt; 中的函数\n\n\nJava: java.lang.Math 类提供了各种数学函数（sqrt, pow, abs, min, max等）。\n\n\n\n\n大整数：\n\n\nC++: 通常需要手写或使用第三方库。\n\n\nJava: java.math.BigInteger (任意精度整数), java.math.BigDecimal (任意精度浮点数)。这是Java在竞技编程中的一大优势，可以直接处理超出long long范围的整数。\n\n\n\n\n时间/日期：\n\n\nC++: &lt;chrono&gt;, &lt;ctime&gt;\n\n\nJava: java.util.Date, java.util.Calendar (旧API)，java.time 包 (Java 8及以后推荐的新API，更强大和易用)。\n\n\n\n\n随机数：\n\n\nC++: &lt;random&gt;\n\n\nJava: java.util.Random。\n\n\n\n\n7. C++ STL算法在Java中的替代（更详细）\n许多C++ std::algorithm 中的函数在Java中没有直接的、通用的对应方法，但可以通过Stream API或手动实现来达到类似效果。\n\n\nstd::fill： 填充容器\n\nJava: Arrays.fill(array, value); 或手动循环。\n\n\n\nstd::copy： 复制元素\n\nJava: System.arraycopy(src, srcPos, dest, destPos, length); 或手动循环。\n\n\n\nstd::unique： 去重（需要先排序）\n\n\nJava: 通常结合Stream API或手动遍历。\nList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(List.of(1, 2, 2, 3, 3, 3, 4));\n// 使用Stream API去重\nList&lt;Integer&gt; distinctNumbers = numbers.stream().distinct().collect(Collectors.toList());\nSystem.out.println(distinctNumbers); // [1, 2, 3, 4]\n\n\n\n\n\nstd::next_permutation / std::prev_permutation： 生成下一个/上一个字典序排列\n\nJava: 没有直接的库函数。通常需要自己实现，算法与C++的实现原理类似。\n\n\n\nstd::iota： 填充递增序列\n\n\nJava: 手动循环。\nint[] arr = new int[5];\nfor (int i = 0; i &lt; arr.length; i++) {\n    arr[i] = i + 1; // 填充 1, 2, 3, 4, 5\n}\n\n\n\n\n\n8. 性能注意事项\n\n\n自动装箱/拆箱： Java集合框架只能存储对象，因此当你将基本类型（int, double等）放入集合时，它们会自动装箱（转换为对应的包装类Integer, Double等），取出时会自动拆箱。这会带来额外的性能开销和内存消耗。在竞技编程中，如果性能敏感，有时会使用基本类型数组而不是ArrayList&lt;Integer&gt;。\n\n\nhashCode() 和 equals()： 对于HashSet, HashMap, TreeSet, TreeMap等基于哈希或比较的集合，如果你存储自定义对象，必须正确重写hashCode()和equals()（对于哈希表）或实现Comparable / 提供Comparator（对于树结构），否则集合的行为可能不符合预期。\n\n\nStream API： Java 8引入的Stream API提供了非常简洁和函数式的编程风格，但其性能开销可能比传统循环略高。在对性能要求极高的竞技编程场景中，有时仍需权衡使用。\n\n\n9. 面向对象特性\nJava是纯粹的面向对象语言，这意味着一切皆对象（除了基本类型）。STL中的容器和算法在Java中也以类和对象的形式存在。\n\n\n方法调用： C++中你可能习惯于std::sort(vec.begin(), vec.end())，而在Java中，你会看到Collections.sort(list)，这是Collections工具类的静态方法。集合自身也有方法，如list.add()，map.get()。\n\n\n接口： Java集合框架大量依赖接口。理解List, Set, Map, Queue等接口的定义及其具体实现类的特点是掌握JCF的关键。\n\n\n总结\nJava的集合框架和核心库提供了与C++ STL非常相似的功能，甚至在某些方面（如内置的大整数支持、Stream API）更为强大。作为C++ ACMer，您在数据结构和算法方面的知识将是巨大的优势。您需要适应的是Java的面向对象特性、接口与实现的分离、泛型的工作方式以及一些常用的工具类。掌握了这些，您会发现用Java进行竞技编程同样高效和愉快。\n祝您在Java的竞技编程之旅中取得好成绩！"},"有感":{"slug":"有感","filePath":"有感.md","title":"有感","links":[],"tags":[],"content":"一千天啦～祝贺祝贺，按照markdown格式这里可以插入一张图片，点开能看到我们亲嘴子\n感觉朋友圈子里谈到一千天的人也不多吧，亮亮那个闷骚没有发什么长篇大论，王健涵我也不知道一千天没有，打完这段话我就去问问\n上大学半年 我们对很多事情都有了新的体会，聊天的内容也越来越沉重，越来越现实。大概对于我而言，能跟有些人说上话真的得得益于同学这层纽带，好比在社会上见了宇轩我得叫周总，但是有同学情谊在我居然可以叫他儿子。\n之前看到过一个视频，说建议男生在大学谈一段恋爱，因为这是”翻盘的最好机会，大学里的白富美会因为你唱歌好听跟你约会，然而出了社会没人会搭理你”，我们还一起讨论过这个视频，得出的结论是这种行为虽不仁义却十分真实，现在的大学已经慢慢的退出了分配财富的舞台，有时候不免感觉“这么努力还不如找富婆包养来的实在”。也正是因为这样，我居然会在一些时候突然觉得黄景怡是一个虚无缥缈的存在，好像她这段时间只是用来陪我过家家，时间一到就去跟什么大国的王室联姻，从此只能在新闻上看到她和她的宫殿\n我自认为不是一个非常成功的人，很有个性但是没什么能耐，感觉高三飘了一年被高考打回现实了，一年前的今天我可能还跟刘佳南两个半夜不睡觉搬凳子出去阳台吹牛逼然后被陈超穿着树懒睡衣出来说“哥们你们吵死我了”，现在的爱好变成了跟他约着出去打台球的时候喝点小酒然后互相诉苦，发泄对这个很操蛋的世界的不满\n家境不提也罢，偏偏她又那么有才华，我在大学更加努力。我不止一次跟黄景怡说“我真的很怕给不起彩礼 让你过得不舒服”云云，黄景怡也反复跟我说“没关系， 跟你在一起的话没什么钱也是可以的” 。每每想到能让她说出这样有点主观有点扯淡的话，我就觉得我又有活着的动力了\n黄景怡是一个很聪明，很心细的人，在解人意这方面有先天性的优势。但她不是一个外向的人，导致很多时候她都是自我内耗 然后自己解了自己的人意 如果说我在这段恋爱关系中帮到了她什么，大概也就只有“让她变得自信起来”  她现在会跟我分享自己好看的和摆了鬼脸的照片，有精致的也有披头散发的，她不再害怕跟我打视频通话，也允许我在朋友圈发她的 被抓拍照片 看到她的思维，她的伤心难过事一点一点暴露在我面前，我有点接受不了，因此说过“不想听你的负面情绪”这种很极端的言论，但是她没有放弃 在恋爱中一点点把解人意的技巧传授给我，导致我的脾气随着恋爱变好了（有吗？一些人说有）也感觉不再是木头脑袋，也发现女孩子没有那么莫名其妙那么难哄。\n跨省异地恋 是非常 非常 非常痛苦的 我本身情况特殊，父母都是来深打工的，导致我虽然在深圳长大但是逢年过节还是得回老家，哈尔滨的大雪把寒假时间（从我的认知中）延长到了六十天，但我们见面的次数竟寥寥无几 挽着手逛街之后总要分别，每到这时候她就说不想分开，其实我也不想分开，也许我们受不了的其实不是分开，而是长时间未能见面短暂满足心愿又被迫很快分离的愿望破碎感。\n所以我不会后悔1月2号下午做的那个 一个人做十六个半小时硬座去北京的 疯狂决定，也很期待五月一号那个五天假期我们去哪玩\n越写越感觉我其实对她没那么好，黄景怡你是怎么看上我这人的呢？我们两个能情投意合的谈一千天之多 究竟是射箭的还是牵红线的立了功？\n开了学我们都一堆课要忙 更没什么机会聊天，感觉我礼物也不会送，话也说不好听，但是她说要跟我过一辈子诶，那我是应该努努力 ^^\n她已经完完全全的改变了我，让我有了吃饭的时候拍照给她分享食物的习惯（并因此被大学舍友喷是恋爱脑），让我有了更加辩证，更加全面的思考态度 而不是一个非黑即白的人，跟我说了很多为人处世的道理 让我三天可见的朋友圈挂了一堆恋爱日常的置顶，让我在冰城每天都很想她\n所以我打了这些字，放在朋友圈请大家见证：==我不想做一个只会画饼的人，我会尽我的努力让我们俩过得更好 =="}}